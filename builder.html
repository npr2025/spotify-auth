<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TDCS Builder — Singles(1–4) • ArtistID lock • Primary-only • Pin @19 • 強化検索＋レート制御</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
           max-width:1080px;margin:24px auto;padding:0 12px;background:#0b1220;color:#cfe3ff;}
    h1{margin:0 0 8px;font-size:20px;}
    fieldset{border:1px solid #22324f;border-radius:10px;margin:10px 0;padding:12px;}
    legend{padding:0 8px;color:#bcd1f5;}
    label{display:block;margin:8px 0 4px;}
    input[type="text"],input[type="number"],select{width:100%;max-width:640px;padding:9px;border-radius:8px;
      border:1px solid #2d3e60;background:#091426;color:#cfe3ff;}
    input[type="checkbox"]{transform:scale(1.05);margin-right:6px;}
    button{padding:10px 14px;border-radius:8px;border:1px solid #3a4d75;background:#14213a;color:#e9f1ff;cursor:pointer;}
    #log{white-space:pre-wrap;background:#091426;color:#d6e6ff;border:1px solid #20304a;padding:12px;border-radius:10px;
      margin-top:12px;max-height:560px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center;}
    .row>*{flex:1 1 auto;}
    .muted{color:#8ea6cc;}
  </style>
</head>
<body>
<h1>TDCS Builder — Singles(1–4) • ArtistID lock • Primary-only • Pin @19 • 強化検索＋レート制御</h1>

<fieldset>
  <legend>Auth</legend>
  <div id="authStatus" class="muted">No token.</div>
  <div class="row" style="margin-top:8px">
    <button id="btnSignIn">Sign in</button>
    <button id="btnSignOut">Sign out (local)</button>
  </div>
</fieldset>

<fieldset>
  <legend>Constraints</legend>
  <label>Artist IDs（カンマ区切り。<b>先頭IDを“固定メイン”</b>として扱います）
    <input id="artistIds" type="text" value="55fvQ5I2IZUfcFT2DV02T3">
  </label>
  <label><input id="primaryOnly" type="checkbox" checked> Primary-artist only（原則：artists[0].id=固定メイン）</label>
  <label><input id="strictSingles" type="checkbox" checked> Singlesのみ（1–4曲）</label>
  <label><input id="fallbackAllowFeatured" type="checkbox" checked> 固定メインが先頭でなくても、1–4曲シングルなら採用（修正依頼に記録）</label>
  <label><input id="useCatalogNumber" type="checkbox" checked> Catalog number（例: NPR226）も検索語に含める</label>
  <div class="row">
    <label>Pin track (URL/URI)
      <input id="pinUri" type="text" value="https://open.spotify.com/track/3bBCxxbNkrl1DlBlxATNVQ">
    </label>
    <label>Pin position（1始まり）
      <input id="pinPos" type="number" min="1" value="19">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>Playlist & Rate</legend>
  <label><input id="isPublic" type="checkbox"> Public playlist</label>
  <label><input id="uniqueUris" type="checkbox" checked> 重複を除外</label>
  <label>Build for user（任意）
    <input id="userIdOverride" type="text" placeholder="22fqn5mozguuegi2t3l2zeugy" value="22fqn5mozguuegi2t3l2zeugy">
  </label>
  <div class="row">
    <label>Playlist name prefix
      <input id="prefix" type="text" value="TDCS - Singles(1-4) - ">
    </label>
    <label><input id="useFileName" type="checkbox" checked> プレイリスト名にCSVファイル名を使用</label>
  </div>
  <div class="row">
    <label>Search market
      <select id="searchMarket">
        <option value="from_token" selected>from_token</option>
        <option value="JP">JP</option><option value="US">US</option><option value="GB">GB</option>
        <option value="DE">DE</option><option value="FR">FR</option><option value="ES">ES</option>
        <option value="NL">NL</option><option value="SE">SE</option><option value="BR">BR</option>
      </select>
    </label>
    <label>Rate mode
      <select id="rateMode">
        <option value="gentle" selected>Gentle (安全)</option>
        <option value="normal">Normal</option>
        <option value="aggressive">Aggressive</option>
      </select>
    </label>
    <div>
      <button id="btnAbort" title="現在のリクエスト終了後に停止">Abort</button>
    </div>
  </div>
</fieldset>

<fieldset>
  <legend>CSV</legend>
  <label>Choose CSV（複数可）
    <input id="csvFiles" type="file" accept=".csv" multiple>
  </label>
  <div class="row" style="margin-top:8px">
    <button id="btnBuild">Build playlists（CSVごとに1つ）</button>
    <button id="btnExportNF">Export not-found.csv（直近の実行）</button>
    <button id="btnExportCorr">Export distributor-correction.txt（直近の実行）</button>
  </div>
  <div class="muted" style="margin-top:8px">
    受理列: <code>order</code>, <code>Catalog number</code>, <code>title</code>, <code>remixer</code>, <code>isrc</code>, <code>spotify_query</code>, <code>Original file name</code><br>
    ISRC列が無い場合は <em>Original file name</em> から抽出を試みます。
  </div>
</fieldset>

<pre id="log">Ready.</pre>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
/* ---------- Logging / Utils ---------- */
const LOG=(...a)=>{const el=document.getElementById('log');el.textContent+="\n"+a.join(' ');el.scrollTop=el.scrollHeight;}
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
function download(name, text){
  const blob=new Blob([text],{type:'text/plain;charset=utf-8;'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a');
  a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

/* ---------- Sign-in button: return_to を保存して auth.html へ ---------- */
document.getElementById('btnSignIn').onclick=()=>{
  try{ sessionStorage.setItem('return_to', location.href); }catch(_){}
  location.href='auth.html';
};

/* ---------- Abort control ---------- */
let ABORT=false;
document.getElementById('btnAbort').onclick=()=>{ ABORT=true; LOG('Abort requested. 現在のリクエスト完了後に停止します。'); };
function checkAbort(){ if(ABORT) throw new Error('aborted'); }

/* ---------- Auth & Token (with auto refresh) ---------- */
function token(){return sessionStorage.getItem('access_token')}
function tokenExpiresAt(){return Number(sessionStorage.getItem('access_token_expires_at')||0)}
function refreshToken(){return sessionStorage.getItem('refresh_token')}
const CLIENT_ID='5b4dc486f92a46878665468fa5de9361';
const TOKEN_URL='https://accounts.spotify.com/api/token';

async function refreshIfNeeded(){
  const now=Date.now(), exp=tokenExpiresAt();
  if(token() && exp && now < exp-60*1000) return; // 60秒の余裕
  const rt=refreshToken(); if(!rt) return; // 無ければスキップ
  LOG('Refreshing token…');
  const res=await fetch(TOKEN_URL,{
    method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'},
    body:new URLSearchParams({ grant_type:'refresh_token', refresh_token:rt, client_id:CLIENT_ID })
  });
  if(res.ok){
    const t=await res.json();
    if(t.access_token) sessionStorage.setItem('access_token', t.access_token);
    if(t.refresh_token) sessionStorage.setItem('refresh_token', t.refresh_token);
    if(t.expires_in){ sessionStorage.setItem('access_token_expires_at', String(Date.now()+t.expires_in*1000)); }
  }else{
    LOG('Refresh failed:', res.status); // 必要ならサインアウト
  }
}

function needToken(){const t=token();if(!t)throw new Error('no_token');return t}
async function me(){await refreshIfNeeded(); return api('https://api.spotify.com/v1/me')}
function setAuthStatus(msg){document.getElementById('authStatus').textContent=msg}

/* ---------- Global Rate Limiter (Queue + Backoff) ---------- */
const Rate = { minDelay:350, maxDelay:3000, nextAt:0, inFlight:0, attempts429:0 };
function applyRateMode(mode){
  if(mode==='aggressive'){ Rate.minDelay=120; Rate.maxDelay=1500; }
  else if(mode==='normal'){ Rate.minDelay=220; Rate.maxDelay=2000; }
  else { Rate.minDelay=350; Rate.maxDelay=3000; }
}
async function gate(){
  while(Rate.inFlight>0){ await sleep(10); }
  Rate.inFlight=1;
  const now=Date.now();
  if(Rate.nextAt>now){ await sleep(Rate.nextAt-now); }
}
function release(){ Rate.inFlight=0; }

async function api(url,opt={}, attempt=0){
  checkAbort();
  await refreshIfNeeded();
  await gate();
  const headers=Object.assign({'Authorization':'Bearer '+needToken()}, opt.headers||{});
  try{
    const res=await fetch(url, Object.assign({}, opt, {headers}));
    if(res.status===429){
      const retrySec = Number(res.headers.get('Retry-After')||'2');
      Rate.attempts429++;
      const grow = Math.min(Rate.maxDelay, Math.max(Rate.minDelay*Math.pow(1.5,Rate.attempts429), retrySec*1000));
      Rate.minDelay = Math.min(Rate.maxDelay, Math.max(Rate.minDelay, grow));
      const jitter = Math.floor(Math.random()*300);
      Rate.nextAt = Date.now() + Math.max(retrySec*1000, Rate.minDelay) + jitter;
      LOG(`429 -> backoff ${(Rate.nextAt-Date.now())/1000|0}s (minDelay=${Rate.minDelay}ms, attempt=${Rate.attempts429})`);
      release();
      if(attempt<6){ await sleep(Math.max(0, Rate.nextAt-Date.now())); return api(url,opt,attempt+1); }
      throw new Error('API 429 too many attempts');
    }
    Rate.attempts429=0;
    Rate.nextAt = Date.now() + Rate.minDelay;
    if(!res.ok){
      const txt=await res.text(); throw new Error('API '+res.status+': '+txt);
    }
    const json=await res.json();
    release();
    return json;
  }catch(e){ release(); throw e; }
}

/* ---------- Normalizers ---------- */
function normTitle(s){return (s||'').toLowerCase().replace(/[‐–—−]/g,'-').replace(/[’`]/g,"'").replace(/\s+/g,' ').trim();}
function stripParens(s){return (s||'').replace(/\s*$begin:math:text$[^)]*$end:math:text$\s*/g,' ').replace(/\s+/g,' ').trim();}
function extractISRC(s){if(!s)return'';const m=String(s).match(/\b[A-Z]{2}[A-Z0-9]{3}\d{7}\b/);return m?m[0]:'';}

function normalizeRow(raw){
  const lower={};for(const k in raw) lower[k.toLowerCase()]=k;
  const pick=k=>raw[lower[k]];
  const row={};
  row.order=pick('order')??raw.order??'';
  row.catalog=pick('catalog number')??pick('catalog')??pick('catalog_number')??'';
  row.title=pick('title')??raw.title??pick('track')??'';
  row.remixer=pick('remixer')??pick('remixers')??'';
  let isrc=pick('isrc')??''; if(!isrc || String(isrc).trim()===''){ isrc=extractISRC(pick('original file name')??''); }
  row.isrc=String(isrc||'').trim();
  row.spotify_query=pick('spotify_query')??'';
  row._order=Number(row.order||0);
  return row;
}

/* ---------- Remixers / Aliases ---------- */
function splitRemixers(remixer){
  if(!remixer) return [];
  const s = String(remixer).replace(/\bfeat\.?\b/ig, ',').replace(/\s+x\s+/ig, ',').replace(/\s*&\s*/g, ',');
  return s.split(',').map(x=>x.trim()).filter(Boolean);
}
function tdcsAliases(){ return ['The Darrow Chem Syndicate','Darrow Chem Syndicate','TDCS']; }

/* ---------- Query builder ---------- */
function buildQueries(row, useCatno){
  const qs=new Set();
  const tRaw=String(row.title||'').trim();
  const tClean=stripParens(tRaw);
  const remixers=splitRemixers(row.remixer);
  const cat = row.catalog ? String(row.catalog).trim() : '';
  const aliases = tdcsAliases();

  if(row.isrc) qs.add('isrc:'+row.isrc);
  if(row.spotify_query && String(row.spotify_query).trim()) qs.add(String(row.spotify_query).trim());

  for(const name of aliases){
    if(tRaw) qs.add(`track:"${tRaw}" artist:"${name}"`);
    if(tClean && tClean!==tRaw) qs.add(`track:"${tClean}" artist:"${name}"`);
    if(tRaw && remixers.length){
      for(const r of remixers){
        qs.add(`track:"${tRaw}" ${r} remix artist:"${name}"`);
        qs.add(`"${tRaw} (${r} Remix)" "${name}"`);
      }
      if(remixers.length>=2){
        const joined = remixers.join(' ');
        qs.add(`track:"${tRaw}" ${joined} remix artist:"${name}"`);
      }
    }
    if(tRaw) qs.add(`${tRaw} "${name}"`);
    if(tClean && tClean!==tRaw) qs.add(`${tClean} "${name}"`);
  }
  if(tRaw){
    qs.add(`track:"${tRaw}" remix`);
    for(const r of remixers){ qs.add(`track:"${tRaw}" "${r}" remix`); }
    qs.add(`${tRaw} remix`);
  }
  if(useCatno && cat && tRaw){
    qs.add(`"${cat}" "${tRaw}"`);
    for(const name of aliases){ qs.add(`"${cat}" "${tRaw}" "${name}"`); }
  }
  return Array.from(qs);
}

/* ---------- Artist / Single checks ---------- */
function parseArtistIds(){ return document.getElementById('artistIds').value.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean); }
function mainArtistId(){ return parseArtistIds()[0] || ''; }
function artistNames(arts){ return (arts||[]).map(a=>a.name).join(', '); }

function hasArtist(track, whitelist, primaryOnly){
  const arts=track?.artists||[];
  if(primaryOnly){
    const a0=arts[0]?.id;
    return a0 && whitelist.includes(a0);
  }
  return arts.some(a=>whitelist.includes(a.id));
}
const albumTotalCache=new Map();
async function getAlbumTotalTracks(albumId){
  if(!albumId) return null;
  if(albumTotalCache.has(albumId)) return albumTotalCache.get(albumId);
  const data=await api('https://api.spotify.com/v1/albums/'+encodeURIComponent(albumId));
  const tt=(typeof data?.total_tracks==='number')?data.total_tracks:null;
  albumTotalCache.set(albumId,tt);
  await sleep(25);
  return tt;
}
function singleCheckLocal(track, strict){
  if(track?.album?.album_type!=='single') return false;
  const tt=track?.album?.total_tracks;
  if(typeof tt!=='number'||tt<=0) return 'unknown';
  return strict ? (tt>=1 && tt<=4) : true;
}

/* ---------- Search layers ---------- */
async function searchTracks(q, market){
  const base='https://api.spotify.com/v1/search?q='+encodeURIComponent(q)+'&type=track&limit=50';
  const url=(market && market!=='from_token') ? (base+'&market='+encodeURIComponent(market)) : base;
  return api(url);
}
async function searchAlbums(q, market){
  const base='https://api.spotify.com/v1/search?q='+encodeURIComponent(q)+'&type=album&limit=50';
  const url=(market && market!=='from_token') ? (base+'&market='+encodeURIComponent(market)) : base;
  return api(url);
}
const artistAlbumsCache=new Map(); // key: artist|market|groups
async function getArtistAlbums(artistId, market, groups='single'){
  const key=artistId+'|'+(market||'')+'|'+groups;
  if(artistAlbumsCache.has(key)) return artistAlbumsCache.get(key);
  const albums=[];
  let url=`https://api.spotify.com/v1/artists/${encodeURIComponent(artistId)}/albums?include_groups=${groups}&limit=50${market&&market!=='from_token'?`&market=${encodeURIComponent(market)}`:''}`;
  let guard=0;
  while(url && guard++<8){
    const data=await api(url);
    (data.items||[]).forEach(a=>albums.push({id:a.id,total_tracks:a.total_tracks||null, album_type:a.album_type, name:a.name}));
    url=data.next;
    await sleep(40);
  }
  artistAlbumsCache.set(key,albums); return albums;
}

/* ---------- Global collectors ---------- */
let lastNotFoundRows=[];
let lastPrimaryIssues=[];

/* ---------- Match helper ---------- */
function titleMatch(a,b){const na=normTitle(a), nb=normTitle(b);return na===nb || na.includes(nb) || nb.includes(na);}

/* ---------- Resolver ---------- */
async function resolveTrack(row, market, strictSingles, whitelist, primaryOnly){
  checkAbort();
  const useCatno = document.getElementById('useCatalogNumber').checked;
  const allowFeatured = document.getElementById('fallbackAllowFeatured').checked;
  const markets = (market && market!=='from_token') ? [market] : ['', 'JP','US','GB','DE','FR','ES','NL','SE','BR'];
  const qs = buildQueries(row, useCatno);

  const consider = async (it, mkt, sourceLabel) => {
    let ok = false;
    const chk=singleCheckLocal(it, strictSingles);
    if(chk===true){ ok=true; }
    else if(chk==='unknown'){
      const tt=await getAlbumTotalTracks(it.album?.id);
      ok = !!(tt && tt>=1 && tt<=4);
    }
    if(!ok) return null;

    const arts=it.artists||[];
    const names=artistNames(arts);
    const main=mainArtistId();
    const containsMain = arts.some(a=>a.id===main);
    const mainIsFirst = arts[0]?.id===main;

    if(primaryOnly){
      if(mainIsFirst) return {uri:it.uri, issue:null};
      if(allowFeatured && containsMain){
        const note = `【primary順序要修正】"${it.name}" — ${names}\nURI: ${it.uri}\n理由: 固定メイン(${main})が先頭でなく、primaryが複数/順序違いの可能性（市場:${mkt} / src:${sourceLabel}）。シングル(1–4)のため採用。`;
        return {uri:it.uri, issue:note};
      }
      return null;
    }else{
      if(containsMain){
        if(!mainIsFirst){
          const note = `【primary順序要修正】"${it.name}" — ${names}\nURI: ${it.uri}\n理由: 固定メイン(${main})が先頭でなく、primaryが複数/順序違いの可能性（市場:${mkt} / src:${sourceLabel}）。`;
          return {uri:it.uri, issue:note};
        }
        return {uri:it.uri, issue:null};
      }
      return null;
    }
  };

  // A: 厳格（primary-only先頭一致）
  for(const mkt of markets){
    for(const q of qs){
      checkAbort();
      try{
        const res=await searchTracks(q, mkt);
        const items=(res?.tracks?.items||[]).filter(x=>x?.uri?.startsWith('spotify:track:') && hasArtist(x,whitelist,true));
        for(const it of items){
          const r = await consider(it, mkt, 'searchA');
          if(r) return r;
          await sleep(15);
        }
      }catch(e){ LOG('searchA error', e.message); }
      await sleep(50);
    }
  }
  // B: 緩和（allowFeaturedで採用可＋修正依頼）
  for(const mkt of markets){
    for(const q of qs){
      checkAbort();
      try{
        const res=await searchTracks(q, mkt);
        const items=(res?.tracks?.items||[]).filter(x=>x?.uri?.startsWith('spotify:track:'));
        const filtered = allowFeatured
          ? items.filter(x => (x.artists||[]).some(a=>whitelist.includes(a.id)))
          : items.filter(x => hasArtist(x,whitelist,primaryOnly));
        for(const it of filtered){
          const r = await consider(it, mkt, 'searchB');
          if(r) return r;
          await sleep(15);
        }
      }catch(e){ LOG('searchB error', e.message); }
      await sleep(50);
    }
  }
  // C: アーティスト single/appears_on を走査（タイトルゆる一致）
  for(const mkt of markets){
    for(const aid of whitelist){
      for(const groups of ['single','appears_on']){
        checkAbort();
        try{
          const albums=await getArtistAlbums(aid, mkt, groups);
          for(const a of albums){
            if(a.album_type!=='single') continue;
            const tt=(typeof a.total_tracks==='number')?a.total_tracks:await getAlbumTotalTracks(a.id);
            if(!(tt && tt>=1 && tt<=4)) continue;
            const tr=await api(`https://api.spotify.com/v1/albums/${encodeURIComponent(a.id)}/tracks?limit=50${mkt&&mkt!=='from_token'?`&market=${encodeURIComponent(mkt)}`:''}`);
            for(const t of (tr.items||[])){
              if(!titleMatch(t.name, row.title||'')) continue;
              const fakeTrack = { uri:t.uri, name:t.name, artists:t.artists||[], album:{album_type:'single', total_tracks:tt, id:a.id} };
              const r = await consider(fakeTrack, mkt, 'albums');
              if(r) return r;
            }
            await sleep(30);
          }
        }catch(e){ LOG('albums error', e.message); }
      }
    }
  }

  return null;
}

/* ---------- Pin / Playlist ---------- */
function toTrackUri(s){
  if(!s) return null;
  if(String(s).startsWith('http')){
    const m=String(s).match(/track\/([a-zA-Z0-9]+)/);
    if(m) return 'spotify:track:'+m[1];
  }
  return s;
}
async function createPlaylist(name, isPublic){
  const override=document.getElementById('userIdOverride').value.trim();
  const uid=override || (await me()).id;
  return api('https://api.spotify.com/v1/users/'+encodeURIComponent(uid)+'/playlists',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({name, public:!!isPublic, description:'Singles(1–4) • ArtistID lock • Primary-only • Pinned'})
  });
}
async function addUris(pid, uris){
  for(let i=0;i<uris.length;i+=100){
    const chunk=uris.slice(i,i+100);
    await api('https://api.spotify.com/v1/playlists/'+pid+'/tracks',{
      method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({uris:chunk})
    });
    LOG('added', Math.min(i+100, uris.length), '/', uris.length);
    await sleep(80);
  }
}

/* ---------- Exporters ---------- */
function exportNotFound(){
  if(!lastNotFoundRows.length){ alert('not-found はありません'); return; }
  const header=['source_file','index','title','remixer','isrc','catalog'];
  const rows=lastNotFoundRows.map(r=>[r.source,r.index,r.title||'',r.remixer||'',r.isrc||'',r.catalog||'']);
  const csv=[header.join(','), ...rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(','))].join('\n');
  download('not-found.csv', csv);
}
function exportCorrections(){
  if(!lastPrimaryIssues.length){ alert('修正依頼はありません'); return; }
  const lines = [
    '【ディストリビューター様 修正依頼（primary順序/重複primaryの可能性）】',
    '固定メイン（Artist ID 先頭）: ' + mainArtistId(),
    '',
    '以下のトラックは、固定メインが先頭でなく、primaryが複数/順序違いの可能性があります。',
    '「メイン＝固定アーティスト」になるようクレジット順序のご確認・修正をご検討ください。',
    '(プレイリストにはシングル1–4曲の条件を満たすため暫定採用しています)',
    ''
  ].concat(lastPrimaryIssues);
  download('distributor_correction.txt', lines.join('\n'));
}

/* ---------- Build (pin = [ok]のN曲目直前) ---------- */
async function buildOneCSV(file, opts){
  LOG('--- CSV:', file.name, '---');
  const rows=await new Promise((resolve,reject)=>{
    Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>resolve(r.data),error:reject});
  });
  const norm=rows.map(normalizeRow).sort((a,b)=>(a._order||0)-(b._order||0));
  LOG('rows:', norm.length);

  const {market,isPublic,unique,prefix,useFileName,strictSingles,whitelist,primaryOnly,pinUri,pinPos}=opts;
  const seen=new Set(); const uris=[];
  let okCount=0; const pinIndex0=Math.max(0, Number(pinPos||19)-1);

  for(let i=0;i<norm.length;i++){
    checkAbort();
    const r=norm[i];
    try{
      const res=await resolveTrack(r, market, strictSingles, whitelist, primaryOnly);
      if(res && res.uri){
        if(pinUri && okCount===pinIndex0){
          if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin @', pinIndex0+1, pinUri); }
        }
        if(!unique || !seen.has(res.uri)){ uris.push(res.uri); seen.add(res.uri); okCount++; LOG('[ok]', i+1, res.uri); }
        else { LOG('[dup] skip', i+1, res.uri); }
        if(res.issue){ lastPrimaryIssues.push(res.issue); LOG('[note] primary要修正 追記'); }
      }else{
        LOG('[x] not found', i+1, r.title||'');
        lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
      }
    }catch(e){
      if(e.message==='aborted'){ LOG('中断しました'); return; }
      LOG('[!] error', i+1, (r.title||''), e.message);
      lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
    }
  }

  if(pinUri && okCount<=pinIndex0){
    if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin (tail)', pinUri); }
  }

  const base=file.name.replace(/\.csv$/i,'').slice(0,140);
  const name=useFileName ? (prefix + base) : (prefix || 'TDCS - Singles(1-4)');
  const pl=await createPlaylist(name, isPublic);
  LOG('playlist:', pl.external_urls?.spotify||'');
  if(uris.length) await addUris(pl.id, uris);
  LOG('DONE', file.name, '->', pl.external_urls?.spotify||'');
}

/* ---------- UI ---------- */
document.getElementById('btnBuild').onclick=async()=>{
  try{ needToken(); }catch(_){ alert('Sign in first'); return; }
  ABORT=false; lastNotFoundRows=[]; lastPrimaryIssues=[];
  const files=[...(document.getElementById('csvFiles').files||[])];
  if(!files.length){ alert('Choose CSV'); return; }

  applyRateMode(document.getElementById('rateMode').value);

  const opts={};
  opts.isPublic=document.getElementById('isPublic').checked;
  opts.unique=document.getElementById('uniqueUris').checked;
  opts.market=document.getElementById('searchMarket').value;
  opts.prefix=document.getElementById('prefix').value||'';
  opts.useFileName=document.getElementById('useFileName').checked;
  opts.strictSingles=document.getElementById('strictSingles').checked;
  opts.primaryOnly=document.getElementById('primaryOnly').checked;
  opts.whitelist=parseArtistIds();
  opts.pinUri=toTrackUri(document.getElementById('pinUri').value.trim());
  opts.pinPos=Number(document.getElementById('pinPos').value||19);

  for(const f of files){
    if(ABORT) break;
    await buildOneCSV(f, opts);
  }

  if(lastPrimaryIssues.length){ exportCorrections(); }
  if(ABORT){ alert('中断しました。ログを確認してください。'); }
  else { alert('All done. 必要なら「Export not-found.csv」もどうぞ。'); }
};
document.getElementById('btnExportNF').onclick=exportNotFound;
document.getElementById('btnExportCorr').onclick=exportCorrections;
document.getElementById('btnSignOut').onclick=()=>{ sessionStorage.clear(); localStorage.removeItem('code_verifier'); setAuthStatus('No token.'); LOG('Signed out (local).'); };

(async()=>{
  try{
    if(!token()) throw 0;
    const m=await me(); setAuthStatus('Signed in as '+(m.display_name||m.id));
  }catch(_){ setAuthStatus('No token.'); }
})();
</script>
</body>
</html>
