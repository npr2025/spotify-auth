
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TDCS Playlist Builder — Singles(1–4) • ArtistID-locked • Pin @19</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
           max-width: 1000px; margin: 24px auto; padding: 0 12px; background: #0b1220; color: #cfe3ff; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    fieldset { border: 1px solid #22324f; border-radius: 10px; margin: 10px 0; padding: 12px; }
    legend { padding: 0 8px; color: #bcd1f5; }
    label { display: block; margin: 8px 0 4px; }
    input[type="text"], input[type="number"], select { width: 100%; max-width: 640px; padding: 9px; border-radius: 8px;
                                 border: 1px solid #2d3e60; background: #091426; color: #cfe3ff; }
    input[type="checkbox"] { transform: scale(1.05); margin-right: 6px; }
    button { padding: 10px 14px; border-radius: 8px; border: 1px solid #3a4d75; background: #14213a; color: #e9f1ff; cursor: pointer; }
    #log { white-space: pre-wrap; background: #091426; color: #d6e6ff; border: 1px solid #20304a; padding: 12px; border-radius: 10px; margin-top: 12px; max-height: 540px; overflow: auto; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; }
    .row > * { flex: 1 1 auto; }
    .muted { color: #8ea6cc; }
  </style>
</head>
<body>
  <h1>TDCS Playlist Builder — Singles(1–4) • ArtistID-locked • Pin @19</h1>

  <fieldset>
    <legend>Auth</legend>
    <div id="authStatus" class="muted">No token.</div>
    <div class="row" style="margin-top:8px">
      <button onclick="location.href='auth.html'">Sign in</button>
      <button id="btnSignOut">Sign out (local)</button>
    </div>
  </fieldset>

  <fieldset>
    <legend>Constraints</legend>
    <label>Artist IDs (comma separated; results must include one of these artist IDs)
      <input id="artistIds" type="text" value="55fvQ5I2IZUfcFT2DV02T3">
    </label>
    <div class="row">
      <label>Pin track (URI or URL)
        <input id="pinUri" type="text" value="https://open.spotify.com/track/3bBCxxbNkrl1DlBlxATNVQ">
      </label>
      <label>Pin at position (1-based)
        <input id="pinPos" type="number" min="1" value="19">
      </label>
    </div>
  </fieldset>

  <fieldset>
    <legend>Settings</legend>
    <label>Playlist name prefix
      <input id="prefix" type="text" value="TDCS - Singles(1-4) - ">
    </label>
    <label class="row" style="align-items:center">
      <span><input id="useFileName" type="checkbox" checked> Use CSV filename as playlist name (prefix + filename)</span>
    </label>
    <div class="row">
      <label class="row" style="align-items:center"><span><input id="isPublic" type="checkbox"> Public playlist</span></label>
      <label class="row" style="align-items:center"><span><input id="uniqueUris" type="checkbox" checked> Unique tracks only</span></label>
      <label class="row" style="align-items:center"><span><input id="strictSingles" type="checkbox" checked> Strict: SINGLE with 1–4 tracks only</span></label>
    </div>
    <div class="row">
      <label>Build for user (override, optional)
        <input id="userIdOverride" type="text" placeholder="22fqn5mozguuegi2t3l2zeugy" value="22fqn5mozguuegi2t3l2zeugy">
      </label>
      <label>Search market
        <select id="searchMarket">
          <option value="from_token" selected>from_token</option>
          <option value="JP">JP</option><option value="US">US</option><option value="GB">GB</option>
          <option value="DE">DE</option><option value="FR">FR</option><option value="ES">ES</option>
          <option value="NL">NL</option><option value="SE">SE</option><option value="BR">BR</option>
        </select>
      </label>
    </div>
  </fieldset>

  <fieldset>
    <legend>CSV</legend>
    <label>Choose CSV files (multiple)
      <input id="csvFiles" type="file" accept=".csv" multiple>
    </label>
    <div class="row" style="margin-top:8px">
      <button id="btnBuild">Build playlists (one per CSV)</button>
    </div>
    <div class="muted" style="margin-top:8px">
      Columns (flexible names ok): order, Catalog number, title, remixer, isrc, spotify_query, Original file name.
    </div>
  </fieldset>

  <pre id="log">Ready.</pre>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    const LOG = (...a)=>{ const el=document.getElementById('log'); el.textContent += "\n" + a.join(' '); el.scrollTop = el.scrollHeight; };
    const sleep = ms => new Promise(r=>setTimeout(r, ms));

    function token(){ return sessionStorage.getItem('access_token') }
    function needToken(){ const t=token(); if(!t) throw new Error('no_token'); return t }
    async function api(url, opts={}){
      const headers = Object.assign({'Authorization':'Bearer '+needToken()}, opts.headers||{});
      const res = await fetch(url, Object.assign({}, opts, {headers}));
      if(res.status===429){
        const retry = Number(res.headers.get('Retry-After')||'2');
        LOG('429 wait', retry, 's');
        await sleep(retry*1000);
        return api(url, opts);
      }
      if(!res.ok){
        const txt = await res.text(); throw new Error('API '+res.status+': '+txt);
      }
      return res.json();
    }
    async function me(){ return api('https://api.spotify.com/v1/me') }
    function setAuthStatus(msg){ document.getElementById('authStatus').textContent = msg }

    // ----- CSV normalize & queries -----
    function extractISRC(s){
      if(!s) return '';
      const m = String(s).match(/\b[A-Z]{2}[A-Z0-9]{3}\d{7}\b/);
      return m ? m[0] : '';
    }
    function normalizeRow(raw){
      const lower = {}; for(const k in raw){ lower[k.toLowerCase()] = k; }
      const pick = key => raw[ lower[key] ];
      const row = {};
      row.order = pick('order') ?? raw.order ?? '';
      row.catalog = pick('catalog number') ?? pick('catalog') ?? pick('catalog_number') ?? '';
      row.title = pick('title') ?? raw.title ?? pick('track') ?? pick('track title') ?? pick('title (remixer remix)') ?? '';
      row.remixer = pick('remixer') ?? pick('remixers') ?? pick('artist') ?? '';
      let isrc = pick('isrc') ?? '';
      if(!isrc || String(isrc).trim()===''){
        const ofn = pick('original file name') ?? '';
        isrc = extractISRC(ofn);
      }
      row.isrc = String(isrc||'').trim();
      row.spotify_query = pick('spotify_query') ?? '';
      row._order = Number(row.order||0);
      return row;
    }
    function buildQueries(row){
      const qs = [];
      if(row.isrc) qs.push('isrc:'+row.isrc);
      if(row.spotify_query && String(row.spotify_query).trim()) qs.push(String(row.spotify_query).trim());
      const t = String(row.title||'').trim();
      const r = String(row.remixer||'').trim();
      if(t) qs.push('track:"'+t+'" artist:"The Darrow Chem Syndicate"');
      if(t && r) qs.push('track:"'+t+'" '+r+' remix artist:"The Darrow Chem Syndicate"');
      if(t) qs.push(t+' "The Darrow Chem Syndicate"');
      return qs;
    }

    // ----- Singles-only (1–4) + ArtistID filter -----
    const albumCache = new Map();
    async function getAlbumTotalTracks(album){
      let n = album?.total_tracks;
      if(typeof n === 'number' && n > 0) return n;
      const id = album?.id;
      if(!id) return null;
      if(albumCache.has(id)) return albumCache.get(id);
      const data = await api('https://api.spotify.com/v1/albums/' + encodeURIComponent(id));
      n = (typeof data?.total_tracks === 'number') ? data.total_tracks : null;
      albumCache.set(id, n);
      await sleep(40);
      return n;
    }
    function parseArtistIds(){
      const raw = document.getElementById('artistIds').value.trim();
      return raw.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean);
    }
    function hasWhitelistedArtist(track, whitelist){
      const artists = (track?.artists||[]).map(a=>a?.id).filter(Boolean);
      return artists.some(id => whitelist.includes(id));
    }
    async function pickSingle1to4_artistLocked(items, strict, whitelist){
      const filtered = items.filter(x => x?.type==='track' && x?.uri?.startsWith('spotify:track:') && hasWhitelistedArtist(x, whitelist));
      const singles = filtered.filter(x => x?.album?.album_type === 'single');
      if(!singles.length) return null;
      const scored = [];
      for(const it of singles.slice(0,12)){
        let tt = it?.album?.total_tracks;
        if(!(typeof tt === 'number' && tt > 0)){
          tt = await getAlbumTotalTracks(it.album);
        }
        scored.push({it, tt});
      }
      const inRange = scored.filter(s => typeof s.tt === 'number' && s.tt >= 1 && s.tt <= 4);
      if(inRange.length) return inRange[0].it;
      if(strict) return null;
      return singles[0];
    }
    async function resolveTrack(row, market, strict, whitelist){
      const qs = buildQueries(row);
      for(const q of qs){
        const url = 'https://api.spotify.com/v1/search?q=' + encodeURIComponent(q) + '&type=track&limit=12&market=' + encodeURIComponent(market);
        try{
          const res = await api(url);
          const items = (res?.tracks?.items||[]);
          const chosen = await pickSingle1to4_artistLocked(items, strict, whitelist);
          if(chosen) return chosen.uri;
        }catch(e){
          LOG('search error', e.message);
        }
        await sleep(100);
      }
      return null;
    }

    // ----- Build helpers -----
    function parsePinUri(){
      let s = document.getElementById('pinUri').value.trim();
      if(!s) return null;
      if(s.startsWith('http')){
        const m = s.match(/track\/([a-zA-Z0-9]+)/);
        if(m){ return 'spotify:track:' + m[1]; }
      }
      return s;
    }
    function splicePin(uris, pinUri, pos1based, unique){
      const idx = Math.max(0, Number(pos1based||1)-1);
      const arr = uris.slice();
      const already = arr.indexOf(pinUri);
      if(already >= 0){
        // move it to idx
        arr.splice(already,1);
      }
      const safeIdx = Math.min(idx, arr.length);
      if(unique){
        // avoid duplicate if pinUri is in uris later
        const rest = arr.filter(u => u !== pinUri);
        rest.splice(safeIdx, 0, pinUri);
        return rest;
      } else {
        arr.splice(safeIdx, 0, pinUri);
        return arr;
      }
    }

    async function createPlaylist(name, pub){
      const override = document.getElementById('userIdOverride').value.trim();
      const uid = override || (await me()).id;
      return api('https://api.spotify.com/v1/users/' + encodeURIComponent(uid) + '/playlists', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify({ name, public: !!pub, description: 'Singles(1–4) • ArtistID-locked • Pin @N' })
      });
    }
    async function addUris(pid, uris){
      for(let i=0;i<uris.length;i+=100){
        const chunk = uris.slice(i,i+100);
        await api('https://api.spotify.com/v1/playlists/' + pid + '/tracks', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ uris: chunk })
        });
        LOG('added', Math.min(i+100, uris.length), '/', uris.length);
        await sleep(100);
      }
    }

    async function buildOneCSV(file, market, pub, unique, prefix, useFileName, strictSingles, whitelist, pinUri, pinPos){
      LOG('--- CSV:', file.name, '---');
      const rows = await new Promise((resolve, reject)=>{
        Papa.parse(file, { header:true, skipEmptyLines:true, complete: r=>resolve(r.data), error: reject });
      });
      const norm = rows.map(normalizeRow).sort((a,b)=> (a._order||0)-(b._order||0));
      LOG('rows:', norm.length);

      const seen = new Set();
      const uris = [];
      let idx = 0;
      for(const r of norm){
        idx++;
        const uri = await resolveTrack(r, market, strictSingles, whitelist);
        if(uri){
          if(unique && seen.has(uri)){
            LOG('[dup] skip', idx, uri);
          }else{
            seen.add(uri); uris.push(uri);
            LOG('[ok]', idx, uri);
          }
        }else{
          LOG('[x] not found SINGLE(1–4) + artistID', idx, r.title||'');
        }
      }

      // Pin @ position
      if(pinUri){
        const before = uris.length;
        const ordered = splicePin(uris, pinUri, pinPos, unique);
        LOG('pin', pinUri, 'at', pinPos, '(before=', before, 'after=', ordered.length, ')');
        // use ordered
        uris.length = 0; Array.prototype.push.apply(uris, ordered);
      }

      const base = file.name.replace(/\.csv$/i,'').slice(0,140);
      const name = useFileName ? (prefix + base) : (prefix || 'TDCS - Singles(1-4)');
      const pl = await createPlaylist(name, pub);
      LOG('playlist:', pl.external_urls?.spotify || '');
      if(uris.length) await addUris(pl.id, uris);
      LOG('DONE', file.name, '->', pl.external_urls?.spotify || '');
    }

    document.getElementById('btnBuild').onclick = async () => {
      try{ needToken(); }catch(_){ alert('Sign in first'); return; }
      const files = [...(document.getElementById('csvFiles').files||[])];
      if(!files.length){ alert('Choose CSV files'); return; }

      const pub = document.getElementById('isPublic').checked;
      const unique = document.getElementById('uniqueUris').checked;
      const market = document.getElementById('searchMarket').value;
      const prefix = document.getElementById('prefix').value || '';
      const useFileName = document.getElementById('useFileName').checked;
      const strictSingles = document.getElementById('strictSingles').checked;
      const whitelist = parseArtistIds();
      const pinUri = parsePinUri();
      const pinPos = Number(document.getElementById('pinPos').value||19);

      for(const f of files){
        await buildOneCSV(f, market, pub, unique, prefix, useFileName, strictSingles, whitelist, pinUri, pinPos);
      }
      alert('All done.');
    };

    document.getElementById('btnSignOut').onclick = () => {
      sessionStorage.clear();
      localStorage.removeItem('code_verifier');
      setAuthStatus('No token.');
      LOG('Signed out (local).');
    };

    (async()=>{
      try{
        if(!token()) throw new Error('no');
        const m = await me();
        setAuthStatus('Signed in as ' + (m.display_name || m.id));
      }catch(_){
        setAuthStatus('No token.');
      }
    })();
  </script>
</body>
</html>
