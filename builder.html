<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TDCS Builder — Singles(1–4) • ArtistID lock • Primary-only • Pin @19 • 強化検索＋超レート制御</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
           max-width:1080px;margin:24px auto;padding:0 12px;background:#0b1220;color:#cfe3ff;}
    h1{margin:0 0 8px;font-size:20px;}
    fieldset{border:1px solid #22324f;border-radius:10px;margin:10px 0;padding:12px;}
    legend{padding:0 8px;color:#bcd1f5;}
    label{display:block;margin:8px 0 4px;}
    input[type="text"],input[type="number"],select{width:100%;max-width:640px;padding:9px;border-radius:8px;
      border:1px solid #2d3e60;background:#091426;color:#cfe3ff;}
    input[type="checkbox"]{transform:scale(1.05);margin-right:6px;}
    button{padding:10px 14px;border-radius:8px;border:1px solid #3a4d75;background:#14213a;color:#e9f1ff;cursor:pointer;}
    #log{white-space:pre-wrap;background:#091426;color:#d6e6ff;border:1px solid #20304a;padding:12px;border-radius:10px;
      margin-top:12px;max-height:560px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center;}
    .row>*{flex:1 1 auto;}
    .muted{color:#8ea6cc;}
  </style>
</head>
<body>
<h1>TDCS Builder — Singles(1–4) • ArtistID lock • Primary-only • Pin @19 • 強化検索＋超レート制御</h1>

<fieldset>
  <legend>Auth</legend>
  <div id="authStatus" class="muted">No token.</div>
  <div class="row" style="margin-top:8px">
    <button id="btnSignIn">Sign in</button>
    <button id="btnSignOut">Sign out (local)</button>
  </div>
</fieldset>

<fieldset>
  <legend>Constraints</legend>
  <label>Artist IDs（カンマ区切り。<b>先頭IDを“固定メイン”</b>として扱います）
    <input id="artistIds" type="text" value="55fvQ5I2IZUfcFT2DV02T3">
  </label>
  <label><input id="primaryOnly" type="checkbox" checked> Primary-artist only（artists[0].id = 固定メイン）</label>
  <label><input id="fallbackAllowFeatured" type="checkbox" checked> 固定メインが先頭でなくても、1–4曲シングルなら採用（修正依頼に記録）</label>
  <label><input id="strictSingles" type="checkbox" checked> Singlesのみ（1–4曲）</label>
  <label><input id="useCatalogNumber" type="checkbox" checked> Catalog number（例: NPR226）も検索語に含める</label>
  <div class="row">
    <label>Pin track (URL/URI)
      <input id="pinUri" type="text" value="https://open.spotify.com/track/3bBCxxbNkrl1DlBlxATNVQ">
    </label>
    <label>Pin position（1始まり）
      <input id="pinPos" type="number" min="1" value="19">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>Playlist & Rate</legend>
  <label><input id="isPublic" type="checkbox"> Public playlist</label>
  <label><input id="uniqueUris" type="checkbox" checked> 重複を除外</label>
  <label>Build for user（任意）
    <input id="userIdOverride" type="text" placeholder="22fqn5mozguuegi2t3l2zeugy" value="22fqn5mozguuegi2t3l2zeugy">
  </label>
  <div class="row">
    <label>Playlist name prefix
      <input id="prefix" type="text" value="TDCS - Singles(1-4) - ">
    </label>
    <label><input id="useFileName" type="checkbox" checked> プレイリスト名にCSVファイル名を使用</label>
  </div>
  <div class="row">
    <label>Search market
      <select id="searchMarket">
        <option value="from_token" selected>from_token</option>
        <option value="JP">JP</option><option value="US">US</option><option value="GB">GB</option>
        <option value="DE">DE</option><option value="FR">FR</option><option value="ES">ES</option>
        <option value="NL">NL</option><option value="SE">SE</option><option value="BR">BR</option>
      </select>
    </label>
    <label>Rate mode
      <select id="rateMode">
        <option value="gentle" selected>Gentle (最安全)</option>
        <option value="normal">Normal</option>
        <option value="aggressive">Aggressive</option>
      </select>
    </label>
    <div>
      <button id="btnAbort" title="現在のリクエスト終了後に停止">Abort</button>
    </div>
  </div>
</fieldset>

<fieldset>
  <legend>Advanced（429対策）</legend>
  <div class="row">
    <label>深掘り検索（アルバム走査）<select id="deepMode">
      <option value="auto" selected>Auto（429時は自動デグレード）</option>
      <option value="on">Always On</option>
      <option value="off">Off（/search のみ）</option>
    </select></label>
    <label>アーティスト単位のアルバム取得上限（CSVあたり）
      <input id="budgetAlbumList" type="number" value="60" min="0">
    </label>
    <label>アルバム→トラック取得上限（CSVあたり）
      <input id="budgetAlbumTracks" type="number" value="200" min="0">
    </label>
  </div>
  <div class="row">
    <label>429グローバル・クールダウン秒
      <input id="cooldownSec" type="number" value="30" min="5">
    </label>
    <label>1行ごとの待機（ms）
      <input id="rowDelayMs" type="number" value="120" min="0">
    </label>
  </div>
  <div class="muted">※ 429が一定回数続くと、指定秒数のクールダウン＋深掘りを一時停止します。</div>
</fieldset>

<fieldset>
  <legend>CSV</legend>
  <label>Choose CSV（複数可）
    <input id="csvFiles" type="file" accept=".csv" multiple>
  </label>
  <div class="row" style="margin-top:8px">
    <button id="btnBuild">Build playlists（CSVごとに1つ）</button>
    <button id="btnExportNF">Export not-found.csv（直近の実行）</button>
    <button id="btnExportCorr">Export distributor-correction.txt（直近の実行）</button>
  </div>
  <div class="muted" style="margin-top:8px">
    受理列: <code>order</code>, <code>Catalog number</code>, <code>title</code>, <code>remixer</code>, <code>isrc</code>, <code>spotify_query</code>, <code>Original file name</code><br>
    ISRC列が無い場合は <em>Original file name</em> から抽出を試みます。
  </div>
</fieldset>

<pre id="log">Ready.</pre>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
/* -------------------- 基本ユーティリティ -------------------- */
const LOG=(...a)=>{const el=document.getElementById('log');el.textContent+="\n"+a.join(' ');el.scrollTop=el.scrollHeight;}
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
function download(name, text){const blob=new Blob([text],{type:'text/plain;charset=utf-8;'});const url=URL.createObjectURL(blob);const a=document.createElement('a');a.href=url;a.download=name;document.body.appendChild(a);a.click();a.remove();URL.revokeObjectURL(url);}

/* Sign-in 起点: 戻り先保存→auth.html へ */
document.getElementById('btnSignIn').onclick=()=>{ try{ sessionStorage.setItem('return_to', location.href); }catch(_){}
  location.href='auth.html'; };

/* Abort */
let ABORT=false;
document.getElementById('btnAbort').onclick=()=>{ ABORT=true; LOG('Abort requested. 現在のリクエスト完了後に停止します。'); };
function checkAbort(){ if(ABORT) throw new Error('aborted'); }

/* -------------------- Auth / Token（refresh内蔵） -------------------- */
function token(){return sessionStorage.getItem('access_token')}
function tokenExpiresAt(){return Number(sessionStorage.getItem('access_token_expires_at')||0)}
function refreshToken(){return sessionStorage.getItem('refresh_token')}
const CLIENT_ID='5b4dc486f92a46878665468fa5de9361';
const TOKEN_URL='https://accounts.spotify.com/api/token';

async function refreshIfNeeded(){
  const now=Date.now(), exp=tokenExpiresAt();
  if(token() && exp && now < exp-60*1000) return;
  const rt=refreshToken(); if(!rt) return;
  LOG('Refreshing token…');
  const res=await fetch(TOKEN_URL,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},
    body:new URLSearchParams({ grant_type:'refresh_token', refresh_token:rt, client_id:CLIENT_ID })});
  if(res.ok){
    const t=await res.json();
    if(t.access_token) sessionStorage.setItem('access_token', t.access_token);
    if(t.refresh_token) sessionStorage.setItem('refresh_token', t.refresh_token);
    if(t.expires_in){ sessionStorage.setItem('access_token_expires_at', String(Date.now()+t.expires_in*1000)); }
  }else{ LOG('Refresh failed:', res.status); }
}
function needToken(){const t=token();if(!t)throw new Error('no_token');return t}
async function me(){await refreshIfNeeded(); return api('https://api.spotify.com/v1/me')}
function setAuthStatus(msg){document.getElementById('authStatus').textContent=msg}

/* -------------------- 超レート制御（Queue + Backoff + Cooldown + Degrade） -------------------- */
const Rate = { minDelay:1100, maxDelay:8000, nextAt:0, inFlight:0, attempts429:0, cooldownUntil:0, degradeUntil:0 };
function applyRateMode(mode){ if(mode==='aggressive'){Rate.minDelay=400;Rate.maxDelay=3000;} else if(mode==='normal'){Rate.minDelay=800;Rate.maxDelay=5000;} else {Rate.minDelay=1100;Rate.maxDelay=8000;} }
function jitter(ms=220){ return Math.floor(Math.random()*ms); }

async function gate(){
  // グローバル・クールダウン
  const now=Date.now();
  if(Rate.cooldownUntil>now){ const wait=Rate.cooldownUntil-now; LOG(`cooldown ${Math.ceil(wait/1000)}s`); await sleep(wait); }
  // 同時実行=1
  while(Rate.inFlight>0){ await sleep(10); }
  Rate.inFlight=1;
  // 次の解禁時刻まで待つ
  const now2=Date.now();
  if(Rate.nextAt>now2){ await sleep(Rate.nextAt-now2); }
}
function release(){ Rate.inFlight=0; }
function setNext(){ Rate.nextAt = Date.now() + Rate.minDelay + jitter(180); }

function startCooldown(){
  const sec = Number(document.getElementById('cooldownSec').value||30);
  Rate.cooldownUntil = Date.now() + sec*1000;
  // 深掘りデグレード（自動OFF）も付与
  Rate.degradeUntil = Date.now() + Math.max(15*1000, sec*1000);
  LOG(`→ cooldown ${sec}s / degrade deep search`);
}

async function api(url,opt={}, attempt=0){
  checkAbort();
  await refreshIfNeeded();
  await gate();
  const headers=Object.assign({'Authorization':'Bearer '+needToken()}, opt.headers||{});
  try{
    const res=await fetch(url, Object.assign({}, opt, {headers}));
    if([502,503,504].includes(res.status)){ // 一時的障害
      release(); setNext();
      if(attempt<4){ const back= (attempt+1)*1000 + jitter(300); LOG(`5xx retry in ${back}ms`); await sleep(back); return api(url,opt,attempt+1); }
      throw new Error('API '+res.status+' temporary error');
    }
    if(res.status===429){
      const retrySec = Number(res.headers.get('Retry-After')||'2');
      Rate.attempts429++;
      // 最低間隔をRetry-Afterに寄せて拡張
      Rate.minDelay = Math.min(Rate.maxDelay, Math.max(Rate.minDelay, (retrySec*1000)*1.25));
      // 連続429が閾値超えたらクールダウン＆デグレード
      if(Rate.attempts429>=3){ startCooldown(); }
      release(); setNext();
      if(attempt<6){ const wait = Math.max(Rate.minDelay, retrySec*1000)+jitter(300); LOG(`429 -> backoff ${(wait/1000)|0}s (attempt=${attempt+1})`); await sleep(wait); return api(url,opt,attempt+1); }
      throw new Error('API 429 too many attempts');
    }
    Rate.attempts429=0; // 連続解除
    if(!res.ok){ const txt=await res.text(); release(); setNext(); throw new Error('API '+res.status+': '+txt); }
    const json=await res.json();
    release(); setNext();
    return json;
  }catch(e){ release(); setNext(); throw e; }
}

/* -------------------- 正規化/CSV -------------------- */
function normTitle(s){return (s||'').toLowerCase().replace(/[‐–—−]/g,'-').replace(/[’`]/g,"'").replace(/\s+/g,' ').trim();}
function stripParens(s){return (s||'').replace(/\s*$begin:math:text$[^)]*$end:math:text$\s*/g,' ').replace(/\s+/g,' ').trim();}
function extractISRC(s){if(!s)return'';const m=String(s).match(/\b[A-Z]{2}[A-Z0-9]{3}\d{7}\b/);return m?m[0]:'';}

function normalizeRow(raw){
  const lower={};for(const k in raw) lower[k.toLowerCase()]=k;
  const pick=k=>raw[lower[k]];
  const row={};
  row.order=pick('order')??raw.order??'';
  row.catalog=pick('catalog number')??pick('catalog')??pick('catalog_number')??'';
  row.title=pick('title')??raw.title??pick('track')??'';
  row.remixer=pick('remixer')??pick('remixers')??'';
  let isrc=pick('isrc')??''; if(!isrc || String(isrc).trim()===''){ isrc=extractISRC(pick('original file name')??''); }
  row.isrc=String(isrc||'').trim();
  row.spotify_query=pick('spotify_query')??'';
  row._order=Number(row.order||0);
  return row;
}

/* -------------------- Query生成（段階的） -------------------- */
function splitRemixers(remixer){
  if(!remixer) return [];
  const s = String(remixer).replace(/\bfeat\.?\b/ig, ',').replace(/\s+x\s+/ig, ',').replace(/\s*&\s*/g, ',');
  return s.split(',').map(x=>x.trim()).filter(Boolean);
}
function tdcsAliases(){ return ['The Darrow Chem Syndicate','Darrow Chem Syndicate','TDCS']; }

function buildQueries(row, useCatno){
  const qs=new Set();
  const tRaw=String(row.title||'').trim();
  const tClean=stripParens(tRaw);
  const remixers=splitRemixers(row.remixer);
  const cat = row.catalog ? String(row.catalog).trim() : '';
  const aliases = tdcsAliases();

  if(row.isrc) qs.add('isrc:'+row.isrc);
  if(row.spotify_query && String(row.spotify_query).trim()) qs.add(String(row.spotify_query).trim());

  for(const name of aliases){
    if(tRaw) qs.add(`track:"${tRaw}" artist:"${name}"`);
    if(tClean && tClean!==tRaw) qs.add(`track:"${tClean}" artist:"${name}"`);
    if(tRaw && remixers.length){
      for(const r of remixers){
        qs.add(`track:"${tRaw}" ${r} remix artist:"${name}"`);
        qs.add(`"${tRaw} (${r} Remix)" "${name}"`);
      }
      if(remixers.length>=2){
        const joined = remixers.join(' ');
        qs.add(`track:"${tRaw}" ${joined} remix artist:"${name}"`);
      }
    }
    if(tRaw) qs.add(`${tRaw} "${name}"`);
    if(tClean && tClean!==tRaw) qs.add(`${tClean} "${name}"`);
  }
  if(tRaw){
    qs.add(`track:"${tRaw}" remix`);
    for(const r of remixers){ qs.add(`track:"${tRaw}" "${r}" remix`); }
    qs.add(`${tRaw} remix`);
  }
  if(useCatno && cat && tRaw){
    qs.add(`"${cat}" "${tRaw}"`);
    for(const name of aliases){ qs.add(`"${cat}" "${tRaw}" "${name}"`); }
  }
  // 過剰クエリ抑制：最大16個まで
  return Array.from(qs).slice(0,16);
}

/* -------------------- Artist / Single 判定 -------------------- */
function parseArtistIds(){ return document.getElementById('artistIds').value.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean); }
function mainArtistId(){ return parseArtistIds()[0] || ''; }
function artistNames(arts){ return (arts||[]).map(a=>a.name).join(', '); }

function hasArtist(track, whitelist, primaryOnly){
  const arts=track?.artists||[];
  if(primaryOnly){ const a0=arts[0]?.id; return a0 && whitelist.includes(a0); }
  return arts.some(a=>whitelist.includes(a.id));
}
const albumTotalCache=new Map();
async function getAlbumTotalTracks(albumId){
  if(!albumId) return null;
  if(albumTotalCache.has(albumId)) return albumTotalCache.get(albumId);
  const data=await api('https://api.spotify.com/v1/albums/'+encodeURIComponent(albumId));
  const tt=(typeof data?.total_tracks==='number')?data.total_tracks:null;
  albumTotalCache.set(albumId,tt); return tt;
}
function singleCheckLocal(track, strict){
  if(track?.album?.album_type!=='single') return false;
  const tt=track?.album?.total_tracks;
  if(typeof tt!=='number'||tt<=0) return 'unknown';
  return strict ? (tt>=1 && tt<=4) : true;
}

/* -------------------- Search / Crawl -------------------- */
async function searchTracks(q, market){
  const base='https://api.spotify.com/v1/search?q='+encodeURIComponent(q)+'&type=track&limit=20';
  const url=(market && market!=='from_token') ? (base+'&market='+encodeURIComponent(market)) : base;
  return api(url);
}
const artistAlbumsCache=new Map(); // key: artist|market|groups
async function getArtistAlbums(artistId, market, groups='single'){
  const key=artistId+'|'+(market||'')+'|'+groups;
  if(artistAlbumsCache.has(key)) return artistAlbumsCache.get(key);
  const albums=[];
  let url=`https://api.spotify.com/v1/artists/${encodeURIComponent(artistId)}/albums?include_groups=${groups}&limit=50${market&&market!=='from_token'?`&market=${encodeURIComponent(market)}`:''}`;
  let guard=0;
  while(url && guard++<5){
    const data=await api(url);
    (data.items||[]).forEach(a=>albums.push({id:a.id,total_tracks:a.total_tracks||null, album_type:a.album_type, name:a.name}));
    url=data.next;
  }
  artistAlbumsCache.set(key,albums); return albums;
}

/* -------------------- 収集とエクスポート -------------------- */
let lastNotFoundRows=[];
let lastPrimaryIssues=[];
function exportNotFound(){
  if(!lastNotFoundRows.length){ alert('not-found はありません'); return; }
  const header=['source_file','index','title','remixer','isrc','catalog'];
  const rows=lastNotFoundRows.map(r=>[r.source,r.index,r.title||'',r.remixer||'',r.isrc||'',r.catalog||'']);
  const csv=[header.join(','), ...rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(','))].join('\n');
  download('not-found.csv', csv);
}
function exportCorrections(){
  if(!lastPrimaryIssues.length){ alert('修正依頼はありません'); return; }
  const lines = [
    '【ディストリビューター様 修正依頼（primary順序/重複primaryの可能性）】',
    '固定メイン（Artist ID 先頭）: ' + mainArtistId(),
    '',
    '以下のトラックは、固定メインが先頭でなく、primaryが複数/順序違いの可能性があります。',
    '「メイン＝固定アーティスト」になるようクレジット順序のご確認・修正をご検討ください。',
    '(プレイリストにはシングル1–4曲の条件を満たすため暫定採用しています)',
    ''
  ].concat(lastPrimaryIssues);
  download('distributor_correction.txt', lines.join('\n'));
}

/* -------------------- Resolver（段階的＋予算＋デグレード） -------------------- */
function titleMatch(a,b){const na=normTitle(a), nb=normTitle(b);return na===nb || na.includes(nb) || nb.includes(na);}

async function resolveTrack(row, market, strictSingles, whitelist, primaryOnly, budget, deepPref){
  checkAbort();
  const allowFeatured = document.getElementById('fallbackAllowFeatured').checked;
  const useCatno = document.getElementById('useCatalogNumber').checked;
  const markets = (market && market!=='from_token') ? [market] : ['', 'JP','US','GB']; // 控えめに
  const qs = buildQueries(row, useCatno);

  const deepAllowed = (()=> {
    const now=Date.now();
    if(deepPref==='off') return false;
    if(deepPref==='on')  return true;
    // auto: 429直後のデグレード期間はオフ
    return now >= Rate.degradeUntil;
  })();

  const consider = async (it, mkt, sourceLabel) => {
    let ok = false;
    const chk=singleCheckLocal(it, strictSingles);
    if(chk===true){ ok=true; }
    else if(chk==='unknown'){
      const tt=await getAlbumTotalTracks(it.album?.id);
      ok = !!(tt && tt>=1 && tt<=4);
    }
    if(!ok) return null;

    const arts=it.artists||[];
    const names=artistNames(arts);
    const main=mainArtistId();
    const containsMain = arts.some(a=>a.id===main);
    const mainIsFirst = arts[0]?.id===main;

    if(primaryOnly){
      if(mainIsFirst) return {uri:it.uri, issue:null};
      if(allowFeatured && containsMain){
        const note = `【primary順序要修正】"${it.name}" — ${names}\nURI: ${it.uri}\n理由: 固定メイン(${main})が先頭でなく、primaryが複数/順序違いの可能性（市場:${mkt} / src:${sourceLabel}）。シングル(1–4)のため採用。`;
        return {uri:it.uri, issue:note};
      }
      return null;
    }else{
      if(containsMain){
        if(!mainIsFirst){
          const note = `【primary順序要修正】"${it.name}" — ${names}\nURI: ${it.uri}\n理由: 固定メイン(${main})が先頭でなく、primaryが複数/順序違いの可能性（市場:${mkt} / src:${sourceLabel}）。`;
          return {uri:it.uri, issue:note};
        }
        return {uri:it.uri, issue:null};
      }
      return null;
    }
  };

  /* A) /search 厳格（primary先頭一致） */
  for(const mkt of markets){
    for(const q of qs){
      try{
        const res=await searchTracks(q, mkt);
        const items=(res?.tracks?.items||[]).filter(x=>x?.uri?.startsWith('spotify:track:') && hasArtist(x,whitelist,true));
        for(const it of items){ const r=await consider(it,mkt,'searchA'); if(r) return r; }
      }catch(e){ LOG('searchA error', e.message); }
    }
  }

  /* B) /search 緩和（allowFeatured 採用可） */
  for(const mkt of markets){
    for(const q of qs){
      try{
        const res=await searchTracks(q, mkt);
        const items=(res?.tracks?.items||[]).filter(x=>x?.uri?.startsWith('spotify:track:'));
        const filtered = allowFeatured ? items.filter(x => (x.artists||[]).some(a=>whitelist.includes(a.id)))
                                       : items.filter(x => hasArtist(x,whitelist,primaryOnly));
        for(const it of filtered){ const r=await consider(it,mkt,'searchB'); if(r) return r; }
      }catch(e){ LOG('searchB error', e.message); }
    }
  }

  /* C) 深掘り（アルバム走査） — 429や予算で自動停止 */
  if(deepAllowed && (budget.albums>0 || budget.albumTracks>0)){
    for(const mkt of markets){
      // まず “single” だけ。appears_on は重いのでカット（allowFeaturedで拾える想定）
      for(const aid of whitelist){
        if(budget.albums<=0) break;
        try{
          const albums=await getArtistAlbums(aid, mkt, 'single');
          // 予算カット
          const pick = albums.slice(0, Math.max(0, budget.albums));
          budget.albums -= pick.length;
          for(const a of pick){
            if(!(a.album_type==='single')) continue;
            let tt=(typeof a.total_tracks==='number')?a.total_tracks:null;
            if(tt==null){ if(budget.albumTracks<=0) continue; tt=await getAlbumTotalTracks(a.id); }
            if(!(tt && tt>=1 && tt<=4)) continue;
            if(budget.albumTracks<=0) break;
            budget.albumTracks--;
            const tr=await api(`https://api.spotify.com/v1/albums/${encodeURIComponent(a.id)}/tracks?limit=50${mkt&&mkt!=='from_token'?`&market=${encodeURIComponent(mkt)}`:''}`);
            for(const t of (tr.items||[])){
              if(!titleMatch(t.name, row.title||'')) continue;
              const fake = { uri:t.uri, name:t.name, artists:t.artists||[], album:{album_type:'single', total_tracks:tt, id:a.id} };
              const r=await consider(fake,mkt,'albums'); if(r) return r;
            }
          }
        }catch(e){
          LOG('albums error', e.message);
          // 連発429を検知したら即クールダウン＆デグレード
          if(String(e.message).includes('429')) startCooldown();
        }
      }
    }
  }

  return null;
}

/* -------------------- Pin / Playlist -------------------- */
function toTrackUri(s){ if(!s) return null; if(String(s).startsWith('http')){ const m=String(s).match(/track\/([a-zA-Z0-9]+)/); if(m) return 'spotify:track:'+m[1]; } return s; }
async function createPlaylist(name, isPublic){
  const override=document.getElementById('userIdOverride').value.trim();
  const uid=override || (await me()).id;
  return api('https://api.spotify.com/v1/users/'+encodeURIComponent(uid)+'/playlists',{
    method:'POST', headers:{'Content-Type':'application/json'},
    body:JSON.stringify({name, public:!!isPublic, description:'Singles(1–4) • ArtistID lock • Primary-only • Pinned'})
  });
}
async function addUris(pid, uris){
  for(let i=0;i<uris.length;i+=100){
    const chunk=uris.slice(i,i+100);
    await api('https://api.spotify.com/v1/playlists/'+pid+'/tracks',{
      method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({uris:chunk})
    });
    LOG('added', Math.min(i+100, uris.length), '/', uris.length);
  }
}

/* -------------------- Build（pinは[ok]N曲目直前・行間待機） -------------------- */
async function buildOneCSV(file, opts){
  LOG('--- CSV:', file.name, '---');
  const rows=await new Promise((resolve,reject)=>{
    Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>resolve(r.data),error:reject});
  });
  const norm=rows.map(normalizeRow).sort((a,b)=>(a._order||0)-(b._order||0));
  LOG('rows:', norm.length);

  const {market,isPublic,unique,prefix,useFileName,strictSingles,whitelist,primaryOnly,pinUri,pinPos,deepMode,rowDelayMs,budgetCfg}=opts;
  const seen=new Set(); const uris=[];
  let okCount=0; const pinIndex0=Math.max(0, Number(pinPos||19)-1);

  // CSV内の予算（アルバム一覧/アルバム→トラック）
  const budget={ albums: budgetCfg.albumList, albumTracks: budgetCfg.albumTracks };

  for(let i=0;i<norm.length;i++){
    checkAbort();
    const r=norm[i];
    try{
      const res=await resolveTrack(r, market, strictSingles, whitelist, primaryOnly, budget, deepMode);
      if(res && res.uri){
        if(pinUri && okCount===pinIndex0){ if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin @', pinIndex0+1, pinUri); } }
        if(!unique || !seen.has(res.uri)){ uris.push(res.uri); seen.add(res.uri); okCount++; LOG('[ok]', i+1, res.uri); }
        else{ LOG('[dup] skip', i+1, res.uri); }
        if(res.issue){ lastPrimaryIssues.push(res.issue); LOG('[note] primary要修正 追記'); }
      }else{
        LOG('[x] not found', i+1, r.title||'');
        lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
      }
    }catch(e){
      if(e.message==='aborted'){ LOG('中断しました'); return; }
      LOG('[!] error', i+1, (r.title||''), e.message);
      lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
    }
    const pause = Number(rowDelayMs||0);
    if(pause>0) await sleep(pause);
  }

  if(pinUri && okCount<=pinIndex0){ if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin (tail)', pinUri); } }

  const base=file.name.replace(/\.csv$/i,'').slice(0,140);
  const name=useFileName ? (prefix + base) : (prefix || 'TDCS - Singles(1-4)');
  const pl=await createPlaylist(name, isPublic);
  LOG('playlist:', pl.external_urls?.spotify||'');
  if(uris.length) await addUris(pl.id, uris);
  LOG('DONE', file.name, '->', pl.external_urls?.spotify||'');
}

/* -------------------- UI 結線 -------------------- */
document.getElementById('btnBuild').onclick=async()=>{
  try{ needToken(); }catch(_){ alert('Sign in first'); return; }
  ABORT=false; lastNotFoundRows=[]; lastPrimaryIssues=[];
  const files=[...(document.getElementById('csvFiles').files||[])];
  if(!files.length){ alert('Choose CSV'); return; }

  applyRateMode(document.getElementById('rateMode').value);

  const opts={};
  opts.isPublic=document.getElementById('isPublic').checked;
  opts.unique=document.getElementById('uniqueUris').checked;
  opts.market=document.getElementById('searchMarket').value;
  opts.prefix=document.getElementById('prefix').value||'';
  opts.useFileName=document.getElementById('useFileName').checked;
  opts.strictSingles=document.getElementById('strictSingles').checked;
  opts.primaryOnly=document.getElementById('primaryOnly').checked;
  opts.whitelist=parseArtistIds();
  opts.pinUri=toTrackUri(document.getElementById('pinUri').value.trim());
  opts.pinPos=Number(document.getElementById('pinPos').value||19);
  opts.deepMode=document.getElementById('deepMode').value;
  opts.rowDelayMs=Number(document.getElementById('rowDelayMs').value||120);
  opts.budgetCfg={
    albumList:Number(document.getElementById('budgetAlbumList').value||60),
    albumTracks:Number(document.getElementById('budgetAlbumTracks').value||200)
  };

  for(const f of files){ if(ABORT) break; await buildOneCSV(f, opts); }

  if(lastPrimaryIssues.length){ exportCorrections(); }
  if(ABORT){ alert('中断しました。ログを確認してください。'); }
  else { alert('All done. 必要なら「Export not-found.csv」もどうぞ。'); }
};
document.getElementById('btnExportNF').onclick=exportNotFound;
document.getElementById('btnExportCorr').onclick=exportCorrections;
document.getElementById('btnSignOut').onclick=()=>{ sessionStorage.clear(); localStorage.removeItem('code_verifier'); setAuthStatus('No token.'); LOG('Signed out (local).'); };

(async()=>{ try{ if(!token()) throw 0; const m=await me(); setAuthStatus('Signed in as '+(m.display_name||m.id)); }catch(_){ setAuthStatus('No token.'); } })();
</script>
</body>
</html>
