<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TDCS Builder — Singles(1–4) • Artist lock • Primary-any • Pin @20 • Index+Backoff</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
           max-width:1080px;margin:24px auto;padding:0 12px;background:#0b1220;color:#cfe3ff;}
    h1{margin:0 0 8px;font-size:20px;}
    fieldset{border:1px solid #22324f;border-radius:10px;margin:10px 0;padding:12px;}
    legend{padding:0 8px;color:#bcd1f5;}
    label{display:block;margin:8px 0 4px;}
    input[type="text"],input[type="number"],select{width:100%;max-width:640px;padding:9px;border-radius:8px;
      border:1px solid #2d3e60;background:#091426;color:#cfe3ff;}
    input[type="checkbox"]{transform:scale(1.05);margin-right:6px;}
    button{padding:10px 14px;border-radius:8px;border:1px solid #3a4d75;background:#14213a;color:#e9f1ff;cursor:pointer;}
    #log{white-space:pre-wrap;background:#091426;color:#d6e6ff;border:1px solid #20304a;padding:12px;border-radius:10px;
      margin-top:12px;max-height:560px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center;}
    .row>*{flex:1 1 auto;}
    .muted{color:#8ea6cc;}
  </style>
</head>
<body>
<h1>TDCS Builder — Singles(1–4) • Artist lock • Primary-any • Pin @20</h1>

<fieldset>
  <legend>Auth</legend>
  <div id="authStatus" class="muted">No token.</div>
  <div class="row" style="margin-top:8px">
    <button id="btnSignIn">Sign in</button>
    <button id="btnSelfTest">Self test (/v1/me)</button>
    <button id="btnSignOut">Sign out (local)</button>
  </div>
</fieldset>

<fieldset>
  <legend>Constraints</legend>
  <label>Artist IDs（カンマ区切り。先頭が基準 TDCS）
    <input id="artistIds" type="text" value="55fvQ5I2IZUfcFT2DV02T3">
  </label>
  <label><input id="primaryOnly" type="checkbox"> Primary-artist を先頭（artists[0]）に限定</label>
  <label><input id="allowFeatured" type="checkbox" checked> 先頭でなくても固定メインを含むなら採用（1–4シングル限定、修正依頼に記載）</label>
  <label><input id="strictSingles" type="checkbox" checked> Singlesのみ（1–4曲）</label>
  <label><input id="useCatalogNumber" type="checkbox" checked> Catalog number（例: NPR226）も検索語に使う</label>
  <div class="row">
    <label>Pin track (URL/URI)
      <input id="pinUri" type="text" value="https://open.spotify.com/track/3bBCxxbNkrl1DlBlxATNVQ">
    </label>
    <label>Pin position（1始まり）
      <input id="pinPos" type="number" min="1" value="20">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>Playlist & Rate</legend>
  <label><input id="isPublic" type="checkbox"> Public playlist</label>
  <label><input id="uniqueUris" type="checkbox" checked> 重複除外</label>
  <label>Build for user（任意）
    <input id="userIdOverride" type="text" placeholder="22fqn5mozguuegi2t3l2zeugy" value="22fqn5mozguuegi2t3l2zeugy">
  </label>
  <div class="row">
    <label>Playlist name prefix
      <input id="prefix" type="text" value="TDCS - Singles(1-4) - ">
    </label>
    <label><input id="useFileName" type="checkbox" checked> プレイリスト名にCSVファイル名を使う</label>
  </div>
  <div class="row">
    <label>Search market
      <select id="searchMarket">
        <option value="from_token" selected>from_token</option>
        <option value="JP">JP</option><option value="US">US</option><option value="GB">GB</option>
      </select>
    </label>
    <label>Rate mode
      <select id="rateMode">
        <option value="gentle">Gentle（最安全）</option>
        <option value="normal" selected>Normal</option>
        <option value="aggressive">Aggressive</option>
      </select>
    </label>
    <div><button id="btnAbort" title="現在のリクエスト終了後に停止">Abort</button></div>
  </div>
</fieldset>

<fieldset>
  <legend>Advanced（索引 & 429対策）</legend>
  <label><input id="preloadIndex" type="checkbox"> 先にシングル(1–4)を全取得してローカル索引を作る</label>
  <div class="row">
    <label>インデックス化の市場
      <select id="indexMarkets" multiple size="3">
        <option selected>JP</option>
        <option>US</option>
        <option>GB</option>
      </select>
    </label>
    <label>429クールダウン秒
      <input id="cooldownSec" type="number" value="30" min="5">
    </label>
    <label>行ごとの待機（ms）
      <input id="rowDelayMs" type="number" value="20" min="0">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>CSV</legend>
  <label>Choose CSV（複数可）
    <input id="csvFiles" type="file" accept=".csv" multiple>
  </label>
  <div class="row" style="margin-top:8px">
    <button id="btnBuild">Build playlists（CSVごとに1つ）</button>
    <button id="btnExportNF">Export not-found.csv（直近の実行）</button>
    <button id="btnExportCorr">Export distributor-correction.txt（直近の実行）</button>
  </div>
  <div class="muted" style="margin-top:8px">
    受理列: <code>order</code>, <code>Catalog number</code>, <code>title</code>, <code>remixer</code>, <code>isrc</code>, <code>spotify_query</code>, <code>Original file name</code><br>
    ISRC列が無い場合は <em>Original file name</em> から抽出を試みます。
  </div>
</fieldset>

<pre id="log">Ready.</pre>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
const LOG=(...a)=>{const el=document.getElementById('log');el.textContent+="\n"+a.join(' ');el.scrollTop=el.scrollHeight;}
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const download=(name,text)=>{const b=new Blob([text],{type:'text/plain;charset=utf-8;'});const u=URL.createObjectURL(b);const a=document.createElement('a');a.href=u;a.download=name;document.body.appendChild(a);a.click();a.remove();URL.revokeObjectURL(u);}

/* ===== Auth ===== */
const CLIENT_ID='5b4dc486f92a46878665468fa5de9361';
const TOKEN_URL='https://accounts.spotify.com/api/token';
function token(){return sessionStorage.getItem('access_token')}
function tokenExpiresAt(){return Number(sessionStorage.getItem('access_token_expires_at')||0)}
function refreshToken(){return sessionStorage.getItem('refresh_token')}
function setAuthStatus(msg){document.getElementById('authStatus').textContent=msg}
async function me(){await refreshIfNeeded(); return api('https://api.spotify.com/v1/me')}
async function refreshIfNeeded(){
  const now=Date.now(), exp=tokenExpiresAt();
  if(token() && exp && now < exp-60*1000) return;
  const rt=refreshToken(); if(!rt) return;
  LOG('Refreshing token…');
  const res=await fetch(TOKEN_URL,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},
    body:new URLSearchParams({grant_type:'refresh_token',refresh_token:rt,client_id:CLIENT_ID})});
  if(res.ok){
    const t=await res.json();
    if(t.access_token) sessionStorage.setItem('access_token', t.access_token);
    if(t.refresh_token) sessionStorage.setItem('refresh_token', t.refresh_token);
    if(t.expires_in) sessionStorage.setItem('access_token_expires_at', String(Date.now()+t.expires_in*1000));
  }else{
    LOG('Refresh failed:', res.status);
  }
}
function needToken(){const t=token(); if(!t) throw new Error('no_token'); return t;}

/* ===== Rate limit (queue+backoff+cooldown) ===== */
const Rate = { minDelay:700, maxDelay:4000, nextAt:0, inFlight:0, attempts429:0, cooldownUntil:0 };
function applyRateMode(mode){ if(mode==='aggressive'){Rate.minDelay=350;Rate.maxDelay=2500;} else if(mode==='normal'){Rate.minDelay=700;Rate.maxDelay=4000;} else {Rate.minDelay=900;Rate.maxDelay=6000;} }
function jitter(ms=160){ return Math.floor(Math.random()*ms); }
function startCooldown(){ const sec=Number(document.getElementById('cooldownSec').value||30); Rate.cooldownUntil=Date.now()+sec*1000; LOG(`→ cooldown ${sec}s`); }
async function gate(){ const now=Date.now(); if(Rate.cooldownUntil>now){ const w=Rate.cooldownUntil-now; LOG(`cooldown ${Math.ceil(w/1000)}s`); await sleep(w); }
  while(Rate.inFlight>0){ await sleep(8); } Rate.inFlight=1; const now2=Date.now(); if(Rate.nextAt>now2){ await sleep(Rate.nextAt-now2); } }
function release(){ Rate.inFlight=0; }
function setNext(){ Rate.nextAt = Date.now() + Rate.minDelay + jitter(); }
let ABORT=false; document.getElementById('btnAbort').onclick=()=>{ ABORT=true; LOG('Abort requested.'); }
function checkAbort(){ if(ABORT) throw new Error('aborted'); }

async function api(url,opt={}, attempt=0){
  checkAbort(); await refreshIfNeeded(); await gate();
  const headers=Object.assign({'Authorization':'Bearer '+needToken()}, opt.headers||{});
  try{
    const res=await fetch(url, Object.assign({}, opt, {headers}));
    if(res.status===429){
      const retrySec=Number(res.headers.get('Retry-After')||'2');
      Rate.attempts429++; Rate.minDelay=Math.min(Rate.maxDelay, Math.max(Rate.minDelay, retrySec*1000*1.2));
      if(Rate.attempts429>=2) startCooldown();
      release(); setNext();
      if(attempt<6){ const wait=Math.max(Rate.minDelay, retrySec*1000)+jitter(300); LOG(`429 -> backoff ${(wait/1000)|0}s (attempt=${attempt+1})`); await sleep(wait); return api(url,opt,attempt+1); }
      throw new Error('API 429 too many attempts');
    }
    Rate.attempts429=0;
    if(!res.ok){ const txt=await res.text(); release(); setNext(); throw new Error('API '+res.status+': '+txt); }
    const json=await res.json(); release(); setNext(); return json;
  }catch(e){ release(); setNext(); throw e; }
}

/* ===== CSV normalize ===== */
function normTitle(s){return (s||'').toLowerCase().replace(/[‐–—−]/g,'-').replace(/[’`]/g,"'").replace(/\s+/g,' ').trim();}
function stripParens(s){return (s||'').replace(/\s*$begin:math:text$[^)]*$end:math:text$\s*/g,' ').replace(/\s*$begin:math:display$[^$end:math:display$]*\]\s*/g,' ').replace(/\s+/g,' ').trim();}
function extractISRC(s){ if(!s) return ''; const m=String(s).match(/\b[A-Z]{2}[A-Z0-9]{3}\d{7}\b/); return m?m[0]:''; }
function normalizeRow(raw){
  const lower={}; for(const k in raw) lower[k.toLowerCase()]=k;
  const pick=k=>raw[lower[k]];
  const row={};
  row.order=pick('order')??raw.order??'';
  row.catalog=pick('catalog number')??pick('catalog')??pick('catalog_number')??'';
  row.title=pick('title')??raw.title??pick('track')??'';
  row.remixer=pick('remixer')??pick('remixers')??'';
  let isrc=pick('isrc')??''; if(!isrc || String(isrc).trim()===''){ isrc=extractISRC(pick('original file name')??''); }
  row.isrc=String(isrc||'').trim();
  row.spotify_query=pick('spotify_query')??'';
  row._order=Number(row.order||0);
  return row;
}

/* ===== Artist logic ===== */
function parseArtistIds(){ return document.getElementById('artistIds').value.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean); }
function mainArtistId(){ return parseArtistIds()[0] || ''; }
function artistNames(arts){ return (arts||[]).map(a=>a.name).join(', '); }
function hasMainArtistFirst(arts){ return (arts&&arts[0]&&arts[0].id===mainArtistId()); }
function containsMain(arts){ return (arts||[]).some(a=>a.id===mainArtistId()); }

/* ===== Index (singles only) ===== */
const indexStore=new Map(); // key: market|artistId => Map<titleNorm, [trackInfo…]>
async function listSinglesAlbums(artistId, market){
  let url=`https://api.spotify.com/v1/artists/${encodeURIComponent(artistId)}/albums?include_groups=single&limit=50${market?`&market=${market}`:''}`;
  const albums=[]; let page=0;
  while(url && page++<6){
    const d=await api(url);
    (d.items||[]).forEach(a=>albums.push({id:a.id,total_tracks:a.total_tracks, album_type:a.album_type, name:a.name}));
    url=d.next;
  }
  return albums;
}
async function getAlbumTracks(albumId, market){
  const d=await api(`https://api.spotify.com/v1/albums/${encodeURIComponent(albumId)}/tracks?limit=50${market?`&market=${market}`:''}`);
  return d.items||[];
}
function singleCheck(tt){ return (typeof tt==='number' && tt>=1 && tt<=4); }

async function buildIndexFor(artistId, market){
  const key=`${market||''}|${artistId}`; if(indexStore.has(key)) return indexStore.get(key);
  const m=new Map(); let kept=0, skipped=0;
  LOG('indexing singles…', artistId, '@'+(market||'from_token'));
  const albums=await listSinglesAlbums(artistId, market);
  for(const a of albums){
    const tt=a.total_tracks;
    if(a.album_type!=='single' || !singleCheck(tt)){ skipped++; continue; }
    const tracks=await getAlbumTracks(a.id, market);
    for(const t of tracks){
      const info={ uri:t.uri, name:t.name, artists:t.artists||[], albumId:a.id, total_tracks:tt };
      const n1=normTitle(t.name), n2=normTitle(stripParens(t.name));
      if(!m.has(n1)) m.set(n1, []); m.get(n1).push(info);
      if(n2!==n1){ if(!m.has(n2)) m.set(n2, []); m.get(n2).push(info); }
      kept++;
    }
  }
  indexStore.set(key,m);
  LOG(`indexed ${artistId} @${market||'from_token'}: titles=${m.size} tracks=${kept} (skip=${skipped})`);
  return m;
}

/* ===== Lightweight search fallback ===== */
async function searchTracks(q, market){
  const base='https://api.spotify.com/v1/search?q='+encodeURIComponent(q)+'&type=track&limit=10';
  const url=(market && market!=='from_token') ? (base+'&market='+encodeURIComponent(market)) : base;
  return api(url);
}
function tdcsAliases(){ return ['The Darrow Chem Syndicate','Darrow Chem Syndicate','TDCS']; }
function splitRemixers(remixer){
  if(!remixer) return [];
  const s = String(remixer).replace(/\bfeat\.?\b/ig, ',').replace(/\s+x\s+/ig, ',').replace(/\s*&\s*/g, ',');
  return s.split(',').map(x=>x.trim()).filter(Boolean);
}
function buildLightQueries(row){
  const set=new Set();
  const t=String(row.title||'').trim(); const t2=stripParens(t); const aliases=tdcsAliases(); const remixers=splitRemixers(row.remixer);
  if(row.isrc) set.add('isrc:'+row.isrc);
  for(const name of aliases){
    if(t) set.add(`track:"${t}" artist:"${name}"`);
    if(t2 && t2!==t) set.add(`track:"${t2}" artist:"${name}"`);
    if(t && remixers.length){ for(const r of remixers) set.add(`track:"${t}" ${r} remix artist:"${name}"`); }
  }
  return Array.from(set).slice(0,4);
}

/* ===== Resolver ===== */
async function resolveTrack(row, marketsForIndex, marketForSearch, primaryOnly, allowFeatured){
  const title=row.title||''; const n=normTitle(title), n2=normTitle(stripParens(title));

  // 1) Index hit
  for(const mkt of marketsForIndex){
    for(const aid of parseArtistIds()){
      const idx=await buildIndexFor(aid, mkt);
      const list=(idx.get(n)||[]).concat(idx.get(n2)||[]);
      if(list.length){
        // choose best
        const first=list.find(x=>hasMainArtistFirst(x.artists));
        if(primaryOnly){
          if(first) return {uri:first.uri, issue:null};
          if(allowFeatured){
            const withMain=list.find(x=>containsMain(x.artists));
            if(withMain){
              const names=artistNames(withMain.artists);
              const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（索引:${mkt}）。シングル(1–4)条件。`;
              return {uri:withMain.uri, issue:note};
            }
          }
        }else{
          const withMain=list.find(x=>containsMain(x.artists));
          if(withMain){
            if(!hasMainArtistFirst(withMain.artists)){
              const names=artistNames(withMain.artists);
              const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（索引:${mkt}）。`;
              return {uri:withMain.uri, issue:note};
            }
            return {uri:withMain.uri, issue:null};
          }
        }
      }
    }
  }

  // 2) ISRC
  if(row.isrc){
    try{
      const res=await searchTracks('isrc:'+row.isrc, marketForSearch);
      const items=(res?.tracks?.items||[]).filter(x=>x.album?.album_type==='single' && (x.album.total_tracks||0)<=4);
      const withMain=items.find(x=>containsMain(x.artists));
      if(withMain){
        if(primaryOnly && !hasMainArtistFirst(withMain.artists)){
          if(allowFeatured){
            const names=artistNames(withMain.artists);
            const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（ISRC）。`;
            return {uri:withMain.uri, issue:note};
          }
        }else{
          return {uri:withMain.uri, issue:null};
        }
      }
    }catch(e){ LOG('isrc search error', e.message); }
  }

  // 3) Light queries
  try{
    const qs=buildLightQueries(row);
    for(const q of qs){
      const res=await searchTracks(q, marketForSearch);
      const items=(res?.tracks?.items||[]).filter(x=>x.album?.album_type==='single' && (x.album.total_tracks||0)<=4);
      const first=items.find(x=>hasMainArtistFirst(x.artists));
      if(primaryOnly){
        if(first) return {uri:first.uri, issue:null};
        if(allowFeatured){
          const withMain=items.find(x=>containsMain(x.artists));
          if(withMain){
            const names=artistNames(withMain.artists);
            const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（search）。`;
            return {uri:withMain.uri, issue:note};
          }
        }
      }else{
        const withMain=items.find(x=>containsMain(x.artists));
        if(withMain){
          if(!hasMainArtistFirst(withMain.artists)){
            const names=artistNames(withMain.artists);
            const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（search）。`;
            return {uri:withMain.uri, issue:note};
          }
          return {uri:withMain.uri, issue:null};
        }
      }
    }
  }catch(e){ LOG('search error', e.message); }

  return null;
}

/* ===== Playlist helpers ===== */
function toTrackUri(s){ if(!s) return null; if(String(s).startsWith('http')){ const m=String(s).match(/track\/([a-zA-Z0-9]+)/); if(m) return 'spotify:track:'+m[1]; } return s; }
async function createPlaylist(name, isPublic){
  const override=document.getElementById('userIdOverride').value.trim();
  const uid=override || (await me()).id;
  return api('https://api.spotify.com/v1/users/'+encodeURIComponent(uid)+'/playlists',{
    method:'POST', headers:{'Content-Type':'application/json'},
    body:JSON.stringify({name, public:!!isPublic, description:'Singles(1–4) • Artist lock • Primary-any • Pinned'})
  });
}
async function addUris(pid, uris){
  for(let i=0;i<uris.length;i+=100){
    const chunk=uris.slice(i,i+100);
    await api('https://api.spotify.com/v1/playlists/'+pid+'/tracks',{
      method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({uris:chunk})
    });
    LOG('added', Math.min(i+100, uris.length), '/', uris.length);
  }
}

/* ===== Export buckets ===== */
let lastNotFoundRows=[]; let lastPrimaryIssues=[];
function exportNotFound(){
  if(!lastNotFoundRows.length){ alert('not-found はありません'); return; }
  const header=['source_file','index','title','remixer','isrc','catalog'];
  const rows=lastNotFoundRows.map(r=>[r.source,r.index,r.title||'',r.remixer||'',r.isrc||'',r.catalog||'']);
  const csv=[header.join(','), ...rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(','))].join('\n');
  download('not-found.csv', csv);
}
function exportCorrections(){
  if(!lastPrimaryIssues.length){ alert('修正依頼はありません'); return; }
  const lines = [
    '【ディストリビューター様 修正依頼（primary順序/重複primaryの可能性）】',
    '固定メイン（Artist ID 先頭）: ' + mainArtistId(),
    '',
    '以下のトラックは、固定メインが先頭でなく、primaryが複数/順序違いの可能性があります。',
    '「メイン＝固定アーティスト」になるようクレジット順序のご確認・修正をご検討ください。',
    '(プレイリストにはシングル1–4曲の条件を満たすため暫定採用しています)',
    ''
  ].concat(lastPrimaryIssues);
  download('distributor_correction.txt', lines.join('\n'));
}

/* ===== Build ===== */
async function buildOneCSV(file, opts){
  LOG('--- CSV:', file.name, '---');
  const rows=await new Promise((resolve,reject)=>{
    Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>resolve(r.data),error:reject});
  });
  const norm=rows.map(normalizeRow).sort((a,b)=>(a._order||0)-(b._order||0));
  LOG('rows:', norm.length);

  const {isPublic,unique,prefix,useFileName,primaryOnly,allowFeatured,market,marketsIndex,pinUri,pinPos,rowDelayMs}=opts;

  if(opts.preloadIndex){
    for(const mkt of marketsIndex){
      for(const aid of parseArtistIds()){
        await buildIndexFor(aid, mkt);
      }
    }
  }

  const seen=new Set(); const uris=[];
  let okCount=0; const pinIndex0=Math.max(0, Number(pinPos||20)-1);

  for(let i=0;i<norm.length;i++){
    if((i+1)%10===0) LOG('…processing', (i+1)+'/'+norm.length);
    const r=norm[i];
    try{
      const res=await resolveTrack(r, marketsIndex, market, primaryOnly, allowFeatured);
      if(res && res.uri){
        if(pinUri && okCount===pinIndex0){ if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin @', pinIndex0+1, pinUri); } }
        if(!unique || !seen.has(res.uri)){ uris.push(res.uri); seen.add(res.uri); okCount++; LOG('[ok]', i+1, res.uri); }
        else{ LOG('[dup] skip', i+1, res.uri); }
        if(res.issue){ lastPrimaryIssues.push(res.issue); LOG('[note] primary要修正 追記'); }
      }else{
        LOG('[x] not found', i+1, r.title||'');
        lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
      }
    }catch(e){
      if(e.message==='aborted'){ LOG('中断しました'); return; }
      LOG('[!] error', i+1, (r.title||''), e.message);
      lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
    }
    const pause=Number(rowDelayMs||0); if(pause>0) await sleep(pause);
  }

  if(pinUri && okCount<=pinIndex0){ if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin (tail)', pinUri); } }

  const base=file.name.replace(/\.csv$/i,'').slice(0,140);
  const name=useFileName ? (prefix + base) : (prefix || 'TDCS - Singles(1-4)');
  const pl=await createPlaylist(name, isPublic);
  LOG('playlist:', pl.external_urls?.spotify||'');
  if(uris.length) await addUris(pl.id, uris);
  LOG('DONE', file.name, '->', pl.external_urls?.spotify||'');
}

/* ===== UI wiring ===== */
document.getElementById('btnSignIn').onclick=()=>{ try{ sessionStorage.setItem('return_to', location.href); }catch(_){} location.href='auth.html'; };
document.getElementById('btnSignOut').onclick=()=>{ sessionStorage.clear(); localStorage.removeItem('code_verifier'); setAuthStatus('No token.'); LOG('Signed out (local).'); };
document.getElementById('btnSelfTest').onclick=async()=>{ try{ const m=await me(); LOG('Self test OK as', (m.display_name||m.id)); }catch(e){ LOG('Self test NG:', e.message); } };
document.getElementById('btnExportNF').onclick=exportNotFound;
document.getElementById('btnExportCorr').onclick=exportCorrections;

document.getElementById('btnBuild').onclick=async()=>{
  try{ needToken(); }catch(_){ alert('Sign in first'); return; }
  ABORT=false; lastNotFoundRows=[]; lastPrimaryIssues=[];
  const files=[...(document.getElementById('csvFiles').files||[])]; if(!files.length){ alert('Choose CSV'); return; }

  applyRateMode(document.getElementById('rateMode').value);

  const opts={};
  opts.isPublic=document.getElementById('isPublic').checked;
  opts.unique=document.getElementById('uniqueUris').checked;
  opts.market=document.getElementById('searchMarket').value;
  opts.preloadIndex=document.getElementById('preloadIndex').checked;
  opts.marketsIndex=[...document.getElementById('indexMarkets').selectedOptions].map(o=>o.value);
  opts.prefix=document.getElementById('prefix').value||'';
  opts.useFileName=document.getElementById('useFileName').checked;
  opts.primaryOnly=document.getElementById('primaryOnly').checked;
  opts.allowFeatured=document.getElementById('allowFeatured').checked;
  opts.pinUri=toTrackUri(document.getElementById('pinUri').value.trim());
  opts.pinPos=Number(document.getElementById('pinPos').value||20);
  opts.rowDelayMs=Number(document.getElementById('rowDelayMs').value||20);

  for(const f of files){ await buildOneCSV(f, opts); }
  if(lastPrimaryIssues.length){ exportCorrections(); }
  alert('All done. 必要なら「Export not-found.csv」もどうぞ。');
};

/* initial auth status */
(async()=>{ try{ if(!token()) throw 0; const m=await me(); setAuthStatus('Signed in as '+(m.display_name||m.id)); }catch(_){ setAuthStatus('No token.'); } })();
}); // DOMContentLoaded
</script>
</body>
</html>
