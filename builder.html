<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TDCS Builder — Singles(1–4) • ArtistID lock • Primary-only • Pin @19 • 事前索引で429回避</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
           max-width:1080px;margin:24px auto;padding:0 12px;background:#0b1220;color:#cfe3ff;}
    h1{margin:0 0 8px;font-size:20px;}
    fieldset{border:1px solid #22324f;border-radius:10px;margin:10px 0;padding:12px;}
    legend{padding:0 8px;color:#bcd1f5;}
    label{display:block;margin:8px 0 4px;}
    input[type="text"],input[type="number"],select{width:100%;max-width:640px;padding:9px;border-radius:8px;
      border:1px solid #2d3e60;background:#091426;color:#cfe3ff;}
    input[type="checkbox"]{transform:scale(1.05);margin-right:6px;}
    button{padding:10px 14px;border-radius:8px;border:1px solid #3a4d75;background:#14213a;color:#e9f1ff;cursor:pointer;}
    #log{white-space:pre-wrap;background:#091426;color:#d6e6ff;border:1px solid #20304a;padding:12px;border-radius:10px;
      margin-top:12px;max-height:560px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center;}
    .row>*{flex:1 1 auto;}
    .muted{color:#8ea6cc;}
  </style>
</head>
<body>
<h1>TDCS Builder — Singles(1–4) • ArtistID lock • Primary-only • Pin @19 • 事前索引で429回避</h1>

<fieldset>
  <legend>Auth</legend>
  <div id="authStatus" class="muted">No token.</div>
  <div class="row" style="margin-top:8px">
    <button id="btnSignIn">Sign in</button>
    <button id="btnSignOut">Sign out (local)</button>
  </div>
</fieldset>

<fieldset>
  <legend>Constraints</legend>
  <label>Artist IDs（カンマ区切り。<b>先頭ID=固定メイン</b>）
    <input id="artistIds" type="text" value="55fvQ5I2IZUfcFT2DV02T3">
  </label>
  <label><input id="primaryOnly" type="checkbox" checked> Primary-artist only（artists[0].id=固定メイン）</label>
  <label><input id="allowFeatured" type="checkbox" checked> 固定メインが先頭でなくても、1–4曲シングルなら採用（修正依頼に追記）</label>
  <label><input id="strictSingles" type="checkbox" checked> Singlesのみ（1–4曲）</label>
  <label><input id="useCatalogNumber" type="checkbox" checked> Catalog numberも検索語に使う（例: NPR226）</label>
  <div class="row">
    <label>Pin track (URL/URI)
      <input id="pinUri" type="text" value="https://open.spotify.com/track/3bBCxxbNkrl1DlBlxATNVQ">
    </label>
    <label>Pin position（1始まり）
      <input id="pinPos" type="number" min="1" value="19">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>Playlist & Rate</legend>
  <label><input id="isPublic" type="checkbox"> Public playlist</label>
  <label><input id="uniqueUris" type="checkbox" checked> 重複除外</label>
  <label>Build for user（任意）
    <input id="userIdOverride" type="text" placeholder="22fqn5mozguuegi2t3l2zeugy" value="22fqn5mozguuegi2t3l2zeugy">
  </label>
  <div class="row">
    <label>Playlist name prefix
      <input id="prefix" type="text" value="TDCS - Singles(1-4) - ">
    </label>
    <label><input id="useFileName" type="checkbox" checked> プレイリスト名にCSVファイル名を使う</label>
  </div>
  <div class="row">
    <label>Search market
      <select id="searchMarket">
        <option value="from_token" selected>from_token</option>
        <option value="JP">JP</option><option value="US">US</option><option value="GB">GB</option>
      </select>
    </label>
    <label>Rate mode
      <select id="rateMode">
        <option value="gentle" selected>Gentle（最安全）</option>
        <option value="normal">Normal</option>
        <option value="aggressive">Aggressive</option>
      </select>
    </label>
    <div><button id="btnAbort" title="現在のリクエスト終了後に停止">Abort</button></div>
  </div>
</fieldset>

<fieldset>
  <legend>Advanced（事前索引 & 429対策）</legend>
  <label><input id="preloadIndex" type="checkbox" checked> 先に「シングル(1–4)」を全取得してローカル索引を作る（推奨）</label>
  <div class="row">
    <label>インデックス化の市場
      <select id="indexMarkets" multiple size="3">
        <option selected>JP</option>
        <option>US</option>
        <option>GB</option>
      </select>
    </label>
    <label>429クールダウン秒
      <input id="cooldownSec" type="number" value="30" min="5">
    </label>
    <label>行ごとの待機（ms）
      <input id="rowDelayMs" type="number" value="80" min="0">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>CSV</legend>
  <label>Choose CSV（複数可）
    <input id="csvFiles" type="file" accept=".csv" multiple>
  </label>
  <div class="row" style="margin-top:8px">
    <button id="btnBuild">Build playlists（CSVごとに1つ）</button>
    <button id="btnExportNF">Export not-found.csv（直近の実行）</button>
    <button id="btnExportCorr">Export distributor-correction.txt（直近の実行）</button>
  </div>
  <div class="muted" style="margin-top:8px">
    受理列: <code>order</code>, <code>Catalog number</code>, <code>title</code>, <code>remixer</code>, <code>isrc</code>, <code>spotify_query</code>, <code>Original file name</code><br>
    ISRC列が無い場合は <em>Original file name</em> から抽出を試みます。
  </div>
</fieldset>

<pre id="log">Ready.</pre>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
/* ====== 基本ユーティリティ ====== */
const LOG=(...a)=>{const el=document.getElementById('log');el.textContent+="\n"+a.join(' ');el.scrollTop=el.scrollHeight;}
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
function download(name, text){const b=new Blob([text],{type:'text/plain;charset=utf-8;'});const u=URL.createObjectURL(b);const a=document.createElement('a');a.href=u;a.download=name;document.body.appendChild(a);a.click();a.remove();URL.revokeObjectURL(u);}

/* ====== サインイン起点 ====== */
document.getElementById('btnSignIn').onclick=()=>{ try{ sessionStorage.setItem('return_to', location.href); }catch(_){} location.href='auth.html'; };

/* ====== Abort ====== */
let ABORT=false;
document.getElementById('btnAbort').onclick=()=>{ ABORT=true; LOG('Abort requested. 現在のリクエスト完了後に停止します。'); };
function checkAbort(){ if(ABORT) throw new Error('aborted'); }

/* ====== Auth / Token（refresh内蔵） ====== */
function token(){return sessionStorage.getItem('access_token')}
function tokenExpiresAt(){return Number(sessionStorage.getItem('access_token_expires_at')||0)}
function refreshToken(){return sessionStorage.getItem('refresh_token')}
const CLIENT_ID='5b4dc486f92a46878665468fa5de9361';
const TOKEN_URL='https://accounts.spotify.com/api/token';

async function refreshIfNeeded(){
  const now=Date.now(), exp=tokenExpiresAt();
  if(token() && exp && now < exp-60*1000) return;
  const rt=refreshToken(); if(!rt) return;
  LOG('Refreshing token…');
  const res=await fetch(TOKEN_URL,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},
    body:new URLSearchParams({ grant_type:'refresh_token', refresh_token:rt, client_id:CLIENT_ID })});
  if(res.ok){
    const t=await res.json();
    if(t.access_token) sessionStorage.setItem('access_token', t.access_token);
    if(t.refresh_token) sessionStorage.setItem('refresh_token', t.refresh_token);
    if(t.expires_in){ sessionStorage.setItem('access_token_expires_at', String(Date.now()+t.expires_in*1000)); }
  }else{ LOG('Refresh failed:', res.status); }
}
function needToken(){const t=token();if(!t)throw new Error('no_token');return t}
async function me(){await refreshIfNeeded(); return api('https://api.spotify.com/v1/me')}
function setAuthStatus(msg){document.getElementById('authStatus').textContent=msg}

/* ====== レート制御（Queue + Backoff + Cooldown） ====== */
const Rate = { minDelay:900, maxDelay:6000, nextAt:0, inFlight:0, attempts429:0, cooldownUntil:0 };
function applyRateMode(mode){ if(mode==='aggressive'){Rate.minDelay=350;Rate.maxDelay=2500;} else if(mode==='normal'){Rate.minDelay=700;Rate.maxDelay=4000;} else {Rate.minDelay=900;Rate.maxDelay=6000;} }
function jitter(ms=160){ return Math.floor(Math.random()*ms); }
function startCooldown(){ const sec=Number(document.getElementById('cooldownSec').value||30); Rate.cooldownUntil=Date.now()+sec*1000; LOG(`→ cooldown ${sec}s`); }
async function gate(){
  const now=Date.now(); if(Rate.cooldownUntil>now){ const w=Rate.cooldownUntil-now; LOG(`cooldown ${Math.ceil(w/1000)}s`); await sleep(w); }
  while(Rate.inFlight>0){ await sleep(8); }
  Rate.inFlight=1;
  const now2=Date.now(); if(Rate.nextAt>now2){ await sleep(Rate.nextAt-now2); }
}
function release(){ Rate.inFlight=0; }
function setNext(){ Rate.nextAt = Date.now() + Rate.minDelay + jitter(); }

async function api(url,opt={}, attempt=0){
  checkAbort();
  await refreshIfNeeded();
  await gate();
  const headers=Object.assign({'Authorization':'Bearer '+needToken()}, opt.headers||{});
  try{
    const res=await fetch(url, Object.assign({}, opt, {headers}));
    if(res.status===429){
      const retrySec = Number(res.headers.get('Retry-After')||'2');
      Rate.attempts429++;
      Rate.minDelay = Math.min(Rate.maxDelay, Math.max(Rate.minDelay, retrySec*1000*1.2));
      if(Rate.attempts429>=2) startCooldown();
      release(); setNext();
      if(attempt<6){ const wait = Math.max(Rate.minDelay, retrySec*1000)+jitter(300); LOG(`429 -> backoff ${(wait/1000)|0}s (attempt=${attempt+1})`); await sleep(wait); return api(url,opt,attempt+1); }
      throw new Error('API 429 too many attempts');
    }
    Rate.attempts429=0;
    if(!res.ok){ const txt=await res.text(); release(); setNext(); throw new Error('API '+res.status+': '+txt); }
    const json=await res.json(); release(); setNext(); return json;
  }catch(e){ release(); setNext(); throw e; }
}

/* ====== 正規化/CSV ====== */
function normTitle(s){return (s||'').toLowerCase().replace(/[‐–—−]/g,'-').replace(/[’`]/g,"'").replace(/\s+/g,' ').trim();}
function stripParens(s){return (s||'').replace(/\s*$begin:math:text$[^)]*$end:math:text$\s*/g,' ').replace(/\s+/g,' ').trim();}
function extractISRC(s){if(!s)return'';const m=String(s).match(/\b[A-Z]{2}[A-Z0-9]{3}\d{7}\b/);return m?m[0]:'';}
function normalizeRow(raw){
  const lower={};for(const k in raw) lower[k.toLowerCase()]=k;
  const pick=k=>raw[lower[k]];
  const row={};
  row.order=pick('order')??raw.order??'';
  row.catalog=pick('catalog number')??pick('catalog')??pick('catalog_number')??'';
  row.title=pick('title')??raw.title??pick('track')??'';
  row.remixer=pick('remixer')??pick('remixers')??'';
  let isrc=pick('isrc')??''; if(!isrc || String(isrc).trim()===''){ isrc=extractISRC(pick('original file name')??''); }
  row.isrc=String(isrc||'').trim();
  row.spotify_query=pick('spotify_query')??'';
  row._order=Number(row.order||0);
  return row;
}

/* ====== 事前カタログ索引（シングル1–4のみ） ====== */
const indexStore = new Map(); // key: market|artistId -> Map<titleNorm, [trackInfo…]>
function parseArtistIds(){ return document.getElementById('artistIds').value.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean); }
function artistNames(arts){ return (arts||[]).map(a=>a.name).join(', '); }
function mainArtistId(){ return parseArtistIds()[0] || ''; }

async function listSinglesAlbums(artistId, market){
  let url=`https://api.spotify.com/v1/artists/${encodeURIComponent(artistId)}/albums?include_groups=single&limit=50${market?`&market=${market}`:''}`;
  const albums=[];
  let page=0;
  while(url && page++<6){
    const d=await api(url);
    (d.items||[]).forEach(a=>albums.push({id:a.id,total_tracks:a.total_tracks, album_type:a.album_type, name:a.name}));
    url=d.next;
  }
  return albums;
}
async function getAlbumTracks(albumId, market){
  const url=`https://api.spotify.com/v1/albums/${encodeURIComponent(albumId)}/tracks?limit=50${market?`&market=${market}`:''}`;
  const d=await api(url);
  return d.items||[];
}
function singleCheck(tt, strict){ if(typeof tt!=='number'||tt<=0) return false; return strict ? (tt>=1&&tt<=4) : true; }

async function buildIndexFor(artistId, market, strictSingles){
  const key=`${market||''}|${artistId}`;
  if(indexStore.has(key)) return indexStore.get(key);
  const m=new Map(); // titleNorm => array of trackInfo
  const albums=await listSinglesAlbums(artistId, market);
  let kept=0, skipped=0;
  for(const a of albums){
    const tt=a.total_tracks;
    if(a.album_type!=='single' || !singleCheck(tt,true)){ skipped++; continue; }
    const tracks=await getAlbumTracks(a.id, market);
    for(const t of tracks){
      const info={ uri:t.uri, name:t.name, artists:t.artists||[], albumId:a.id, total_tracks:tt };
      const n1=normTitle(t.name);
      const n2=normTitle(stripParens(t.name));
      if(!m.has(n1)) m.set(n1, []);
      m.get(n1).push(info);
      if(n2!==n1){ if(!m.has(n2)) m.set(n2, []); m.get(n2).push(info); }
      kept++;
    }
  }
  indexStore.set(key,m);
  LOG(`indexed ${artistId} @${market||'from_token'}: titles=${m.size} tracks=${kept} (skip=${skipped})`);
  return m;
}

/* ====== 検索フォールバック（軽量） ====== */
async function searchTracks(q, market){
  const base='https://api.spotify.com/v1/search?q='+encodeURIComponent(q)+'&type=track&limit=10';
  const url=(market && market!=='from_token') ? (base+'&market='+encodeURIComponent(market)) : base;
  return api(url);
}
function tdcsAliases(){ return ['The Darrow Chem Syndicate','Darrow Chem Syndicate','TDCS']; }
function splitRemixers(remixer){
  if(!remixer) return [];
  const s = String(remixer).replace(/\bfeat\.?\b/ig, ',').replace(/\s+x\s+/ig, ',').replace(/\s*&\s*/g, ',');
  return s.split(',').map(x=>x.trim()).filter(Boolean);
}
function buildLightQueries(row){
  const set=new Set();
  const t=String(row.title||'').trim(); const t2=stripParens(t); const aliases=tdcsAliases(); const remixers=splitRemixers(row.remixer);
  if(row.isrc) set.add('isrc:'+row.isrc);
  for(const name of aliases){
    if(t) set.add(`track:"${t}" artist:"${name}"`);
    if(t2 && t2!==t) set.add(`track:"${t2}" artist:"${name}"`);
    if(t && remixers.length){ for(const r of remixers) set.add(`track:"${t}" ${r} remix artist:"${name}"`); }
  }
  return Array.from(set).slice(0,4); // 最大4クエリ
}

/* ====== 判定 ====== */
function hasMainArtistFirst(arts){ return (arts&&arts[0]&&arts[0].id===mainArtistId()); }
function containsMain(arts){ return (arts||[]).some(a=>a.id===mainArtistId()); }

/* ====== 解決（索引優先 → ISRC検索 → 軽量検索） ====== */
async function resolveTrack(row, marketsForIndex, marketForSearch, strictSingles, primaryOnly, allowFeatured){
  checkAbort();
  const title=row.title||'';
  const n=normTitle(title), n2=normTitle(stripParens(title));

  // 1) 事前索引ヒット（市場優先順）
  for(const mkt of marketsForIndex){
    for(const aid of parseArtistIds()){
      const idx = await buildIndexFor(aid, mkt, strictSingles);
      const list = (idx.get(n)||[]).concat(idx.get(n2)||[]);
      if(list.length){
        // primary/allowFeatured 判定で最良を選ぶ
        const first = list.find(x=>hasMainArtistFirst(x.artists));
        if(primaryOnly){
          if(first) return {uri:first.uri, issue:null};
          if(allowFeatured){
            const withMain = list.find(x=>containsMain(x.artists));
            if(withMain){
              const names=artistNames(withMain.artists);
              const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（索引:${mkt}）。シングル(1–4)のため暫定採用。`;
              return {uri:withMain.uri, issue:note};
            }
          }
        }else{
          const withMain = list.find(x=>containsMain(x.artists));
          if(withMain){
            if(!hasMainArtistFirst(withMain.artists)){
              const names=artistNames(withMain.artists);
              const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（索引:${mkt}）。`;
              return {uri:withMain.uri, issue:note};
            }
            return {uri:withMain.uri, issue:null};
          }
        }
      }
    }
  }

  // 2) ISRC 検索（1リクエスト）
  if(row.isrc){
    try{
      const res=await searchTracks('isrc:'+row.isrc, marketForSearch);
      const items=(res?.tracks?.items||[]);
      const hit = items.find(x=>x.album?.album_type==='single' && (x.album.total_tracks||0)<=4 && containsMain(x.artists));
      if(hit){
        if(primaryOnly && !hasMainArtistFirst(hit.artists)){
          if(allowFeatured){
            const names=artistNames(hit.artists);
            const note=`【primary順序要修正】"${hit.name}" — ${names}\nURI: ${hit.uri}\n理由: 固定メインが先頭でない（ISRC検索）。`;
            return {uri:hit.uri, issue:note};
          }
        }else{
          return {uri:hit.uri, issue:null};
        }
      }
    }catch(e){ LOG('isrc search error', e.message); }
  }

  // 3) 軽量検索（最大4クエリ）
  try{
    const qs=buildLightQueries(row);
    for(const q of qs){
      const res=await searchTracks(q, marketForSearch);
      const items=(res?.tracks?.items||[]).filter(x=>x.album?.album_type==='single' && (x.album.total_tracks||0)<=4);
      // primary 判定
      const first = items.find(x=>hasMainArtistFirst(x.artists));
      if(primaryOnly){
        if(first) return {uri:first.uri, issue:null};
        if(allowFeatured){
          const withMain = items.find(x=>containsMain(x.artists));
          if(withMain){
            const names=artistNames(withMain.artists);
            const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（search）。`;
            return {uri:withMain.uri, issue:note};
          }
        }
      }else{
        const withMain = items.find(x=>containsMain(x.artists));
        if(withMain){
          if(!hasMainArtistFirst(withMain.artists)){
            const names=artistNames(withMain.artists);
            const note=`【primary順序要修正】"${withMain.name}" — ${names}\nURI: ${withMain.uri}\n理由: 固定メインが先頭でない（search）。`;
            return {uri:withMain.uri, issue:note};
          }
          return {uri:withMain.uri, issue:null};
        }
      }
    }
  }catch(e){ LOG('search error', e.message); }

  return null;
}

/* ====== Pin / Playlist ====== */
function toTrackUri(s){ if(!s) return null; if(String(s).startsWith('http')){ const m=String(s).match(/track\/([a-zA-Z0-9]+)/); if(m) return 'spotify:track:'+m[1]; } return s; }
async function createPlaylist(name, isPublic){
  const override=document.getElementById('userIdOverride').value.trim();
  const uid=override || (await me()).id;
  return api('https://api.spotify.com/v1/users/'+encodeURIComponent(uid)+'/playlists',{
    method:'POST', headers:{'Content-Type':'application/json'},
    body:JSON.stringify({name, public:!!isPublic, description:'Singles(1–4) • ArtistID lock • Primary-only • Pinned'})
  });
}
async function addUris(pid, uris){
  for(let i=0;i<uris.length;i+=100){
    const chunk=uris.slice(i,i+100);
    await api('https://api.spotify.com/v1/playlists/'+pid+'/tracks',{
      method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({uris:chunk})
    });
    LOG('added', Math.min(i+100, uris.length), '/', uris.length);
  }
}

/* ====== Export ====== */
let lastNotFoundRows=[]; let lastPrimaryIssues=[];
function exportNotFound(){
  if(!lastNotFoundRows.length){ alert('not-found はありません'); return; }
  const header=['source_file','index','title','remixer','isrc','catalog'];
  const rows=lastNotFoundRows.map(r=>[r.source,r.index,r.title||'',r.remixer||'',r.isrc||'',r.catalog||'']);
  const csv=[header.join(','), ...rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(','))].join('\n');
  download('not-found.csv', csv);
}
function exportCorrections(){
  if(!lastPrimaryIssues.length){ alert('修正依頼はありません'); return; }
  const lines = [
    '【ディストリビューター様 修正依頼（primary順序/重複primaryの可能性）】',
    '固定メイン（Artist ID 先頭）: ' + mainArtistId(),
    '',
    '以下のトラックは、固定メインが先頭でなく、primaryが複数/順序違いの可能性があります。',
    '「メイン＝固定アーティスト」になるようクレジット順序のご確認・修正をご検討ください。',
    '(プレイリストにはシングル1–4曲の条件を満たすため暫定採用しています)',
    ''
  ].concat(lastPrimaryIssues);
  download('distributor_correction.txt', lines.join('\n'));
}

/* ====== Build（索引→行処理→Pin） ====== */
async function buildOneCSV(file, opts){
  LOG('--- CSV:', file.name, '---');
  const rows=await new Promise((resolve,reject)=>{
    Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>resolve(r.data),error:reject});
  });
  const norm=rows.map(normalizeRow).sort((a,b)=>(a._order||0)-(b._order||0));
  LOG('rows:', norm.length);

  const {isPublic,unique,prefix,useFileName,strictSingles,primaryOnly,allowFeatured,market,marketsIndex,pinUri,pinPos,rowDelayMs}=opts;

  // 事前インデックス
  if(opts.preloadIndex){
    for(const mkt of marketsIndex){
      for(const aid of parseArtistIds()){
        await buildIndexFor(aid, mkt, strictSingles);
      }
    }
  }

  const seen=new Set(); const uris=[];
  let okCount=0; const pinIndex0=Math.max(0, Number(pinPos||19)-1);

  // 行処理
  for(let i=0;i<norm.length;i++){
    checkAbort();
    const r=norm[i];
    try{
      const res=await resolveTrack(r, marketsIndex, market, strictSingles, primaryOnly, allowFeatured);
      if(res && res.uri){
        if(pinUri && okCount===pinIndex0){ if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin @', pinIndex0+1, pinUri); } }
        if(!unique || !seen.has(res.uri)){ uris.push(res.uri); seen.add(res.uri); okCount++; LOG('[ok]', i+1, res.uri); }
        else{ LOG('[dup] skip', i+1, res.uri); }
        if(res.issue){ lastPrimaryIssues.push(res.issue); LOG('[note] primary要修正 追記'); }
      }else{
        LOG('[x] not found', i+1, r.title||'');
        lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
      }
    }catch(e){
      if(e.message==='aborted'){ LOG('中断しました'); return; }
      LOG('[!] error', i+1, (r.title||''), e.message);
      lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
    }
    const pause = Number(rowDelayMs||0); if(pause>0) await sleep(pause);
  }

  // pinがまだなら末尾に
  if(pinUri && okCount<=pinIndex0){ if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin (tail)', pinUri); } }

  // プレイリスト作成と追加
  const base=file.name.replace(/\.csv$/i,'').slice(0,140);
  const name=useFileName ? (prefix + base) : (prefix || 'TDCS - Singles(1-4)');
  const pl=await createPlaylist(name, isPublic);
  LOG('playlist:', pl.external_urls?.spotify||'');
  if(uris.length) await addUris(pl.id, uris);
  LOG('DONE', file.name, '->', pl.external_urls?.spotify||'');
}

/* ====== UI 結線 ====== */
document.getElementById('btnBuild').onclick=async()=>{
  try{ needToken(); }catch(_){ alert('Sign in first'); return; }
  ABORT=false; lastNotFoundRows=[]; lastPrimaryIssues=[];
  const files=[...(document.getElementById('csvFiles').files||[])];
  if(!files.length){ alert('Choose CSV'); return; }

  applyRateMode(document.getElementById('rateMode').value);

  const opts={};
  opts.isPublic=document.getElementById('isPublic').checked;
  opts.unique=document.getElementById('uniqueUris').checked;
  opts.market=document.getElementById('searchMarket').value; // フォールバック検索用
  opts.preloadIndex=document.getElementById('preloadIndex').checked;
  opts.marketsIndex=[...document.getElementById('indexMarkets').selectedOptions].map(o=>o.value);
  opts.prefix=document.getElementById('prefix').value||'';
  opts.useFileName=document.getElementById('useFileName').checked;
  opts.strictSingles=document.getElementById('strictSingles').checked;
  opts.primaryOnly=document.getElementById('primaryOnly').checked;
  opts.allowFeatured=document.getElementById('allowFeatured').checked;
  opts.pinUri=toTrackUri(document.getElementById('pinUri').value.trim());
  opts.pinPos=Number(document.getElementById('pinPos').value||19);
  opts.rowDelayMs=Number(document.getElementById('rowDelayMs').value||80);

  for(const f of files){ if(ABORT) break; await buildOneCSV(f, opts); }

  if(lastPrimaryIssues.length){ exportCorrections(); }
  if(ABORT){ alert('中断しました。ログを確認してください。'); }
  else { alert('All done. 必要なら「Export not-found.csv」もどうぞ。'); }
};
document.getElementById('btnExportNF').onclick=exportNotFound;
document.getElementById('btnExportCorr').onclick=exportCorrections;
document.getElementById('btnSignOut').onclick=()=>{ sessionStorage.clear(); localStorage.removeItem('code_verifier'); setAuthStatus('No token.'); LOG('Signed out (local).'); };

(async()=>{ try{ if(!token()) throw 0; const m=await me(); setAuthStatus('Signed in as '+(m.display_name||m.id)); }catch(_){ setAuthStatus('No token.'); } })();
</script>
</body>
</html>
