<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>TDCS Builder — Singles(1–4) • ArtistID lock • Primary-any-order • Pin @20</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
           max-width:1080px;margin:24px auto;padding:0 12px;background:#0b1220;color:#cfe3ff;}
    h1{margin:0 0 8px;font-size:20px;}
    fieldset{border:1px solid #22324f;border-radius:10px;margin:10px 0;padding:12px;}
    legend{padding:0 8px;color:#bcd1f5;}
    label{display:block;margin:8px 0 4px;}
    input[type="text"],input[type="number"],select{width:100%;max-width:640px;padding:9px;border-radius:8px;
      border:1px solid #2d3e60;background:#091426;color:#cfe3ff;}
    input[type="checkbox"]{transform:scale(1.05);margin-right:6px;}
    button{padding:10px 14px;border-radius:8px;border:1px solid #3a4d75;background:#14213a;color:#e9f1ff;cursor:pointer;}
    #log{white-space:pre-wrap;background:#091426;color:#d6e6ff;border:1px solid #20304a;padding:12px;border-radius:10px;
      margin-top:12px;max-height:560px;overflow:auto;font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px;}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center;}
    .row>*{flex:1 1 auto;}
    .muted{color:#8ea6cc;}
    .warn{color:#ffd166;font-weight:600}
  </style>
</head>
<body>
<h1>TDCS Builder — Singles(1–4) • ArtistID lock • Primary-any-order • Pin @20</h1>

<fieldset>
  <legend>Auth</legend>
  <div id="authStatus" class="muted">No token.</div>
  <div class="row" style="margin-top:8px">
    <button id="btnSignIn">Sign in</button>
    <button id="btnSelfTest">Self test (/v1/me)</button>
    <button id="btnSignOut">Sign out (local)</button>
  </div>
  <div id="authHint" class="warn" style="display:none">Sign in が必要です。</div>
</fieldset>

<fieldset>
  <legend>Constraints</legend>
  <label>Artist IDs（カンマ区切り。<b>先頭=基準</b>）
    <input id="artistIds" type="text" value="55fvQ5I2IZUfcFT2DV02T3">
  </label>
  <label><input id="strictSingles" type="checkbox" checked> Singlesのみ（1–4曲）</label>
  <label><input id="anyPrimary" type="checkbox" checked> リリース or トラックの primary に基準IDが含まれれば採用（順序ゆるい／共同名義OK）</label>
  <label><input id="useCatalogNumber" type="checkbox" checked> Catalog numberも検索語に使う（例: NPR226）</label>
  <div class="row">
    <label>Pin track (URL/URI)
      <input id="pinUri" type="text" value="https://open.spotify.com/track/3bBCxxbNkrl1DlBlxATNVQ">
    </label>
    <label>Pin position（1始まり）
      <input id="pinPos" type="number" min="1" value="20">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>Playlist & Rate</legend>
  <label><input id="isPublic" type="checkbox"> Public playlist</label>
  <label><input id="uniqueUris" type="checkbox" checked> 重複除外</label>
  <label>Build for user（任意）
    <input id="userIdOverride" type="text" placeholder="22fqn5mozguuegi2t3l2zeugy" value="22fqn5mozguuegi2t3l2zeugy">
  </label>
  <div class="row">
    <label>Playlist name prefix
      <input id="prefix" type="text" value="TDCS - Singles(1-4) - ">
    </label>
    <label><input id="useFileName" type="checkbox" checked> プレイリスト名にCSVファイル名を使う</label>
  </div>
  <div class="row">
    <label>Search market
      <select id="searchMarket">
        <option value="from_token" selected>from_token</option>
        <option value="JP">JP</option><option value="US">US</option><option value="GB">GB</option>
      </select>
    </label>
    <label>Rate mode
      <select id="rateMode">
        <option value="gentle" selected>Gentle（最安全）</option>
        <option value="normal">Normal</option>
        <option value="aggressive">Aggressive</option>
      </select>
    </label>
    <div><button id="btnAbort" title="現在のリクエスト終了後に停止">Abort</button></div>
  </div>
</fieldset>

<fieldset>
  <legend>Advanced（事前索引 & 429対策）</legend>
  <label><input id="preloadIndex" type="checkbox" checked> 先に「シングル(1–4)」を全取得してローカル索引（JP/US/GB）</label>
  <div class="row">
    <label>インデックス化の市場
      <select id="indexMarkets" multiple size="3">
        <option selected>JP</option>
        <option>US</option>
        <option>GB</option>
      </select>
    </label>
    <label>429クールダウン秒
      <input id="cooldownSec" type="number" value="30" min="5">
    </label>
    <label>行ごとの待機（ms）
      <input id="rowDelayMs" type="number" value="80" min="0">
    </label>
  </div>
</fieldset>

<fieldset>
  <legend>CSV</legend>
  <label>Choose CSV（複数可）
    <input id="csvFiles" type="file" accept=".csv" multiple>
  </label>
  <div class="row" style="margin-top:8px">
    <button id="btnBuild">Build playlists（CSVごとに1つ）</button>
    <button id="btnExportNF">Export not-found.csv（直近の実行）</button>
  </div>
  <div class="muted" style="margin-top:8px">
    受理列: <code>order</code>, <code>Catalog number</code>, <code>title</code>, <code>remixer</code>, <code>isrc</code>, <code>spotify_query</code>, <code>Original file name</code><br>
    ISRC列が無い場合は <em>Original file name</em> から抽出を試みます。
  </div>
</fieldset>

<pre id="log">Ready.</pre>

<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script>
/* ====== error to #log ====== */
window.addEventListener('error', e => { const m=(e&&e.message)||'error'; LOG('[JS error]', m); });
window.addEventListener('unhandledrejection', e => { LOG('[Promise rejection]', (e.reason && e.reason.message) || e.reason || ''); });

/* ====== LOG/Utils ====== */
const LOG=(...a)=>{const el=document.getElementById('log');el.textContent+="\n"+a.join(' ');el.scrollTop=el.scrollHeight;}
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
function download(name, text){const b=new Blob([text],{type:'text/plain;charset=utf-8;'});const u=URL.createObjectURL(b);const a=document.createElement('a');a.href=u;a.download=name;document.body.appendChild(a);a.click();a.remove();URL.revokeObjectURL(u);}

/* ====== safe getters ====== */
const $ = id => document.getElementById(id);
function getEl(id){ const el=$(id); if(!el){ LOG('[warn] missing element #'+id); } return el; }
function getChecked(id, def=false){ const el=$(id); return el ? !!el.checked : def; }
function getValue(id, def=''){ const el=$(id); return el ? el.value : def; }
function getMultiValues(id, def=[]){ const el=$(id); if(!el||!el.selectedOptions) return def; return [...el.selectedOptions].map(o=>o.value); }

/* ====== Sign in ====== */
document.getElementById('btnSignIn').onclick=()=>{ try{ sessionStorage.setItem('return_to', location.href); }catch(_){} location.href='./auth.html'; };
document.getElementById('btnSelfTest').onclick=async()=>{ try{ const me=await api('https://api.spotify.com/v1/me'); LOG('Self test OK:', me.id, me.display_name||''); }catch(e){ LOG('Self test NG:', e.message); } };

/* ====== Abort ====== */
let ABORT=false;
document.getElementById('btnAbort').onclick=()=>{ ABORT=true; LOG('Abort requested. 現在のリクエスト完了後に停止します。'); };
function checkAbort(){ if(ABORT) throw new Error('aborted'); }

/* ====== Token/refresh ====== */
function token(){return sessionStorage.getItem('access_token')}
function tokenExpiresAt(){return Number(sessionStorage.getItem('access_token_expires_at')||0)}
function refreshToken(){return sessionStorage.getItem('refresh_token')}
const CLIENT_ID='5b4dc486f92a46878665468fa5de9361';
const TOKEN_URL='https://accounts.spotify.com/api/token';

async function refreshIfNeeded(){
  const now=Date.now(), exp=tokenExpiresAt();
  if(token() && exp && now < exp-60*1000) return;
  const rt=refreshToken(); if(!rt) return;
  LOG('Refreshing token…');
  const res=await fetch(TOKEN_URL,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},
    body:new URLSearchParams({ grant_type:'refresh_token', refresh_token:rt, client_id:CLIENT_ID })});
  if(res.ok){
    const t=await res.json();
    if(t.access_token) sessionStorage.setItem('access_token', t.access_token);
    if(t.refresh_token) sessionStorage.setItem('refresh_token', t.refresh_token);
    if(t.expires_in){ sessionStorage.setItem('access_token_expires_at', String(Date.now()+t.expires_in*1000)); }
  }else{ LOG('Refresh failed:', res.status, await res.text()); }
}
function needToken(){const t=token();if(!t){const hint=getEl('authHint'); if(hint) hint.style.display='block'; throw new Error('no_token');}return t}
async function me(){await refreshIfNeeded(); return api('https://api.spotify.com/v1/me')}
function setAuthStatus(msg){const s=getEl('authStatus'); if(s) s.textContent=msg}

/* ====== Rate limit ====== */
const Rate = { minDelay:900, maxDelay:6000, nextAt:0, inFlight:0, attempts429:0, cooldownUntil:0 };
function applyRateMode(mode){ if(mode==='aggressive'){Rate.minDelay=350;Rate.maxDelay=2500;} else if(mode==='normal'){Rate.minDelay=700;Rate.maxDelay=4000;} else {Rate.minDelay=900;Rate.maxDelay=6000;} }
function jitter(ms=160){ return Math.floor(Math.random()*ms); }
function startCooldown(){ const sec=Number(getValue('cooldownSec',30)); Rate.cooldownUntil=Date.now()+sec*1000; LOG(`→ cooldown ${sec}s`); }
async function gate(){
  const now=Date.now(); if(Rate.cooldownUntil>now){ const w=Rate.cooldownUntil-now; LOG(`cooldown ${Math.ceil(w/1000)}s`); await sleep(w); }
  while(Rate.inFlight>0){ await sleep(8); }
  Rate.inFlight=1;
  const now2=Date.now(); if(Rate.nextAt>now2){ await sleep(Rate.nextAt-now2); }
}
function release(){ Rate.inFlight=0; }
function setNext(){ Rate.nextAt = Date.now() + Rate.minDelay + jitter(); }

async function api(url,opt={}, attempt=0){
  checkAbort();
  await refreshIfNeeded();
  await gate();
  const headers=Object.assign({'Authorization':'Bearer '+needToken()}, opt.headers||{});
  try{
    const res=await fetch(url, Object.assign({}, opt, {headers}));
    if(res.status===429){
      const retrySec = Number(res.headers.get('Retry-After')||'2');
      Rate.attempts429++;
      Rate.minDelay = Math.min(Rate.maxDelay, Math.max(Rate.minDelay, retrySec*1000*1.2));
      if(Rate.attempts429>=2) startCooldown();
      release(); setNext();
      if(attempt<6){ const wait = Math.max(Rate.minDelay, retrySec*1000)+jitter(300); LOG(`429 -> backoff ${(wait/1000)|0}s (attempt=${attempt+1})`); await sleep(wait); return api(url,opt,attempt+1); }
      throw new Error('API 429 too many attempts');
    }
    Rate.attempts429=0;
    if(!res.ok){ const txt=await res.text(); release(); setNext(); throw new Error('API '+res.status+': '+txt); }
    const json=await res.json(); release(); setNext(); return json;
  }catch(e){ release(); setNext(); throw e; }
}

/* ====== CSV/normalize ====== */
function normTitle(s){return (s||'').toLowerCase().replace(/[‐–—−]/g,'-').replace(/[’`]/g,"'").replace(/\s+/g,' ').trim();}
function stripParens(s){return (s||'').replace(/\s*$begin:math:text$[^)]*$end:math:text$\s*/g,' ').replace(/\s+/g,' ').trim();}
function extractISRC(s){if(!s)return'';const m=String(s).match(/\b[A-Z]{2}[A-Z0-9]{3}\d{7}\b/);return m?m[0]:'';}
function normalizeRow(raw){
  const lower={};for(const k in raw) lower[k.toLowerCase()]=k;
  const pick=k=>raw[lower[k]];
  const row={};
  row.order=pick('order')??raw.order??'';
  row.catalog=pick('catalog number')??pick('catalog')??pick('catalog_number')??'';
  row.title=pick('title')??raw.title??pick('track')??'';
  row.remixer=pick('remixer')??pick('remixers')??'';
  let isrc=pick('isrc')??''; if(!isrc || String(isrc).trim()===''){ isrc=extractISRC(pick('original file name')??''); }
  row.isrc=String(isrc||'').trim();
  row.spotify_query=pick('spotify_query')??'';
  row._order=Number(row.order||0);
  return row;
}

/* ====== Index ====== */
const indexStore = new Map();
function parseArtistIds(){ const el=getEl('artistIds'); const v=el?el.value:''; return v.split(/[\s,]+/).map(s=>s.trim()).filter(Boolean); }
function mainArtistId(){ return parseArtistIds()[0] || ''; }
function artistNames(arts){ return (arts||[]).map(a=>a.name).join(', '); }

async function listSinglesAlbums(artistId, market){
  let url=`https://api.spotify.com/v1/artists/${encodeURIComponent(artistId)}/albums?include_groups=single&limit=50${market?`&market=${market}`:''}`;
  const albums=[]; let page=0;
  while(url && page++<6){
    const d=await api(url);
    (d.items||[]).forEach(a=>albums.push({id:a.id,total_tracks:a.total_tracks, album_type:a.album_type, name:a.name, artists:a.artists||[]}));
    url=d.next;
  }
  return albums;
}
async function getAlbumTracks(albumId, market){
  const url=`https://api.spotify.com/v1/albums/${encodeURIComponent(albumId)}/tracks?limit=50${market?`&market=${market}`:''}`;
  const d=await api(url);
  return d.items||[];
}
function single14(tt){ return (typeof tt==='number' && tt>=1 && tt<=4); }

async function buildIndexFor(artistId, market){
  const key=`${market||''}|${artistId}`;
  if(indexStore.has(key)) return indexStore.get(key);
  const m=new Map();
  const albums=await listSinglesAlbums(artistId, market);
  for(const a of albums){
    const tt=a.total_tracks;
    if(a.album_type!=='single' || !single14(tt)) continue;
    const tracks=await getAlbumTracks(a.id, market);
    for(const t of tracks){
      const info={ uri:t.uri, name:t.name, artists:t.artists||[], album:{ id:a.id, album_type:'single', total_tracks:tt, artists:(a.artists||[]) } };
      const n1=normTitle(t.name);
      const n2=normTitle(stripParens(t.name));
      if(!m.has(n1)) m.set(n1, []); m.get(n1).push(info);
      if(n2!==n1){ if(!m.has(n2)) m.set(n2, []); m.get(n2).push(info); }
    }
  }
  indexStore.set(key,m);
  LOG(`indexed ${artistId} @${market||'from_token'}: titles=${m.size}`);
  return m;
}

/* ====== Search fallback ====== */
async function searchTracks(q, market){
  const base='https://api.spotify.com/v1/search?q='+encodeURIComponent(q)+'&type=track&limit=10';
  const url=(market && market!=='from_token') ? (base+'&market='+encodeURIComponent(market)) : base;
  return api(url);
}
function tdcsAliases(){ return ['The Darrow Chem Syndicate','Darrow Chem Syndicate','TDCS']; }
function splitRemixers(remixer){
  if(!remixer) return [];
  const s = String(remixer).replace(/\bfeat\.?\b/ig, ',').replace(/\s+x\s+/ig, ',').replace(/\s*&\s*/g, ',');
  return s.split(',').map(x=>x.trim()).filter(Boolean);
}
function buildLightQueries(row){
  const set=new Set();
  const t=String(row.title||'').trim();
  const t2=stripParens(t);
  const remixers=splitRemixers(row.remixer);
  const aliases=tdcsAliases();
  const useCat=getChecked('useCatalogNumber', true);
  const cat=row.catalog?String(row.catalog).trim():'';

  if(row.isrc) set.add('isrc:'+row.isrc);
  for(const name of aliases){
    if(t)  set.add(`track:"${t}" artist:"${name}"`);
    if(t2 && t2!==t) set.add(`track:"${t2}" artist:"${name}"`);
    if(t && remixers.length){ for(const r of remixers) set.add(`track:"${t}" ${r} remix artist:"${name}"`); }
    if(useCat && cat){ set.add(`${cat} "${name}"`); }
  }
  if(useCat && cat){ set.add(cat); }
  return Array.from(set).slice(0,6);
}

/* ====== Scoring ====== */
function albumHasMain(album){ return (album?.artists||[]).some(a=>a.id===mainArtistId()); }
function trackHasMain(arts){ return (arts||[]).some(a=>a.id===mainArtistId()); }
async function ensureSingle14(it){
  if(it.album?.album_type!=='single') return false;
  const tt = it.album?.total_tracks;
  if(typeof tt==='number' && tt>=1 && tt<=4) return true;
  if(!it.album?.id) return false;
  const data=await api('https://api.spotify.com/v1/albums/'+encodeURIComponent(it.album.id));
  return (typeof data.total_tracks==='number' && data.total_tracks>=1 && data.total_tracks<=4);
}
function normalizeForMatch(s){
  return String(s||'')
    .toLowerCase()
    .replace(/[‐–—−]/g,'-')
    .replace(/[’`]/g,"'")
    .replace(/[()［］\[\]{}]/g,' ')
    .replace(/feat\.?/g,'feat')
    .replace(/\s+/g,' ')
    .trim();
}
function remixTokensFromRow(row){ return splitRemixers(row.remixer).map(normalizeForMatch).filter(Boolean); }
function titleScore(rowTitle, candName){
  const a=normalizeForMatch(rowTitle||''); const b=normalizeForMatch(candName||'');
  if(!a || !b) return 0;
  if(a===b) return 60;
  if(a.replace(/ - original mix$/,'')===b) return 55;
  if(b.includes(a)) return 45;
  if(a.includes(b)) return 40;
  if(a.replace(/[\s-]/g,'')===b.replace(/[\s-]/g,'')) return 42;
  return 0;
}
function remixNameScore(tokens, candName){
  if(!tokens.length) return 0;
  const n=normalizeForMatch(candName||'');
  const hasRemix=/\bremix\b/.test(n);
  const hits=tokens.filter(t=>n.includes(t)).length;
  if(hits===tokens.length && hasRemix) return 40;
  if(hits===tokens.length) return 30;
  if(hits>0 && hasRemix) return 22;
  if(hits>0) return 15;
  if(/\boriginal mix\b/.test(n)) return -20;
  return 0;
}
function primaryPresenceScore(it){
  if(albumHasMain(it.album)) return 20;
  if(trackHasMain(it.artists)) return 12;
  return -30;
}
function singleScore(album){
  if(!album) return -50;
  const isSingle=album.album_type==='single';
  const tt=album.total_tracks||0;
  if(isSingle && tt>=1 && tt<=4) return 12;
  if(isSingle && !tt) return 6;
  return -40;
}
function catalogScore(row, cand){
  const cat=(row.catalog||'').toString().trim();
  if(!cat) return 0;
  const hay = normalizeForMatch(`${cand.name} ${(cand.album?.name||'')} ${artistNames(cand.artists||[])}`);
  return hay.includes(cat.toLowerCase()) ? 10 : 0;
}
function scoreCandidate(row, cand){
  const tokens=remixTokensFromRow(row);
  let s=0;
  s+=titleScore(row.title, cand.name);
  s+=remixNameScore(tokens, cand.name);
  s+=primaryPresenceScore(cand);
  s+=singleScore(cand.album);
  s+=catalogScore(row, cand);
  return s;
}

/* ====== Candidates ====== */
async function searchTracksBundle(row, market){
  const out=[];
  if(row.isrc){
    try{ const r=await searchTracks('isrc:'+row.isrc, market); out.push(...(r?.tracks?.items||[])); }catch(e){ LOG('isrc search err', e.message); }
  }
  const qs=buildLightQueries(row);
  for(const q of qs){
    try{ const r=await searchTracks(q, market); out.push(...(r?.tracks?.items||[])); }catch(e){ LOG('search err', e.message); }
  }
  const seen=new Set(); return out.filter(x=>x?.uri && !seen.has(x.uri) && seen.add(x.uri));
}
function collectIndexMatches(idx, t, t2){
  const exact = (idx.get(t)||[]).concat(idx.get(t2)||[]);
  if(exact.length) return exact;
  const res=[]; let seen=0;
  for(const [k,arr] of idx.entries()){
    if(k.includes(t) || t.includes(k) || (t2 && (k.includes(t2)||t2.includes(k)))){
      res.push(...arr);
      if((seen+=arr.length) > 300) break;
    }
  }
  return res;
}

/* ====== Resolve ====== */
async function resolveTrack(row, marketsForIndex, marketForSearch){
  checkAbort();
  const title=row.title||''; const n=normTitle(title), n2=normTitle(stripParens(title));
  const strictSingles = getChecked('strictSingles', true);
  const anyPrimary = getChecked('anyPrimary', true);

  let cands=[];

  for(const mkt of marketsForIndex){
    for(const aid of parseArtistIds()){
      const idx=await buildIndexFor(aid, mkt);
      const arr=collectIndexMatches(idx, n, n2);
      cands.push(...arr.map(x=>({ ...x, origin:'index', market:mkt })));
    }
  }
  cands.push(...(await searchTracksBundle(row, marketForSearch)).map(x=>({ ...x, origin:'search', market:marketForSearch })));

  const seen=new Set(); cands=cands.filter(x=>x?.uri && !seen.has(x.uri) && seen.add(x.uri));

  const filtered=[];
  for(const it of cands){
    if(!(await ensureSingle14(it))) continue;
    if(anyPrimary){
      if(albumHasMain(it.album) || trackHasMain(it.artists)) filtered.push(it);
    }else{
      // 厳密：アルバム(リリース)側に基準IDを要求
      if(albumHasMain(it.album)) filtered.push(it);
    }
  }
  if(!filtered.length) return null;

  filtered.forEach(f=>f.__score=scoreCandidate(row,f));
  filtered.sort((a,b)=>b.__score-a.__score);
  const best = filtered[0];
  if(best.__score < 28) return null;
  return { uri: best.uri };
}

/* ====== Pin / Playlist ====== */
function toTrackUri(s){ if(!s) return null; if(String(s).startsWith('http')){ const m=String(s).match(/track\/([A-Za-z0-9]+)/); if(m) return 'spotify:track:'+m[1]; } return s; }
async function createPlaylist(name, isPublic){
  const override=getValue('userIdOverride','').trim();
  const uid=override || (await me()).id;
  return api('https://api.spotify.com/v1/users/'+encodeURIComponent(uid)+'/playlists',{
    method:'POST', headers:{'Content-Type':'application/json'},
    body:JSON.stringify({name, public:!!isPublic, description:'Singles(1–4) • ArtistID lock • Primary-any-order • Pinned@20'})
  });
}
async function addUris(pid, uris){
  for(let i=0;i<uris.length;i+=100){
    const chunk=uris.slice(i,i+100);
    await api('https://api.spotify.com/v1/playlists/'+pid+'/tracks',{
      method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({uris:chunk})
    });
    LOG('added', Math.min(i+100, uris.length), '/', uris.length);
  }
}

/* ====== Export ====== */
let lastNotFoundRows=[];
function exportNotFound(){
  if(!lastNotFoundRows.length){ alert('not-found はありません'); return; }
  const header=['source_file','index','title','remixer','isrc','catalog'];
  const rows=lastNotFoundRows.map(r=>[r.source,r.index,r.title||'',r.remixer||'',r.isrc||'',r.catalog||'']);
  const csv=[header.join(','), ...rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(','))].join('\n');
  download('not-found.csv', csv);
}

/* ====== Build ====== */
async function buildOneCSV(file, opts){
  LOG('--- CSV:', file.name, '---');
  const rows=await new Promise((resolve,reject)=>{
    Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>resolve(r.data),error:reject});
  });
  const norm=rows.map(normalizeRow).sort((a,b)=>(a._order||0)-(b._order||0));
  LOG('rows:', norm.length);

  const {isPublic,unique,prefix,useFileName,market,marketsIndex,pinUri,pinPos,rowDelayMs}=opts;

  if(opts.preloadIndex){
    for(const mkt of marketsIndex){
      for(const aid of parseArtistIds()){
        await buildIndexFor(aid, mkt);
      }
    }
  }

  const seen=new Set(); const uris=[];
  let okCount=0; const pinIndex0=Math.max(0, Number(pinPos||20)-1);

  for(let i=0;i<norm.length;i++){
    checkAbort();
    const r=norm[i];
    try{
      const res=await resolveTrack(r, marketsIndex, market);
      if(res && res.uri){
        if(pinUri && okCount===pinIndex0){ if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin @', pinIndex0+1, pinUri); } }
        if(!unique || !seen.has(res.uri)){ uris.push(res.uri); seen.add(res.uri); okCount++; LOG('[ok]', i+1, res.uri); }
        else{ LOG('[dup] skip', i+1, res.uri); }
      }else{
        LOG('[x] not found', i+1, r.title||'');
        lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
      }
    }catch(e){
      if(e.message==='aborted'){ LOG('中断しました'); return; }
      LOG('[!] error', i+1, (r.title||''), e.message);
      lastNotFoundRows.push({source:file.name, index:i+1, title:r.title||'', remixer:r.remixer||'', isrc:r.isrc||'', catalog:r.catalog||''});
    }
    const pause = Number(rowDelayMs||0); if(pause>0) await sleep(pause);
  }

  if(pinUri && okCount<=pinIndex0){ if(!unique || !seen.has(pinUri)){ uris.push(pinUri); seen.add(pinUri); LOG('pin (tail)', pinUri); } }

  const base=file.name.replace(/\.csv$/i,'').slice(0,140);
  const name=useFileName ? (prefix + base) : (prefix || 'TDCS - Singles(1-4)');
  const pl=await createPlaylist(name, isPublic);
  LOG('playlist:', pl.external_urls?.spotify||'');
  if(uris.length) await addUris(pl.id, uris);
  LOG('DONE', file.name, '->', pl.external_urls?.spotify||'');
}

/* ====== UI wiring ====== */
document.getElementById('btnBuild').onclick=async()=>{
  try{ needToken(); }catch(_){ alert('Sign in first'); return; }
  ABORT=false; lastNotFoundRows=[];
  const files=[...(getEl('csvFiles')?.files||[])];
  if(!files.length){ alert('Choose CSV'); return; }

  applyRateMode(getValue('rateMode','gentle'));

  const opts={};
  opts.isPublic=getChecked('isPublic',false);
  opts.unique=getChecked('uniqueUris',true);
  opts.market=getValue('searchMarket','from_token');
  opts.preloadIndex=getChecked('preloadIndex',true);
  const idx = getMultiValues('indexMarkets',['JP','US','GB']);
  opts.marketsIndex=idx.length?idx:['JP','US','GB'];
  opts.prefix=getValue('prefix','');
  opts.useFileName=getChecked('useFileName',true);
  opts.pinUri=toTrackUri(getValue('pinUri','').trim());
  opts.pinPos=Number(getValue('pinPos','20')||20);
  opts.rowDelayMs=Number(getValue('rowDelayMs','80')||80);

  for(const f of files){ if(ABORT) break; await buildOneCSV(f, opts); }

  if(ABORT){ alert('中断しました。ログを確認してください。'); }
  else { alert('All done. 必要なら「Export not-found.csv」もどうぞ。'); }
};
document.getElementById('btnExportNF').onclick=exportNotFound;
document.getElementById('btnSignOut').onclick=()=>{ sessionStorage.clear(); localStorage.removeItem('code_verifier'); const s=getEl('authStatus'); if(s) s.textContent='No token.'; const h=getEl('authHint'); if(h) h.style.display='block'; LOG('Signed out (local).'); };

(async()=>{
  try{
    if(!token()) throw 0;
    const m=await me();
    setAuthStatus('Signed in as '+(m.display_name||m.id));
    const h=getEl('authHint'); if(h) h.style.display='none';
  }catch(_){
    setAuthStatus('No token.');
    const h=getEl('authHint'); if(h) h.style.display='block';
  }
})();
</script>
</body>
</html>
