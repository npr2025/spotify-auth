<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TDCS 130→100 (Remix-only, Pins, RL-safe)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:1100px;margin:36px auto;padding:0 12px}
  button{padding:8px 12px;border:1px solid #bbb;border-radius:8px;background:#f6f6f6;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  input,select{padding:6px 8px;border:1px solid #ccc;border-radius:6px}
  #row{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
  #pins{display:grid;grid-template-columns:180px 1fr 160px;gap:8px;align-items:center;margin:10px 0;padding:10px;border:1px dashed #ddd;border-radius:8px;background:#fafafa}
  #log{background:#0b1220;color:#cfe3ff;padding:10px;border-radius:8px;max-height:360px;overflow:auto;white-space:pre-wrap;margin-top:12px}
  #debug{font-size:13px;color:#333;background:#f6f6f9;border:1px solid #e5e6ef;border-radius:8px;padding:8px;margin:12px 0}
  ol{line-height:1.5}
  label.small{font-size:12px;color:#666}
</style>
</head>
<body>
<h1>Spotify Authentication</h1>
<p id="status">Booting…</p>

<div id="row">
  <label>Market
    <select id="market">
      <option>US</option><option selected>JP</option><option>GB</option><option>DE</option>
    </select>
  </label>
  <label>Depth
    <select id="depth">
      <option value="4">(200 results)</option>
      <option value="6" selected>(300 results)</option>
      <option value="8">(400 results)</option>
      <option value="12">(600 results)</option>
      <option value="16">(800 results)</option>
    </select>
  </label>
  <button id="btn130">Build 130 (Remix-only)</button>
  <button id="btn100" disabled>Pick Balanced 100 (Remix-only)</button>
  <button id="btnHead5" disabled>Optimize Head-5</button>
  <input id="plName" style="min-width:360px" value="PROGAPANDA • Balanced100 (TDCS Remixes)">
  <label><input id="plPublic" type="checkbox"> Make Public</label>
  <button id="btnCreate" disabled>Create Playlist</button>
  <button id="btnAbort" style="margin-left:auto">Abort</button>
</div>

<div id="pins">
  <div><b>Pin Track IDs（固定）</b><div class="small">Remixのみ採用／“Mix”は全面除外／空欄は無視・重複は排除</div></div>
  <input id="pinOpen"  value="0ueNjvhtXGDFkJQ5WBQ4mE"><span class="small">先頭 (#1)</span>
  <div></div>
  <input id="pinEarly" value="63dYSEftdSYwMAFBNfQYsA"><span class="small">上旬 (#8)</span>
  <div></div>
  <input id="pinMid"   value="3NQuIFfQPhTICaXGYe5dAt"><span class="small">中盤 (#45)</span>
  <div></div>
  <input id="pinLate"  value="7ltcrdlVsXyU5HU9VCAj6P"><span class="small">後半 (#75)</span>
</div>

<div id="debug">
  <b>Token:</b> <span id="tokstate">–</span> |
  <button id="btnRefresh">Refresh token</button>
  <button id="btnReauth">Re-auth</button>
</div>

<ol id="tracks"></ol>
<pre id="log"></pre>

<script>
/*** 固定（あなたの環境） ***/
const CLIENT_ID    = "1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI = "https://npr2025.github.io/spotify-auth/callback.html";
const ARTIST_ID    = "55fvQ5I2IZUfcFT2DV02T3";
const ARTIST_NAME  = "The Darrow Chem Syndicate";
const USER_ID      = "22fqn5mozguuegi2t3l2zeugy";
const EXACT_LIMIT_130 = 130;
const EXACT_LIMIT_100 = 100;

/*** 便利関数 ***/
const $=s=>document.querySelector(s);
const log=m=>{const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; console.log(m);}
const setStatus=t=>{ $("#status").textContent=t; log(t); }
const sleep = ms => new Promise(r=>setTimeout(r,ms));

/*** フィルタ：Remixのみ / “Mix”単語は除外 ***/
function isRemixOnly(name){
  const s = name||"";
  return /\bremix\b/i.test(s) && !/\bmix\b/i.test(s);
}

/*** トークン（PKCE・読み書き） ***/
function saveToken(t){
  const expAt = Date.now() + (t.expires_in||3600)*1000;
  sessionStorage.setItem("sp_access_token", t.access_token);
  if(t.refresh_token) sessionStorage.setItem("sp_refresh_token", t.refresh_token);
  sessionStorage.setItem("sp_exp_at", String(expAt));
  sessionStorage.setItem("sp_scope", t.scope||"");
  updateTokenDebug();
}
function clearToken(){
  ["sp_access_token","sp_refresh_token","sp_exp_at","sp_scope","pkce_state","pkce_verifier"].forEach(k=>sessionStorage.removeItem(k));
  updateTokenDebug();
}
function updateTokenDebug(){
  const exp=+sessionStorage.getItem("sp_exp_at")||0;
  const left = exp? Math.max(0, Math.floor((exp-Date.now())/1000)) : 0;
  const rt = !!sessionStorage.getItem("sp_refresh_token");
  const sc = sessionStorage.getItem("sp_scope")||"";
  $("#tokstate").textContent = (sessionStorage.getItem("sp_access_token")?"OK":"NONE")+
    ` / exp in ${left}s / refresh:${rt?"yes":"no"} / scope:[${sc}]`;
}
async function tokenByCode(code,verifier){
  const body=new URLSearchParams({client_id:CLIENT_ID,grant_type:"authorization_code",code,redirect_uri:REDIRECT_URI,code_verifier:verifier});
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok) throw new Error(`Token exchange ${r.status}`);
  return r.json();
}
async function refreshTokenNow(){
  const rt=sessionStorage.getItem("sp_refresh_token");
  if(!rt) throw new Error("No refresh_token");
  const r=await fetch("https://accounts.spotify.com/api/token",{
    method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},
    body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:rt})
  });
  if(!r.ok){ clearToken(); throw new Error(`Refresh ${r.status}`); }
  const t=await r.json(); saveToken(t); log("Token refreshed.");
}
async function ensureToken(requiredScopes=[]){
  updateTokenDebug();
  const tok=sessionStorage.getItem("sp_access_token");
  const exp=+sessionStorage.getItem("sp_exp_at")||0;
  if(tok && Date.now()<exp-120000){
    if(!requiredScopes.length) return tok;
    const s=(sessionStorage.getItem("sp_scope")||"").split(" ");
    if(requiredScopes.every(x=>s.includes(x))) return tok;
  }
  const rt=sessionStorage.getItem("sp_refresh_token");
  if(rt){ await refreshTokenNow(); return sessionStorage.getItem("sp_access_token"); }
  throw new Error("Need login");
}
function reauth(){ location.href="auth.html"; }

/*** レート制御（429対策強化） ***/
let BASE_GAP = 1200;   // ベース間隔
let extraCooldown = 0; // 429で伸ばす
let consec429 = 0;
let lastReqAt = 0;
let ABORT = false;

async function spRequest(method, path, {params, body, scopeNeed=[]}={}){
  // 最低インターバル保証
  const now = Date.now();
  const waitMin = Math.max(0, lastReqAt + BASE_GAP + extraCooldown - now);
  if(waitMin>0) await sleep(waitMin);
  lastReqAt = Date.now();

  let tok;
  try{ tok = await ensureToken(method==="GET" ? [] : scopeNeed); }
  catch(e){ if(method==="GET"){ setStatus("Not signed in. Click Re-auth."); return {__auth_needed:true}; } throw e; }

  const u = new URL("https://api.spotify.com/v1/"+path);
  if(params) Object.entries(params).forEach(([k,v])=>{ if(v!=null&&v!=="") u.searchParams.set(k,v);});
  const r = await fetch(u,{method,headers:{Authorization:"Bearer "+tok,"Content-Type":"application/json"},body: body?JSON.stringify(body):undefined});

  if(r.status===401){ try{await refreshTokenNow();}catch{} return spRequest(method,path,{params,body,scopeNeed}); }

  if(r.status===429){
    const ra = +r.headers.get("retry-after")||2;
    consec429++;
    // 連続429で倍々に
    const bump = (ra*1000) * Math.min(4, consec429); // 2s → 4s → 6s → 8s …
    extraCooldown = Math.max(extraCooldown, bump + 500 + Math.floor(Math.random()*500));
    log(`${method} ${path} → 429; wait ${Math.round(extraCooldown/1000)}s (try ${consec429})`);
    if(ABORT) throw new Error("Aborted");
    await sleep(extraCooldown);
    return spRequest(method,path,{params,body,scopeNeed});
  }

  // 正常時はゆっくりクールダウンを戻す
  consec429 = 0;
  extraCooldown = Math.max(0, Math.floor(extraCooldown*0.6));
  if(!r.ok){
    const txt=await r.text();
    throw new Error(`${method} ${path} ${r.status} ${txt}`);
  }
  return r.json();
}
const spGet  = (path,params)=>spRequest("GET", path, {params});
const spPost = (path,body,scopeNeed)=>spRequest("POST", path, {body, scopeNeed});

/*** 検索：Remix-only（Mix除外） ***/
async function searchAllRemixesByArtist(market="US", maxPages=6){
  const keep=[], seen=new Set(); let offset=0;
  const q = `artist:"${ARTIST_NAME}" remix`;
  for(let i=0;i<maxPages;i++){
    if(ABORT) throw new Error("Aborted");
    const d=await spGet("search",{ q, type:"track", market, limit:50, offset });
    if(d.__auth_needed) return [];
    const items=d?.tracks?.items||[];
    for(const t of items){
      if(!t?.name) continue;
      if(!t.artists?.some(a=>a.id===ARTIST_ID)) continue;
      if(!isRemixOnly(t.name)) continue;
      if(!seen.has(t.id)){ seen.add(t.id); keep.push(t); }
    }
    log(`page ${i+1}: fetched ${items.length}, remixes kept ${keep.length}`);
    if(!d?.tracks?.next) break;
    offset += 50;
  }
  return keep;
}

async function fetchTrackMeta(id, market="US"){
  const t=await spGet(`tracks/${id}`,{market});
  if(t.__auth_needed) throw new Error("Not signed in");
  if(!t || !t.id) throw new Error("Track not found: "+id);
  if(!t.artists?.some(a=>a.id===ARTIST_ID)) throw new Error("Not TDCS track: "+id);
  if(!isRemixOnly(t.name)) throw new Error("Pin must be REMIX-only (no 'Mix'): "+t.name);
  const artists=t.artists.map(a=>a.name).join(", ");
  return { id:t.id, name:t.name, artists,
    popularity:t.popularity||0,
    track_url:t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`,
    album:t.album?.name||"", album_url:t.album?.external_urls?.spotify||"" };
}

/*** 整形・選曲 ***/
let base130=[], lastData=[];
function render(list){
  const ol=$("#tracks"); ol.innerHTML="";
  list.forEach((r,i)=>{
    const li=document.createElement("li");
    const a=document.createElement("a"); a.href=r.track_url; a.textContent=r.name; a.target="_blank"; a.rel="noopener";
    li.append(`${i+1}. `, a, ` — ${r.artists} (pop:${r.popularity})`);
    ol.appendChild(li);
  });
  const on=list.length>0; $("#btn100").disabled=!on; $("#btnHead5").disabled=!on; $("#btnCreate").disabled=!on;
}
function pickBalanced100(rows){
  rows.forEach(r=>{ r._score = (r.popularity||0)/100; });
  const byScore=[...rows].sort((a,b)=>b._score-a._score);
  const picked=[], seen=new Set(), albumCnt={};
  const okAlbum=r=>{ const k=r.album+"::"+r.artists; albumCnt[k]=(albumCnt[k]||0)+1; return albumCnt[k]<=2; };
  for(const r of byScore){
    if(picked.length>=EXACT_LIMIT_100) break;
    if(!seen.has(r.id) && okAlbum(r)){ picked.push(r); seen.add(r.id); }
  }
  return picked;
}

/*** Pins ***/
function getPinIds(){
  return {
    open: ($("#pinOpen").value||"").trim(),
    early:($("#pinEarly").value||"").trim(),
    mid:  ($("#pinMid").value||"").trim(),
    late: ($("#pinLate").value||"").trim()
  };
}
function dropDupAndKeepLen(list, keepSet, targetLen){
  const out=[]; const seen=new Set();
  for(const r of list){
    if(seen.has(r.id)) continue;
    seen.add(r.id); out.push(r);
  }
  while(out.length>targetLen){
    const last = out[out.length-1];
    if(keepSet.has(last.id)){
      let idx=-1; for(let i=out.length-1;i>=0;i--){ if(!keepSet.has(out[i].id)){ idx=i; break; } }
      if(idx<0) break; out.splice(idx,1);
    }else out.pop();
  }
  return out;
}
async function ensurePinsInBase(market){
  const pins=getPinIds();
  const pinList=[pins.open,pins.early,pins.mid,pins.late].filter(Boolean);
  const have=new Set(base130.map(x=>x.id));
  for(const id of pinList){
    if(!have.has(id)){
      try{ base130.unshift(await fetchTrackMeta(id, market)); have.add(id); }
      catch(e){ log("PIN include warn: "+e.message); }
    }
  }
  base130 = dropDupAndKeepLen(base130, new Set(pinList), EXACT_LIMIT_130);
}
async function forcePinsInto100(list, market){
  const pins=getPinIds();
  const plan=[
    {id:pins.open,  pos:0},   // #1
    {id:pins.early, pos:7},   // #8
    {id:pins.mid,   pos:44},  // #45
    {id:pins.late,  pos:74}   // #75
  ].filter(p=>p.id);
  const byId=new Map(list.map(x=>[x.id,x]));
  for(const p of plan){
    if(!byId.has(p.id)){
      try{ const row=await fetchTrackMeta(p.id, market); list.push(row); byId.set(row.id,row); }
      catch(e){ log("PIN add warn: "+e.message); }
    }
  }
  const pinSet=new Set(plan.map(p=>p.id));
  list = list.filter(x=>!pinSet.has(x.id));
  for(const p of plan){
    const row=byId.get(p.id); if(!row) continue;
    const pos=Math.min(Math.max(p.pos,0), list.length);
    list.splice(pos,0,row);
  }
  return dropDupAndKeepLen(list, pinSet, EXACT_LIMIT_100);
}

/*** フロー ***/
async function build130(){
  $("#btn130").disabled=true; ABORT=false; consec429=0; extraCooldown=0;
  try{
    const mk=$("#market").value||"US";
    const depth=parseInt($("#depth").value||"6",10);
    setStatus(`Searching REMIXES of "${ARTIST_NAME}" in ${mk}… (Exclude any 'Mix'), depth=${depth}`);
    let tracks=await searchAllRemixesByArtist(mk, depth);
    if(!tracks || tracks.length===0){ setStatus("Sign in first (Re-auth)."); return; }
    tracks = tracks.filter(t=>t && t.artists?.some(a=>a?.id===ARTIST_ID))
                   .sort((a,b)=>(b.popularity||0)-(a.popularity||0));
    base130 = tracks.slice(0, Math.min(EXACT_LIMIT_130, tracks.length)).map(t=>{
      const artists=t.artists.map(a=>a.name).join(", ");
      return {id:t.id,name:t.name,artists,popularity:t.popularity||0,
              track_url:t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`,
              album:t.album?.name||"", album_url:t.album?.external_urls?.spotify||""};
    });
    await ensurePinsInBase(mk);
    base130.sort((a,b)=>(b.popularity||0)-(a.popularity||0));
    lastData = base130.slice();
    render(lastData);
    setStatus(`Loaded ${lastData.length} REMIX tracks — TDCS ONLY. Cooldown≈${Math.round((BASE_GAP+extraCooldown)/1000)}s`);
  }catch(e){ setStatus("Build error: "+(e.message||e)); }
  $("#btn130").disabled=false;
}
$("#btn130").onclick=build130;

$("#btn100").onclick=async ()=>{
  if(!base130.length) return;
  const mk=$("#market").value||"US";
  const remixOnly = base130.filter(t => isRemixOnly(t.name));
  let list = pickBalanced100(remixOnly);
  list = await forcePinsInto100(list, mk);
  lastData = list;
  render(lastData);
  setStatus(`Balanced 100 (Remix-only) + Pins — ${lastData.length}`);
};

$("#btnHead5").onclick=()=>{
  if(!lastData.length) return;
  const pins=getPinIds(); const pinSet=new Set(Object.values(pins).filter(Boolean));
  const isPinned = x=>pinSet.has(x.id);
  const pool=lastData.filter(t=>!isPinned(t)).map(t=>({t, pop:t.popularity||0})).sort((a,b)=>b.pop-a.pop);
  const take=()=>pool.shift()?.t;
  const head=[take(),take(),take(),take(),take()].filter(Boolean);
  const nonPinIdxs = lastData.map((x,i)=>({x,i})).filter(v=>!isPinned(v.x)).map(v=>v.i).slice(0,head.length);
  head.forEach((h,k)=>{ lastData[nonPinIdxs[k]] = h; });
  render(lastData);
  setStatus("Head-5 optimized (Pins preserved)");
};

async function createPlaylist(){
  try{
    if(!lastData.length) return;
    const isPublic=$("#plPublic").checked;
    const scopeNeed=[isPublic?"playlist-modify-public":"playlist-modify-private"];
    const me=await spGet("me");
    if(me.__auth_needed){ setStatus("Sign in first (Re-auth)."); return; }
    if(me?.id && me.id!=="22fqn5mozguuegi2t3l2zeugy") throw new Error(`Signed in as ${me.id}. Please sign in as 22fqn5mozguuegi2t3l2zeugy.`);
    const pl=await spPost(`users/${"22fqn5mozguuegi2t3l2zeugy"}/playlists`,{
      name:$("#plName").value||"PROGAPANDA • Balanced100 (TDCS Remixes)",
      description:"Auto-curated REMIX-only (no Mix). Pins enforced (#1/#8/#45/#75). TDCS 130→100.",
      public:!!isPublic
    }, scopeNeed);
    const uris=[...new Set(lastData.map(x=>"spotify:track:"+x.id))];
    for(let i=0;i<uris.length;i+=100){
      await spPost(`playlists/${pl.id}/tracks`,{uris:uris.slice(i,i+100)}, scopeNeed);
      await sleep(300);
    }
    const url=pl.external_urls?.spotify || `https://open.spotify.com/playlist/${pl.id}`;
    setStatus(`Done — ${lastData.length} tracks added (${isPublic?"public":"private"}). ${url}`);
  }catch(e){ setStatus("Playlist error: "+(e.message||e)); }
}
$("#btnCreate").onclick=createPlaylist;

/*** Abort ***/
$("#btnAbort").onclick=()=>{ ABORT=true; setStatus("Abort requested. 現在のAPI呼び出し完了後に停止します。"); };

/*** Token ops ***/
$("#btnRefresh").onclick=()=>refreshTokenNow().catch(e=>setStatus("Refresh error: "+e.message));
$("#btnReauth").onclick=()=>{ clearToken(); reauth(); };

/*** 起動（PKCEコールバック） ***/
(async function boot(){
  try{
    const qp=new URLSearchParams(location.search);
    const code=qp.get("code"), state=qp.get("state");
    if(code){
      const saved=sessionStorage.getItem("pkce_state");
      const verifier=sessionStorage.getItem("pkce_verifier");
      if(saved && verifier && state===saved){
        const tok=await tokenByCode(code,verifier);
        saveToken(tok);
        sessionStorage.removeItem("pkce_state");
        sessionStorage.removeItem("pkce_verifier");
        history.replaceState({},document.title,location.pathname);
      }else{
        setStatus("State/verifier missing. Re-auth.");
      }
    }
    try{
      await ensureToken([]); // GET用
      setStatus("Signed in. ①Build 130（Remix-only）→ ②Pick Balanced 100（Pins #1/#8/#45/#75）→ ③Head-5 → ④Create Playlist（非公開）");
    }catch{ setStatus("Not signed in. Click Re-auth."); }
  }catch(e){ setStatus("Boot error: "+(e.message||e)); }
})();
</script>
</body>
</html>
