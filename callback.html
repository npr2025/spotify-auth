<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TDCS 130→120→100 (Remix-only, Pins #1/#8/#45/#75)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:1100px;margin:36px auto;padding:0 12px}
  h1{margin:0 0 8px}
  button{padding:8px 12px;border:1px solid #bbb;border-radius:8px;background:#f6f6f6;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  input,select{padding:6px 8px;border:1px solid #ccc;border-radius:6px}
  #row{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
  #pins{display:grid;grid-template-columns:180px 1fr 160px;gap:8px;align-items:center;margin:10px 0;padding:10px;border:1px dashed #ddd;border-radius:8px;background:#fafafa}
  #log{background:#0b1220;color:#cfe3ff;padding:10px;border-radius:8px;max-height:420px;overflow:auto;white-space:pre-wrap;margin-top:12px}
  #debug{font-size:13px;color:#333;background:#f6f6f9;border:1px solid #e5e6ef;border-radius:8px;padding:8px;margin:12px 0}
  ol{line-height:1.55}
  label.small{font-size:12px;color:#666}
</style>
</head>
<body>
<h1>Spotify Authentication</h1>
<p id="status">Booting…</p>

<div id="row">
  <label>Market
    <select id="market"><option>US</option><option selected>JP</option><option>GB</option><option>DE</option></select>
  </label>
  <label>Speed
    <select id="speed">
      <option value="fast" selected>FAST（Search優先）</option>
      <option value="deep">DEEP（Albums遅いが網羅）</option>
    </select>
  </label>
  <button id="btn130">① Build 130 (Remix-only)</button>
  <button id="btn120" disabled>② Trim 120 (album≤2, keep pins)</button>
  <button id="btn100" disabled>③ Balanced 100 (no adjacent remixer)</button>
  <button id="btnHead5" disabled>④ Optimize Head-5</button>
  <input id="plName" style="min-width:360px" value="PROGAPANDA • Balanced100 (TDCS Remixes)">
  <label><input id="plPublic" type="checkbox"> Make Public</label>
  <button id="btnCreate" disabled>⑤ Create Playlist</button>
</div>

<div id="pins">
  <div><b>Pin Track IDs（固定）</b>
    <div class="small">Remixのみ採用／“Mix”は全面除外。空欄は無視、重複は排除。</div>
  </div>
  <input id="pinOpen"  value="0ueNjvhtXGDFkJQ5WBQ4mE" placeholder="先頭 (#1)"><span class="small">先頭 (#1)</span>
  <div></div>
  <input id="pinEarly" value="63dYSEftdSYwMAFBNfQYsA" placeholder="上旬 (#8)"><span class="small">上旬 (目安 #8)</span>
  <div></div>
  <input id="pinMid"   value="3NQuIFfQPhTICaXGYe5dAt" placeholder="中盤 (#45)"><span class="small">中盤 (目安 #45)</span>
  <div></div>
  <input id="pinLate"  value="7ltcrdlVsXyU5HU9VCAj6P" placeholder="後半 (#75)"><span class="small">後半 (目安 #75)</span>
</div>

<div id="debug">
  <b>Token:</b> <span id="tokstate">–</span> |
  <button id="btnRefresh">Refresh token</button>
  <button id="btnReauth">Re-auth</button>
</div>

<ol id="tracks"></ol>
<pre id="log"></pre>

<script>
/*** 固定 ***/
const CLIENT_ID    = "1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI = "https://npr2025.github.io/spotify-auth/callback.html";
const ARTIST_ID    = "55fvQ5I2IZUfcFT2DV02T3";
const ARTIST_NAME  = "The Darrow Chem Syndicate";
const USER_ID      = "22fqn5mozguuegi2t3l2zeugy";
const SCOPES = ["playlist-modify-private","playlist-modify-public"];
const LIMIT_130=130, LIMIT_120=120, LIMIT_100=100, ALBUM_CAP_120=2;

/*** util ***/
const $=s=>document.querySelector(s);
const log=m=>{const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; console.log(m);}
const setStatus=t=>{ $("#status").textContent=t; log(t); }
const sleep=ms=>new Promise(r=>setTimeout(r,ms));

/*** Remix-only / “Mix”除外 ***/
const isRemixOnly = t => /\bremix\b/i.test(t||"") && !/\bmix\b/i.test(t||"");

/*** リミキサー抽出 ***/
function extractRemixers(title){
  const m = (title||"").replace(/\u3000/g," ").match(/[-(]([^()\-]*?)\s*remix\)?$/i);
  if(!m) return [];
  return m[1]
    .split(/(?:&|,| x | and | with | vs\. |\/|×| feat\. )/i)
    .map(v=>v.replace(/\s+/g," ").trim().toLowerCase())
    .filter(Boolean);
}

/*** Token ***/
function saveToken(t){ const exp=Date.now()+(t.expires_in||3600)*1000;
  sessionStorage.setItem("sp_access_token",t.access_token);
  if(t.refresh_token) sessionStorage.setItem("sp_refresh_token",t.refresh_token);
  sessionStorage.setItem("sp_exp_at",exp); sessionStorage.setItem("sp_scope",t.scope||""); updateTokenDebug();
}
function clearToken(){ ["sp_access_token","sp_refresh_token","sp_exp_at","sp_scope","pkce_state","pkce_verifier"].forEach(k=>sessionStorage.removeItem(k)); updateTokenDebug(); }
function updateTokenDebug(){
  const exp=+sessionStorage.getItem("sp_exp_at")||0, left=exp?Math.max(0,((exp-Date.now())/1000)|0):0;
  $("#tokstate").textContent=(sessionStorage.getItem("sp_access_token")?"OK":"NONE")+` / exp in ${left}s / scope:[${sessionStorage.getItem("sp_scope")||""}]`;
}
async function tokenByCode(code,verifier){
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},
    body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"authorization_code",code,redirect_uri:REDIRECT_URI,code_verifier:verifier})});
  if(!r.ok) throw new Error(`Token exchange ${r.status}`); return r.json();
}
async function refreshTokenNow(){
  const rt=sessionStorage.getItem("sp_refresh_token"); if(!rt) throw new Error("No refresh_token");
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},
    body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:rt})});
  if(!r.ok){ clearToken(); throw new Error(`Refresh ${r.status}`); }
  saveToken(await r.json()); log("Token refreshed.");
}
async function ensureToken(req=SCOPES){
  const scopeOk=(sessionStorage.getItem("sp_scope")||"").split(" ").filter(Boolean);
  if(!req.every(s=>scopeOk.includes(s))){ reauth(); await new Promise(()=>{}); }
  const tok=sessionStorage.getItem("sp_access_token"), exp=+sessionStorage.getItem("sp_exp_at")||0;
  if(tok && Date.now()<exp-120000) return tok;
  const rt=sessionStorage.getItem("sp_refresh_token"); if(rt){ await refreshTokenNow(); return sessionStorage.getItem("sp_access_token"); }
  reauth(); await new Promise(()=>{});
}
function reauth(){ location.href="auth.html"; }

/*** API（429対策） ***/
let GAP_MS=1500;
async function spGet(path,params={}){
  const u=new URL("https://api.spotify.com/v1/"+path);
  Object.entries(params).forEach(([k,v])=>{ if(v!=null&&v!=="") u.searchParams.set(k,v); });
  await sleep(GAP_MS);
  const r=await fetch(u,{headers:{Authorization:"Bearer "+await ensureToken()}});
  if(r.status===401){ await refreshTokenNow(); return spGet(path,params); }
  if(r.status===429){
    const ra=(+r.headers.get("retry-after")||2)*1000;
    GAP_MS=Math.max(GAP_MS*1.8+400, ra+3000, 3000); // 強めに引き上げ
    log(`429 ⇒ wait ${ra/1000}s, cooldown≈${GAP_MS}ms`);
    await sleep(ra);
    return spGet(path,params);
  }
  if(!r.ok) throw new Error(`${path} ${r.status}`);
  return r.json();
}
async function spPost(path,body,need=["playlist-modify-private"]){
  await ensureToken(need); await sleep(GAP_MS);
  const r=await fetch("https://api.spotify.com/v1/"+path,{method:"POST",headers:{
    Authorization:"Bearer "+sessionStorage.getItem("sp_access_token"),"Content-Type":"application/json"},body:JSON.stringify(body)});
  if(r.status===401){ await refreshTokenNow(); return spPost(path,body,need); }
  if(r.status===429){
    const ra=(+r.headers.get("retry-after")||2)*1000;
    GAP_MS=Math.max(GAP_MS*1.8+400, ra+3000, 3000);
    log(`POST 429 ⇒ wait ${ra/1000}s, cooldown≈${GAP_MS}ms`);
    await sleep(ra); return spPost(path,body,need);
  }
  if(!r.ok) throw new Error(`POST ${path} ${r.status} ${await r.text()}`);
  return r.json();
}

/*** 検索ハイブリッド ***/
async function searchRemixIdsByMarkets(markets, perMarketPages=6){
  const ids=new Set();
  for(const m of markets){
    for(let p=0;p<perMarketPages;p++){
      const d=await spGet("search",{q:`artist:"${ARTIST_NAME}" remix`, type:"track", market:m, limit:50, offset:p*50});
      const items=d?.tracks?.items||[];
      for(const t of items){
        if(!t?.id) continue;
        if(!t.artists?.some(a=>a.id===ARTIST_ID)) continue;
        if(!isRemixOnly(t.name)) continue;
        ids.add(t.id);
      }
      if(!d?.tracks?.next) break;
    }
  }
  return [...ids];
}
async function collectAlbumIds(){
  const ids=new Set();
  for(const g of ["album","single","compilation","appears_on"]){
    let offset=0, scanned=0, CAP=70; // まず70枚で打ち切り（429回避）
    while(true){
      const d=await spGet(`artists/${ARTIST_ID}/albums`,{include_groups:g,limit:50,offset});
      const items=d?.items||[];
      for(const a of items){ if(a?.id) ids.add(a.id); scanned++; if(scanned>=CAP) break; }
      if(items.length<50 || scanned>=CAP) break;
      offset+=50;
    }
  }
  return [...ids];
}
async function collectRemixTrackIdsFromAlbums(albumIds){
  const keep=new Set();
  for(const id of albumIds){
    const d=await spGet(`albums/${id}/tracks`,{limit:50});
    for(const t of (d?.items||[])){ if(t?.id && isRemixOnly(t.name)) keep.add(t.id); }
    if(keep.size>=1500) break;
  }
  return [...keep];
}
async function fetchTracksDetail(ids, market){
  const out=[];
  for(let i=0;i<ids.length;i+=50){
    const d=await spGet("tracks",{ids:ids.slice(i,i+50).join(","), market});
    for(const t of (d?.tracks||[])){
      if(!t||!t.id) continue;
      if(!t.artists?.some(a=>a.id===ARTIST_ID)) continue;
      if(!isRemixOnly(t.name)) continue;
      out.push({
        id:t.id, name:t.name, popularity:t.popularity||0,
        artists:(t.artists||[]).map(a=>a.name).join(", "),
        remixers:extractRemixers(t.name),
        track_url:t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`,
        album:t.album?.name||"", album_url:t.album?.external_urls?.spotify||""
      });
    }
  }
  const m=new Map(); for(const x of out){ if(!m.has(x.id)) m.set(x.id,x); }
  return [...m.values()];
}

/*** 表示と選曲 ***/
let base130=[], pool120=[], final100=[];
function render(list){
  const ol=$("#tracks"); ol.innerHTML="";
  list.forEach((r,i)=>{
    const li=document.createElement("li");
    const a=document.createElement("a"); a.href=r.track_url; a.textContent=r.name; a.target="_blank"; a.rel="noopener";
    const remix=r.remixers?.length?` [${r.remixers.join(" & ")}]`:"";
    li.append(`${i+1}. `, a, ` — ${r.artists}${remix} (pop:${r.popularity})`);
    ol.appendChild(li);
  });
  $("#btn120").disabled = base130.length===0;
  $("#btn100").disabled = pool120.length===0;
  $("#btnHead5").disabled = (final100.length===0 && pool120.length===0);
  $("#btnCreate").disabled = final100.length===0;
}

/*** Pins ***/
function getPinIds(){
  return {
    open: ($("#pinOpen").value||"").trim(),
    early:($("#pinEarly").value||"").trim(),
    mid:  ($("#pinMid").value||"").trim(),
    late: ($("#pinLate").value||"").trim()
  };
}
function uniqKeepOrder(list){ const seen=new Set(), out=[]; for(const x of list){ if(!seen.has(x.id)){seen.add(x.id); out.push(x);} } return out; }

/*** 130 → 120 ***/
function trimTo120(list){
  const pins=Object.values(getPinIds()).filter(Boolean); const pinSet=new Set(pins);
  const albumCnt={}; const out=[];
  for(const tr of list){
    if(out.length>=LIMIT_120) break;
    const key=tr.album+"::"+tr.artists;
    const ok = pinSet.has(tr.id) || (albumCnt[key]||0) < ALBUM_CAP_120;
    if(ok){ out.push(tr); albumCnt[key]=(albumCnt[key]||0)+1; }
  }
  const ids=new Set(out.map(x=>x.id));
  for(const p of pins){ if(!ids.has(p)){ const f=list.find(x=>x.id===p); if(f){ out.unshift(f); ids.add(f.id);} } }
  return uniqKeepOrder(out).slice(0,LIMIT_120);
}

/*** 120 → 100（同一リミキサー隣接禁止＋ピン配置） ***/
function build100NoAdj(pool){
  const pins=getPinIds();
  const plan=[{id:pins.open,pos:0},{id:pins.early,pos:7},{id:pins.mid,pos:44},{id:pins.late,pos:74}].filter(p=>p.id);
  const pinSet=new Set(plan.map(p=>p.id));
  const arr=new Array(LIMIT_100).fill(null);
  const byId=new Map(pool.map(x=>[x.id,x]));
  for(const p of plan){ if(byId.has(p.id)) arr[p.pos]=byId.get(p.id); }
  const rest=pool.filter(x=>!pinSet.has(x.id)).sort((a,b)=>(b.popularity||0)-(a.popularity||0));
  const share=(a,b)=>{ if(!a||!b) return false; const A=new Set(a.remixers||[]), B=new Set(b.remixers||[]); for(const k of A){ if(B.has(k)) return true; } return false; };
  for(let i=0;i<LIMIT_100;i++){
    if(arr[i]) continue;
    const prev=i>0?arr[i-1]:null;
    let pick=-1;
    for(let j=0;j<rest.length;j++){ if(!prev || !share(prev,rest[j])){ pick=j; break; } }
    if(pick<0) pick=0;
    arr[i]=rest.splice(pick,1)[0];
  }
  // 軽いスワップ調整
  for(let i=1;i<LIMIT_100;i++){
    const isPinIdx = plan.some(p=>p.pos===i)||plan.some(p=>p.pos===i-1);
    if(!isPinIdx && arr[i] && arr[i-1]){
      const prev=arr[i-1], cur=arr[i];
      const A=new Set(prev.remixers||[]), B=new Set(cur.remixers||[]);
      let overlap=false; for(const k of A){ if(B.has(k)) overlap=true; }
      if(overlap){
        for(let k=i+1;k<LIMIT_100;k++){
          const next=arr[k]; const nb=new Set(next?.remixers||[]);
          let ok=true; for(const x of A){ if(nb.has(x)) ok=false; }
          if(ok){ [arr[i],arr[k]]=[arr[k],arr[i]]; break; }
        }
      }
    }
  }
  return arr;
}

/*** ボタン ***/
$("#btn130").onclick=async ()=>{
  $("#btn130").disabled=true; $("#btn120").disabled=true; $("#btn100").disabled=true; $("#btnHead5").disabled=true; $("#btnCreate").disabled=true;
  try{
    const mk=$("#market").value||"US";
    const mode=$("#speed").value; GAP_MS=(mode==="fast")?1500:2500;
    setStatus(`① Collecting candidates… mode=${mode.toUpperCase()}`);
    let ids=[];
    // まず検索で広く集める
    const world=[...new Set([mk,"US","JP","GB","DE","FR","ES","BR","AU","CA","MX"])];
    ids=await searchRemixIdsByMarkets(world,6);
    log(`search ids: ${ids.length}`);
    // 不足分をアルバム走査で補完（DEEPは最初から）
    if(ids.length < 140 || mode==="deep"){
      const albums=await collectAlbumIds();
      log(`albums fetched: ${albums.length}`);
      const fromAlbums=await collectRemixTrackIdsFromAlbums(albums);
      ids=[...new Set([...ids,...fromAlbums])];
      log(`+albums ids: ${ids.length}`);
    }
    // 詳細取得
    let tracks=await fetchTracksDetail(ids, mk);
    tracks.sort((a,b)=>(b.popularity||0)-(a.popularity||0));
    if(!tracks.length) throw new Error("No REMIX tracks found.");
    base130 = tracks.slice(0, Math.min(LIMIT_130, tracks.length));
    render(base130);
    setStatus(`Loaded base ${base130.length} (Remix-only, hybrid collector)`);
    $("#btn120").disabled=false;
  }catch(e){ setStatus("Build error: "+(e.message||e)); }
  $("#btn130").disabled=false;
};

$("#btn120").onclick=()=>{
  if(!base130.length) return;
  pool120=trimTo120(base130);
  render(pool120);
  setStatus(`Trimmed to ${pool120.length} (album≤${ALBUM_CAP_120}, pins ensured)`);
  $("#btn100").disabled=false;
};

$("#btn100").onclick=()=>{
  if(!pool120.length) return;
  final100=build100NoAdj(pool120);
  render(final100);
  setStatus(`Balanced ${final100.length} (no adjacent remixer, pins #1/#8/#45/#75)`);
  $("#btnHead5").disabled=false; $("#btnCreate").disabled=false;
};

$("#btnHead5").onclick=()=>{
  if(!final100.length) return;
  const pins=getPinIds(); const pinPos=new Map([[pins.open,0],[pins.early,7],[pins.mid,44],[pins.late,74]]);
  const pinSet=new Set([...pinPos.keys()].filter(Boolean));
  const isPinned=i=>pinSet.has(final100[i]?.id);
  const pool=final100.filter((t,i)=>!isPinned(i)).sort((a,b)=>(b.popularity||0)-(a.popularity||0)).slice(0,5);
  let p=0; for(let i=0;i<final100.length && p<pool.length;i++){ if(!isPinned(i)) final100[i]=pool[p++]; }
  render(final100); setStatus("Head-5 optimized (pins preserved)");
};

$("#btnCreate").onclick=async ()=>{
  try{
    if(!final100.length) return;
    const isPublic=$("#plPublic").checked;
    const need=[isPublic?"playlist-modify-public":"playlist-modify-private"];
    const me=await spGet("me"); if(me?.id && me.id!==USER_ID) throw new Error(`Signed in as ${me.id}. Please sign in as ${USER_ID}.`);
    const pl=await spPost(`users/${USER_ID}/playlists`,{
      name:$("#plName").value||"PROGAPANDA • Balanced100 (TDCS Remixes)",
      description:"Auto-curated REMIX-only (no Mix). Pins #1/#8/#45/#75. Hybrid collector (search+albums) → 130→120→100. No adjacent remixer.",
      public:!!isPublic
    }, need);
    const uris=[...new Set(final100.map(x=>"spotify:track:"+x.id))];
    for(let i=0;i<uris.length;i+=100){ await spPost(`playlists/${pl.id}/tracks`,{uris:uris.slice(i,i+100)}, need); await sleep(400); }
    const url=pl.external_urls?.spotify || `https://open.spotify.com/playlist/${pl.id}`;
    setStatus(`Done — ${final100.length} tracks added (${isPublic?"public":"private"}). ${url}`);
  }catch(e){ setStatus("Playlist error: "+(e.message||e)); }
};

/*** Token ops ***/
$("#btnRefresh").onclick=()=>refreshTokenNow().catch(e=>setStatus("Refresh error: "+e.message));
$("#btnReauth").onclick=()=>{ clearToken(); location.href="auth.html"; };

/*** boot ***/
(async function boot(){
  try{
    const qp=new URLSearchParams(location.search);
    const code=qp.get("code"), state=qp.get("state");
    if(code){
      const saved=sessionStorage.getItem("pkce_state"), v=sessionStorage.getItem("pkce_verifier");
      if(saved && v && state===saved){
        saveToken(await tokenByCode(code,v));
        sessionStorage.removeItem("pkce_state"); sessionStorage.removeItem("pkce_verifier");
        history.replaceState({},document.title,location.pathname);
      }
    }
    await ensureToken();
    setStatus("Signed in. ①Build 130 → ②Trim 120 → ③Balanced 100（Pins #1/#8/#45/#75 & no adjacent remixer）→ ④Head-5 → ⑤Create Playlist（非公開デフォルト）");
  }catch(e){ setStatus("Boot error: "+(e.message||e)); }
})();
</script>
</body>
</html>
