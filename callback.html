<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TDCS 130→100 (World Albums scan, Remix-only, Pins #1/#8/#45/#75)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:1100px;margin:36px auto;padding:0 12px}
  h1{margin:0 0 8px}
  button{padding:8px 12px;border:1px solid #bbb;border-radius:8px;background:#f6f6f6;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  input,select{padding:6px 8px;border:1px solid #ccc;border-radius:6px}
  #row{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
  #pins{display:grid;grid-template-columns:180px 1fr 160px;gap:8px;align-items:center;margin:10px 0;padding:10px;border:1px dashed #ddd;border-radius:8px;background:#fafafa}
  #log{background:#0b1220;color:#cfe3ff;padding:10px;border-radius:8px;max-height:360px;overflow:auto;white-space:pre-wrap;margin-top:12px}
  #debug{font-size:13px;color:#333;background:#f6f6f9;border:1px solid #e5e6ef;border-radius:8px;padding:8px;margin:12px 0}
  ol{line-height:1.5}
  label.small{font-size:12px;color:#666}
</style>
</head>
<body>
<h1>Spotify Authentication</h1>
<p id="status">Booting…</p>

<div id="row">
  <label>Fetch market（可用性確認用）
    <select id="market"><option selected>US</option><option>JP</option><option>GB</option><option>DE</option></select>
  </label>
  <button id="btn130">Build 130 (World/Albums → Remix-only)</button>
  <button id="btnTrim120" disabled>Trim to 120</button>
  <button id="btn100" disabled>Pick Balanced 100</button>
  <button id="btnHead5" disabled>Optimize Head-5</button>
  <input id="plName" style="min-width:360px" value="PROGAPANDA • Balanced100 (TDCS Remixes)">
  <label><input id="plPublic" type="checkbox"> Make Public</label>
  <button id="btnCreate" disabled>Create Playlist</button>
</div>

<div id="pins">
  <div><b>Pin Track IDs（固定）</b><div class="small">Remixのみ採用／“Mix”は全面除外。空欄は無視、重複は排除。</div></div>
  <input id="pinOpen"  value="0ueNjvhtXGDFkJQ5WBQ4mE" placeholder="先頭 (#1)">
  <span class="small">先頭 (#1)</span>

  <div></div>
  <input id="pinEarly" value="63dYSEftdSYwMAFBNfQYsA" placeholder="上旬（#8目安）">
  <span class="small">上旬 (目安 #8)</span>

  <div></div>
  <input id="pinMid"   value="3NQuIFfQPhTICaXGYe5dAt" placeholder="中盤（#45目安）">
  <span class="small">中盤 (目安 #45)</span>

  <div></div>
  <input id="pinLate"  value="7ltcrdlVsXyU5HU9VCAj6P" placeholder="後半（#75目安）">
  <span class="small">後半 (目安 #75)</span>
</div>

<div id="debug">
  <b>Token:</b> <span id="tokstate">–</span> |
  <button id="btnRefresh">Refresh token</button>
  <button id="btnReauth">Re-auth</button>
</div>

<ol id="tracks"></ol>
<pre id="log"></pre>

<script>
/*** 固定（あなたの環境） ***/
const CLIENT_ID    = "1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI = "https://npr2025.github.io/spotify-auth/callback.html";
const ARTIST_ID    = "55fvQ5I2IZUfcFT2DV02T3";
const ARTIST_NAME  = "The Darrow Chem Syndicate";
const USER_ID      = "22fqn5mozguuegi2t3l2zeugy";
const DESIRED_SCOPES = ["playlist-modify-private","playlist-modify-public"];
const EXACT_LIMIT_130 = 130;
const EXACT_LIMIT_120 = 120;
const EXACT_LIMIT_100 = 100;

/*** 便利 ***/
const $=s=>document.querySelector(s);
const log=m=>{const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; console.log(m);}
const setStatus=t=>{ $("#status").textContent=t; log(t); }
async function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

/*** Remix-only / “Mix”除外 ***/
function isRemixOnly(name){
  const s = (name||"").toLowerCase();
  const hasRemix = /\bremix\b/.test(s);
  const hasMix   = /\bmix\b/.test(s); // club mix / extended mix / continuous mix … を弾く
  return hasRemix && !hasMix;
}

/*** リミキサー名の抽出（AAA & BBB Remix / AAA x BBB Remix / AAA, BBB Remix など対応） ***/
function remixersOf(title){
  const s=(title||"").toLowerCase();
  const m=s.match(/(.+?)\s*-\s*(.+?)\s*remix/); // “Track — XXX Remix”
  const raw = m ? m[2] : (s.split("remix")[0]||"");
  return raw
    .replace(/[()［\]【】]/g," ")
    .split(/\s*(?:&|,| x | vs | feat\.?| featuring )\s*/i)
    .map(t=>t.trim())
    .filter(Boolean);
}
function shareRemixer(a,b){
  const A=new Set(remixersOf(a)); const B=new Set(remixersOf(b));
  for(const x of A){ if(B.has(x)) return true; }
  return false;
}

/*** トークン管理 ***/
function saveToken(t){
  const expAt = Date.now() + (t.expires_in||3600)*1000;
  sessionStorage.setItem("sp_access_token", t.access_token);
  if(t.refresh_token) sessionStorage.setItem("sp_refresh_token", t.refresh_token);
  sessionStorage.setItem("sp_exp_at", String(expAt));
  sessionStorage.setItem("sp_scope", t.scope||"");
  updateTokenDebug();
}
function clearToken(){
  ["sp_access_token","sp_refresh_token","sp_exp_at","sp_scope","pkce_state","pkce_verifier"].forEach(k=>sessionStorage.removeItem(k));
  updateTokenDebug();
}
function scopeOk(required){
  const s=(sessionStorage.getItem("sp_scope")||"").split(" ");
  return required.every(x=>s.includes(x));
}
function updateTokenDebug(){
  const exp=+sessionStorage.getItem("sp_exp_at")||0;
  const left = exp? Math.max(0, Math.floor((exp-Date.now())/1000)) : 0;
  const rt = !!sessionStorage.getItem("sp_refresh_token");
  const sc = sessionStorage.getItem("sp_scope")||"";
  $("#tokstate").textContent = (sessionStorage.getItem("sp_access_token")?"OK":"NONE")+
    ` / exp in ${left}s / refresh:${rt?"yes":"no"} / scope:[${sc}]`;
}
async function tokenByCode(code,verifier){
  const body=new URLSearchParams({client_id:CLIENT_ID,grant_type:"authorization_code",code,redirect_uri:REDIRECT_URI,code_verifier:verifier});
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok) throw new Error(`Token exchange ${r.status}`);
  return r.json();
}
async function refreshTokenNow(){
  const rt=sessionStorage.getItem("sp_refresh_token");
  if(!rt) throw new Error("No refresh_token");
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:rt})});
  if(!r.ok){ clearToken(); throw new Error(`Refresh ${r.status}`); }
  const t=await r.json(); saveToken(t); log("Token refreshed.");
}
async function ensureToken(requiredScopes=DESIRED_SCOPES){
  updateTokenDebug();
  if(!scopeOk(requiredScopes)) { log("Scope insufficient → re-auth"); reauth(); await new Promise(()=>{}); }
  const tok=sessionStorage.getItem("sp_access_token");
  const exp=+sessionStorage.getItem("sp_exp_at")||0;
  if(tok && Date.now()<exp-120000) return tok;
  const rt=sessionStorage.getItem("sp_refresh_token");
  if(rt){ await refreshTokenNow(); return sessionStorage.getItem("sp_access_token"); }
  reauth(); await new Promise(()=>{});
}
function reauth(){ location.href="auth.html"; }

/*** API（自動クールダウン） ***/
let GAP_MS = 1000;
async function spGet(path,params={}){
  const u=new URL("https://api.spotify.com/v1/"+path);
  Object.entries(params).forEach(([k,v])=>{ if(v!=null&&v!=="") u.searchParams.set(k,v);});
  await sleep(GAP_MS);
  const r=await fetch(u,{headers:{Authorization:"Bearer "+await ensureToken()}});
  if(r.status===401){ log("401 → refresh and retry"); await refreshTokenNow(); return spGet(path,params); }
  if(r.status===429){
    const ra=+r.headers.get("retry-after")||2;
    GAP_MS=Math.min(Math.floor(GAP_MS*1.6)+300,6000);
    log(`429 ⇒ wait ${ra}s, cooldown≈${GAP_MS}ms`);
    await sleep(ra*1000);
    return spGet(path,params);
  }
  if(!r.ok) throw new Error(`${path} ${r.status}`);
  return r.json();
}
async function spPost(path,body,scopeNeed=["playlist-modify-private"]){
  await ensureToken(scopeNeed);
  await sleep(GAP_MS);
  const r=await fetch("https://api.spotify.com/v1/"+path,{method:"POST",headers:{Authorization:"Bearer "+sessionStorage.getItem("sp_access_token"),"Content-Type":"application/json"},body:JSON.stringify(body)});
  if(r.status===401){ log("POST 401 → refresh and retry"); await refreshTokenNow(); return spPost(path,body,scopeNeed); }
  if(r.status===429){
    const ra=+r.headers.get("retry-after")||2;
    GAP_MS=Math.min(Math.floor(GAP_MS*1.6)+300,6000);
    log(`POST 429 ⇒ wait ${ra}s, cooldown≈${GAP_MS}ms`);
    await sleep(ra*1000);
    return spPost(path,body,scopeNeed);
  }
  if(!r.ok) throw new Error(`POST ${path} ${r.status} ${await r.text()}`);
  return r.json();
}

/*** World Albums → Tracks → Details ***/
function uniqById(arr){ const m=new Map(); for(const x of arr){ if(x?.id&&!m.has(x.id)) m.set(x.id,x); } return [...m.values()]; }

async function collectAlbumIds(){
  const ids=new Set();
  for(const g of ['album','single','compilation','appears_on']){
    let offset=0;
    while(true){
      const d=await spGet(`artists/${ARTIST_ID}/albums`,{include_groups:g,limit:50,offset});
      const items=d?.items||[];
      for(const a of items){ if(a?.id) ids.add(a.id); }
      if(items.length<50 || ids.size>500) break;
      offset+=50;
    }
  }
  return [...ids];
}

async function collectRemixTrackIdsFromAlbums(albumIds){
  const kept=[];
  for(const id of albumIds){
    const d=await spGet(`albums/${id}/tracks`,{limit:50}); // market付けない＝全リージョンで拾う
    for(const t of (d?.items||[])){
      if(!t?.id) continue;
      if(!isRemixOnly(t.name)) continue;
      kept.push(t.id);
    }
    if(kept.length>=500) break; // 安全キャップ
  }
  return [...new Set(kept)];
}

async function fetchTracksDetail(ids, market){
  const out=[];
  for(let i=0;i<ids.length;i+=50){
    const chunk=ids.slice(i,i+50);
    const d=await spGet("tracks",{ids:chunk.join(","),market});
    for(const t of (d?.tracks||[])){
      if(!t||!t.id) continue;
      if(!t.artists?.some(a=>a.id===ARTIST_ID)) continue;  // TDCS作品だけ
      if(!isRemixOnly(t.name)) continue;
      out.push({
        id:t.id, name:t.name,
        artists:(t.artists||[]).map(a=>a.name).join(", "),
        popularity:t.popularity||0,
        track_url:t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`,
        album:t.album?.name||"",
        album_url:t.album?.external_urls?.spotify||""
      });
    }
  }
  return uniqById(out);
}

/*** リスト整形・選曲 ***/
let base130=[], pool120=[], final100=[];

function render(list){
  const ol=$("#tracks"); ol.innerHTML="";
  list.forEach((r,i)=>{
    const li=document.createElement("li");
    const a=document.createElement("a"); a.href=r.track_url; a.textContent=r.name; a.target="_blank"; a.rel="noopener";
    li.append(`${i+1}. `, a, ` — ${r.artists} (pop:${r.popularity})`);
    ol.appendChild(li);
  });
  const on=list.length>0;
  $("#btnTrim120").disabled=!on;
  $("#btn100").disabled=!on;
  $("#btnHead5").disabled=!on;
  $("#btnCreate").disabled=!on;
}

function capPerAlbum(list,maxPer=2){
  const cnt={}; const out=[];
  for(const r of list){
    const k=r.album+"::"+r.artists;
    cnt[k]=(cnt[k]||0)+1;
    if(cnt[k]<=maxPer) out.push(r);
  }
  return out;
}

function pickBalanced100(rows){
  rows.forEach(r=>{ r._score=(r.popularity||0)/100; });
  const sorted=[...rows].sort((a,b)=>b._score-a._score);
  return sorted.slice(0,EXACT_LIMIT_100);
}

/*** Pins（位置：#1/#8/#45/#75） ***/
function getPinIds(){
  return {
    open: ($("#pinOpen").value||"").trim(),
    early:($("#pinEarly").value||"").trim(),
    mid:  ($("#pinMid").value||"").trim(),
    late: ($("#pinLate").value||"").trim()
  };
}
function dropDupAndKeepLen(list, keepSet, targetLen){
  const out=[]; const seen=new Set();
  for(const r of list){ if(seen.has(r.id)) continue; seen.add(r.id); out.push(r); }
  while(out.length>targetLen){
    // 非Pinの末尾から間引き
    let idx=-1;
    for(let i=out.length-1;i>=0;i--){ if(!keepSet.has(out[i].id)){ idx=i; break; } }
    if(idx<0) break;
    out.splice(idx,1);
  }
  return out;
}
async function ensurePinsPresent(list, market){
  const pins=getPinIds();
  const want=[pins.open,pins.early,pins.mid,pins.late].filter(Boolean);
  const have=new Set(list.map(x=>x.id));
  const missing=want.filter(id=>!have.has(id));
  if(missing.length){
    const extra=await fetchTracksDetail(missing, market);
    list = uniqById(extra.concat(list));
  }
  return list;
}
function placePins(list){
  const pins=getPinIds();
  const plan=[
    {id:pins.open,pos:0},
    {id:pins.early,pos:7},
    {id:pins.mid,pos:44},
    {id:pins.late,pos:74}
  ].filter(p=>p.id);
  const pinSet=new Set(plan.map(p=>p.id));
  list=list.filter(x=>!pinSet.has(x.id)); // いったん外す
  const byId=new Map(final100.concat(pool120,base130).map(x=>[x.id,x]));
  for(const p of plan){
    const row=byId.get(p.id); if(!row) continue;
    const pos=Math.min(Math.max(p.pos,0), list.length);
    list.splice(pos,0,row);
  }
  return {list, pinSet};
}

/*** 連続同リミキサー回避（共著も検知） ***/
function deAdjSameRemixer(list){
  for(let i=1;i<list.length;i++){
    if(shareRemixer(list[i-1].name, list[i].name)){
      // 直後と入替候補を少し先から探す
      let j=i+1;
      while(j<list.length && shareRemixer(list[i-1].name, list[j].name)) j++;
      if(j<list.length){
        const tmp=list[i]; list[i]=list[j]; list[j]=tmp;
      }
    }
  }
  return list;
}

/*** ボタン動作 ***/
$("#btn130").onclick=async ()=>{
  $("#btn130").disabled=true;
  try{
    const mk=$("#market").value||"US";
    setStatus("① World albums scan → remix tracks → details…");
    const albums = await collectAlbumIds();
    log(`albums: ${albums.length}`);
    const ids = await collectRemixTrackIdsFromAlbums(albums);
    log(`remix track ids: ${ids.length}`);
    let tracks = await fetchTracksDetail(ids, mk);
    tracks = uniqById(tracks).sort((a,b)=>(b.popularity||0)-(a.popularity||0));
    if(tracks.length===0) throw new Error("No REMIX tracks found.");
    base130 = tracks.slice(0, Math.min(EXACT_LIMIT_130, tracks.length));
    base130 = await ensurePinsPresent(base130, mk);
    base130 = uniqById(base130).slice(0,EXACT_LIMIT_130);
    render(base130);
    setStatus(`Loaded base ${base130.length} (Remix-only, World albums scan)`);
  }catch(e){ setStatus("Build error: "+(e.message||e)); }
  $("#btn130").disabled=false;
};

$("#btnTrim120").onclick=()=>{
  if(!base130.length) return;
  // 同アルバム2曲まで → 120曲へ
  pool120 = capPerAlbum([...base130], 2).slice(0,EXACT_LIMIT_120);
  render(pool120);
  setStatus(`Trimmed to ${pool120.length} (cap album ≤2)`);
};

$("#btn100").onclick=async ()=>{
  const mk=$("#market").value||"US";
  if(!pool120.length) pool120=[...base130];
  let list = pickBalanced100(pool120);
  // ピンを必ず入れて所定位置へ
  list = await ensurePinsPresent(list, mk);
  const placed = placePins(list);
  list = dropDupAndKeepLen(placed.list, placed.pinSet, EXACT_LIMIT_100);
  list = deAdjSameRemixer(list);
  final100 = list;
  render(final100);
  setStatus(`Balanced 100 ready (pins placed #1/#8/#45/#75, no adjacent shared remixers)`);
};

$("#btnHead5").onclick=()=>{
  if(!final100.length) return;
  // 非ピン上位5だけ微調整（人気順）
  const pins=getPinIds(); const pinSet=new Set(Object.values(pins).filter(Boolean));
  const idxs=final100.map((x,i)=>({x,i})).filter(v=>!pinSet.has(v.x.id)).map(v=>v.i).slice(0,5);
  const pool=idxs.map(i=>final100[i]).sort((a,b)=>(b.popularity||0)-(a.popularity||0));
  idxs.forEach((i,k)=>{ final100[i]=pool[k]; });
  final100 = deAdjSameRemixer(final100);
  render(final100);
  setStatus("Head-5 optimized");
};

$("#btnCreate").onclick=async ()=>{
  try{
    if(!final100.length) return;
    const isPublic=$("#plPublic").checked;
    const scopeNeed=[isPublic?"playlist-modify-public":"playlist-modify-private"];
    const me=await spGet("me");
    if(me?.id && me.id!==USER_ID) throw new Error(`Signed in as ${me.id}. Please sign in as ${USER_ID}.`);
    const pl=await spPost(`users/${USER_ID}/playlists`,{
      name:$("#plName").value||"PROGAPANDA • Balanced100 (TDCS Remixes)",
      description:"TDCS Remix-only (no Mix). World albums scan. Pins at #1/#8/#45/#75. No adjacent shared remixers.",
      public:!!isPublic
    }, scopeNeed);
    const uris=[...new Set(final100.map(x=>"spotify:track:"+x.id))];
    for(let i=0;i<uris.length;i+=100){
      await spPost(`playlists/${pl.id}/tracks`,{uris:uris.slice(i,i+100)}, scopeNeed);
      await sleep(300);
    }
    const url=pl.external_urls?.spotify || `https://open.spotify.com/playlist/${pl.id}`;
    setStatus(`Done — ${final100.length} tracks added (${isPublic?"public":"private"}). ${url}`);
  }catch(e){ setStatus("Playlist error: "+(e.message||e)); }
};

/*** Token ops ***/
$("#btnRefresh").onclick=()=>refreshTokenNow().catch(e=>setStatus("Refresh error: "+e.message));
$("#btnReauth").onclick=()=>{ clearToken(); location.href="auth.html"; };

/*** 起動（PKCEコールバック） ***/
(async function boot(){
  try{
    const qp=new URLSearchParams(location.search);
    const code=qp.get("code"), state=qp.get("state");
    if(code){
      const saved=sessionStorage.getItem("pkce_state");
      const verifier=sessionStorage.getItem("pkce_verifier");
      if(saved && verifier && state===saved){
        const tok=await tokenByCode(code,verifier);
        saveToken(tok);
        sessionStorage.removeItem("pkce_state");
        sessionStorage.removeItem("pkce_verifier");
        history.replaceState({},document.title,location.pathname);
      }
    }
    await ensureToken();
    setStatus("Signed in. ①Build 130（World/Albums→Remix-only）→ ②Trim 120 → ③Pick Balanced 100（Pins #1/#8/#45/#75・連続リミキサー回避）→ ④Create（非公開デフォルト）");
  }catch(e){ setStatus("Boot error: "+(e.message||e)); }
})();
</script>
</body>
</html>
