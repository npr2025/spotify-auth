<!doctype html>
<meta charset="utf-8">
<title>Spotify — TDCS ONLY / EXACT 130 (Private Playlist)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<body style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:980px;margin:40px auto">
  <h1>Spotify Authentication</h1>
  <p id="status">Signed in. Build TDCS-only (exact 130) → Create Private Playlist.</p>

  <section id="app" style="display:block">
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin:12px 0">
      <label>Groups:
        <select id="groups">
          <!-- 他人混入を避けるため appears_on は既定で外す -->
          <option value="album,single,compilation" selected>Albums + Singles + Compilations</option>
          <option value="album,single">Albums + Singles</option>
        </select>
      </label>
      <label><input type="checkbox" id="allMarkets" checked> All markets (no region filter)</label>
      <label>Market (only when All markets is OFF):
        <select id="market">
          <option value="US" selected>US</option><option value="JP">JP</option>
          <option value="GB">GB</option><option value="DE">DE</option>
        </select>
      </label>
      <label><input type="checkbox" id="wantFeatures"> Fetch audio-features (optional)</label>

      <button id="btnFetch">Build TDCS-only (exact 130)</button>
      <button id="btnDLhtml">Download HTML</button>
      <button id="btnDLjson">Download JSON</button>
      <button id="btnDLcsv">Download CSV</button>
    </div>

    <!-- ★ プレイリスト作成（既定=非公開） -->
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin:10px 0;padding:10px;border:1px solid #ddd;border-radius:8px">
      <input id="plName"  style="min-width:320px" value="PROGAPANDA • TOP130 (TDCS ONLY)">
      <label><input id="plPublic" type="checkbox"> Make Public</label>
      <button id="btnCreate">Create Playlist (Private by default)</button>
      <span id="plLink"></span>
    </div>

    <ol id="tracks"></ol>
  </section>

<script>
/* ====== Fixed config ====== */
const CLIENT_ID    = "1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI = "https://npr2025.github.io/spotify-auth/callback.html";
const ARTIST_ID    = "55fvQ5I2IZUfcFT2DV02T3";   // The Darrow Chem Syndicate
const USER_ID      = "22fqn5mozguuegi2t3l2zeugy"; // ← 固定（あなたのSpotifyユーザーID）
const EXACT_LIMIT  = 130;
/* ========================== */

const $=(s)=>document.querySelector(s);
const setStatus=(t)=>{$("#status").textContent=t; console.log(t);};

/* ---- small utils ---- */
const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
function chunk(a,n){const o=[];for(let i=0;i<a.length;i+=n)o.push(a.slice(i,i+n));return o;}
function escHtml(s){return (''+(s??'')).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}
function escCsv(s){return (''+(s??'')).replace(/"/g,'""');}

/* ---- PKCE token handling + scope guard ---- */
function clearPkce(){sessionStorage.removeItem("pkce_verifier");sessionStorage.removeItem("pkce_state");}
function saveToken(t){
  sessionStorage.setItem("sp_access_token",t.access_token);
  if(t.refresh_token) sessionStorage.setItem("sp_refresh_token",t.refresh_token);
  if(t.scope)         sessionStorage.setItem("sp_scope",t.scope);      // ★scopeを保存
  sessionStorage.setItem("sp_exp_at",String(Date.now()+(t.expires_in||3600)*1000));
}
function currentScopes(){return new Set((sessionStorage.getItem("sp_scope")||"").split(" ").filter(Boolean));}
function hasScope(s){return currentScopes().has(s);}
function forceReauth(){
  sessionStorage.removeItem("sp_access_token");
  sessionStorage.removeItem("sp_refresh_token");
  sessionStorage.removeItem("sp_exp_at");
  sessionStorage.removeItem("sp_scope");
  location.href = "auth.html"; // ルートが同じ想定
}

async function exchangeAuthCode(code,verifier){
  const body=new URLSearchParams({client_id:CLIENT_ID,grant_type:"authorization_code",code,redirect_uri:REDIRECT_URI,code_verifier:verifier});
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok) throw new Error("Token exchange failed: "+r.status);
  return r.json();
}
async function refreshAccessToken(refresh){
  const body=new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:refresh});
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok) throw new Error("Refresh failed: "+r.status);
  return r.json();
}

async function ensureToken(minScope="playlist-modify-private"){
  let access = sessionStorage.getItem("sp_access_token");
  let expAt  = Number(sessionStorage.getItem("sp_exp_at")||0);
  if(access && Date.now()<expAt-60000){
    if(!hasScope(minScope)) { forceReauth(); await new Promise(()=>{}); }
    return access;
  }
  const refresh = sessionStorage.getItem("sp_refresh_token");
  if(refresh){
    const t=await refreshAccessToken(refresh); saveToken(t);
    if(!hasScope(minScope)) { forceReauth(); await new Promise(()=>{}); }
    return t.access_token;
  }
  forceReauth(); await new Promise(()=>{});
}

/* ---- Spotify helpers（指数バックオフ） ---- */
async function spGet(path, params={}, retry=8, base=600){
  let attempt=0;
  while(true){
    const token=await ensureToken(); // デフォは private scope で検証
    const url=new URL("https://api.spotify.com/v1/"+path);
    Object.entries(params).forEach(([k,v])=>{ if(v!==undefined&&v!==null&&v!=="") url.searchParams.set(k,v); });
    const r=await fetch(url,{headers:{Authorization:"Bearer "+token}});
    if(r.ok) return r.json();
    if(r.status===401 && retry>0){ sessionStorage.removeItem("sp_access_token"); retry--; continue; }
    if((r.status===429||r.status>=500) && retry>0){
      const ra=Number(r.headers.get("retry-after"))||0;
      const backoff = ra? ra*1000 : base * Math.pow(2, attempt++);
      setStatus(`API ${path} ${r.status} — retry in ${Math.ceil(backoff/1000)}s`);
      await sleep(backoff); retry--; continue;
    }
    const txt=await r.text(); throw new Error(`API ${path} ${r.status} ${txt.slice(0,160)}`);
  }
}
async function spReq(method,path,body=null,params={},retry=8,base=600, minScope="playlist-modify-private"){
  let attempt=0;
  while(true){
    const token=await ensureToken(minScope);
    const url=new URL("https://api.spotify.com/v1/"+path);
    Object.entries(params).forEach(([k,v])=>{ if(v!==undefined&&v!==null&&v!=="") url.searchParams.set(k,v); });
    const r=await fetch(url,{method,headers:{Authorization:"Bearer "+token,"Content-Type":"application/json"},body:body?JSON.stringify(body):null});
    if(r.ok) return r.json();
    if((r.status===429||r.status>=500) && retry>0){
      const ra=Number(r.headers.get("retry-after"))||0;
      const backoff = ra? ra*1000 : base * Math.pow(2, attempt++);
      setStatus(`API ${method} ${path} ${r.status} — retry in ${Math.ceil(backoff/1000)}s`);
      await sleep(backoff); retry--; continue;
    }
    const txt=await r.text(); throw new Error(`API ${method} ${path} ${r.status} ${txt.slice(0,160)}`);
  }
}
const spPost=(path,body,params,minScope)=>spReq("POST",path,body,params,8,600,minScope);

/* ---- Collectors（TDCS限定） ---- */
async function fetchAllAlbums(artistId, include_groups, allMarkets, market){
  let items=[],offset=0;
  while(true){
    const params={include_groups,limit:50,offset}; if(!allMarkets) params.market=market;
    const page=await spGet(`artists/${artistId}/albums`,params);
    items.push(...(page.items||[])); if(!page.next) break; offset+=50;
  }
  const seen=new Set(), albums=[];
  for(const a of items){ if(!seen.has(a.id)){ seen.add(a.id); albums.push(a); } }
  return albums;
}
async function fetchAlbumTracks_TDCS(album, allMarkets, market, artistId){
  const albumHasTDCS = (album.artists||[]).some(a=>a?.id===artistId);
  if(!albumHasTDCS) return [];
  let keep=[], offset=0;
  while(true){
    const params={limit:50,offset}; if(!allMarkets) params.market=market;
    const page=await spGet(`albums/${album.id}/tracks`,params);
    const ok=(page.items||[]).filter(t=> Array.isArray(t.artists) && t.artists.some(a=>a?.id===artistId) );
    keep.push(...ok.map(t=>t.id));
    if(!page.next) break; offset+=50;
  }
  return keep;
}

/* ---- Audio features（任意） ---- */
async function fetchAudioFeaturesSafe(trackIds){
  if(!$("#wantFeatures").checked) return {};
  const out={}; for(const batch of chunk(trackIds.filter(Boolean),50)){
    try{
      const data=await spGet("audio-features",{ids:batch.join(",")});
      (data.audio_features||[]).forEach(f=>{if(f&&f.id) out[f.id]=f;});
    }catch(_){
      for(const id of batch){ try{ const f=await spGet(`audio-features/${id}`,{}); if(f&&f.id) out[f.id]=f; } catch{ out[id]=null; } }
    }
    await sleep(900);
  } return out;
}

/* ---- Builder ---- */
let running=false, lastData=[];
function toCSV(rows){
  if(!rows.length) return "";
  const head=Object.keys(rows[0]); const lines=[head.join(",")];
  for(const r of rows) lines.push(head.map(k=>`"${escCsv(r[k])}"`).join(","));
  return lines.join("\n");
}
function download(name,text,mime){const b=new Blob([text],{type:mime}); const a=document.createElement("a"); a.href=URL.createObjectURL(b); a.download=name; a.click(); URL.revokeObjectURL(a.href);}
function htmlList(rows,title="TDCS ONLY — 130"){
  const items=rows.map((r,i)=>{
    const t=`<a href="${r.track_url}" target="_blank" rel="noopener">${escHtml(r.name)}</a>`;
    const al=r.album_url?` • <a href="${r.album_url}" target="_blank" rel="noopener">${escHtml(r.album)}</a>`:"";
    const as=r.artist_urls? r.artist_urls.split(" | ").map((u,j)=>`<a href="${u}" target="_blank" rel="noopener">${escHtml(r.artists.split(", ")[j]||"Artist")}</a>`).join(", ")
                          : escHtml(r.artists);
    return `<li>${i+1}. ${t} — ${as}${al} <small>(pop:${r.popularity}${r.tempo?`, tempo:${r.tempo}`:""})</small></li>`;
  }).join("\n");
  return `<!doctype html><meta charset="utf-8"><title>${escHtml(title)}</title><body style="font-family:system-ui,-apple-system;max-width:900px;margin:40px auto"><h1>${escHtml(title)}</h1><ol>${items}</ol></body>`;
}

async function runTDCSOnly(){
  if(running) return; running=true;
  try{
    setStatus("Building TDCS-only (exact 130) …");
    const groups=$("#groups").value||"album,single,compilation";
    const allMarkets=$("#allMarkets").checked; const market=$("#market").value||"US";

    // 1) TDCS名義アルバム群
    const albums=await fetchAllAlbums(ARTIST_ID,groups,allMarkets,market);
    setStatus(`Collecting from ${albums.length} TDCS albums…`);

    // 2) 各アルバムから TDCS 含む曲のみ抽出
    let trackIds=[];
    for(const batch of chunk(albums,8)){
      const packs = await Promise.all(batch.map(a=>fetchAlbumTracks_TDCS(a,allMarkets,market,ARTIST_ID).catch(()=>[])));
      packs.forEach(ids=>trackIds.push(...ids));
      await sleep(120);
    }
    trackIds=[...new Set(trackIds)];

    // 3) 詳細取得 → 最終ガード（曲にもTDCSがいるものだけ）
    setStatus(`Fetching track details (${trackIds.length})…`);
    let tracks=[]; for(const ids of chunk(trackIds,50)){ const d=await spGet("tracks",{ids:ids.join(",")}); tracks.push(...(d.tracks||[])); await sleep(80); }
    tracks = tracks.filter(t=> t && t.artists?.some(a=>a?.id===ARTIST_ID));

    // 4) 人気降順 → ちょうど130に固定
    tracks = tracks.sort((a,b)=>(b.popularity||0)-(a.popularity||0));
    if (tracks.length >= EXACT_LIMIT) tracks = tracks.slice(0, EXACT_LIMIT);
    else setStatus(`Only ${tracks.length} tracks found for TDCS-only. (不足: ${EXACT_LIMIT - tracks.length})`);

    // 5) features（任意）
    let featById={}; try{ featById=await fetchAudioFeaturesSafe(tracks.map(t=>t.id)); } catch(e){ setStatus("features skipped: "+(e.message||e)); }

    // 6) 整形（リンク付き）
    lastData=tracks.map(t=>{
      const f=featById[t.id]||{};
      const artistNames=t.artists.map(a=>a.name).join(", ");
      const artistUrls=t.artists.map(a=>a.external_urls?.spotify||"").filter(Boolean).join(" | ");
      const trackUrl=t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`;
      const albumUrl=t.album?.external_urls?.spotify || "";
      const avail=Array.isArray(t.available_markets)?t.available_markets.length:
        (t.album&&Array.isArray(t.album.available_markets)?t.album.available_markets.length:"");
      return {id:t.id,name:t.name,artists:artistNames,artist_urls:artistUrls,popularity:t.popularity,isrc:t.external_ids?.isrc||"",
        preview_url:t.preview_url||"",track_url:trackUrl,album:t.album?.name||"",album_url:albumUrl,release_date:t.album?.release_date||"",
        available_markets_count:avail,duration_ms:t.duration_ms,tempo:f.tempo??"",energy:f.energy??"",danceability:f.danceability??"",
        valence:f.valence??"",loudness:f.loudness??""};
    });

    // 7) 表示
    const ol=$("#tracks"); ol.innerHTML="";
    lastData.forEach((r,i)=>{
      const li=document.createElement("li");
      const a=document.createElement("a"); a.href=r.track_url; a.textContent=r.name; a.target="_blank"; a.rel="noopener";
      li.append(`${i+1}. `, a, ` — ${r.artists} (pop:${r.popularity}${r.tempo?`, tempo:${r.tempo}`:""})`);
      ol.appendChild(li);
    });
    setStatus(`Loaded ${lastData.length} tracks — TDCS ONLY (EXACT ${EXACT_LIMIT})`);
  }catch(e){ setStatus(e.message||String(e)); }
  finally{ running=false; }
}

/* ---- Downloads（=130曲） ---- */
document.getElementById("btnDLhtml").onclick=()=>lastData.length&&download("tdcs_only_130.html",htmlList(lastData),"text/html");
document.getElementById("btnDLjson").onclick=()=>lastData.length&&download("tdcs_only_130.json",JSON.stringify(lastData,null,2),"application/json");
document.getElementById("btnDLcsv").onclick =()=>lastData.length&&download("tdcs_only_130.csv",toCSV(lastData),"text/csv");

/* ---- Playlist（ユーザーID固定／既定=非公開） ---- */
async function createPlaylistForFixedUser(name,desc,isPublic){
  const minScope = isPublic ? "playlist-modify-public" : "playlist-modify-private";
  // 公開作成を選んだのに public スコープが無い場合は再認可
  if (isPublic && !hasScope("playlist-modify-public")) {
    setStatus("Need 'playlist-modify-public' scope. Re-authorizing…");
    forceReauth(); await new Promise(()=>{});
  }
  // サインインしているアカウントが固定IDと一致するか確認（安全策）
  try{
    const me = await spGet("me",{});
    if (me?.id && me.id !== USER_ID) {
      throw new Error(`Signed in as ${me.id}. Please sign in as ${USER_ID}.`);
    }
  }catch(e){ setStatus(e.message||String(e)); throw e; }

  return spPost(`users/${USER_ID}/playlists`,
    {name,description:desc,public:!!isPublic}, {}, minScope);
}
async function addTracksToPlaylist(playlistId,trackIds){
  const uris=[...new Set(trackIds)].filter(Boolean).map(id=>`spotify:track:${id}`);
  for(const batch of chunk(uris,100)){
    await spPost(`playlists/${playlistId}/tracks`,{uris:batch},{});
    await sleep(250);
  }
}
document.getElementById("btnCreate").onclick=async()=>{
  try{
    if(!lastData.length){ setStatus("先に Build TDCS-only を実行して曲を用意してね"); return; }
    const name=$("#plName").value||"PROGAPANDA • TOP130 (TDCS ONLY)";
    const isPublic=$("#plPublic").checked; // 既定OFF = 非公開
    setStatus(`Creating ${isPublic?"public":"private"} playlist for ${USER_ID}…`);
    const pl=await createPlaylistForFixedUser(name,"Auto-built (TDCS ONLY, exact 130).",isPublic);
    setStatus("Adding tracks…");
    await addTracksToPlaylist(pl.id,lastData.map(x=>x.id));
    const url = pl.external_urls?.spotify || `https://open.spotify.com/playlist/${pl.id}`;
    $("#plLink").innerHTML=`<a href="${url}" target="_blank" rel="noopener">Open playlist</a>`;
    setStatus(`Done — ${lastData.length} tracks added (${isPublic?"public":"private"}).`);
  }catch(e){
    setStatus("Playlist error: "+(e.message||e));
  }
};

/* ---- Boot: PKCE callback ---- */
(async function init(){
  const qp=new URLSearchParams(location.search);
  const code=qp.get("code"); const state=qp.get("state");
  if(code){
    const saved=sessionStorage.getItem("pkce_state");
    const verifier=sessionStorage.getItem("pkce_verifier");
    if(!verifier||!saved||state!==saved){ setStatus("State/Verifier mismatch. Start from auth.html"); return; }
    try{
      const tok=await exchangeAuthCode(code,verifier);
      clearPkce();
      history.replaceState({},document.title,location.pathname);
      saveToken(tok);
    }catch(e){ setStatus(e.message); return; }
  }
  document.getElementById("btnFetch").onclick=()=>runTDCSOnly();
})();
</script>
</body>
</html>
