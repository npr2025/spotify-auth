(function(){
  if (!window.lastData || !lastData.length) { alert('先に曲リストを出してから実行してね'); return; }

  // ===== 手動でピン留めしたい曲があれば入れてね（省略可） =====
  const PIN = {
    // 1: 'spotify:track:id_or_plain_id', // 1曲目に固定
    // 3: 'spotify:track:id_or_plain_id', // 3曲目（アンセム）に固定
  };

  // ---------- 小ツール ----------
  const cleanId = x => (x||'').replace('spotify:track:','');
  Object.keys(PIN).forEach(k => PIN[k] = cleanId(PIN[k]));

  const safe = (v, d)=> (v===undefined||v===null||Number.isNaN(v)) ? d : v;
  const ALT_RE = /(remix|radio|extended|vip|edit|rework|version)/i;
  const byId = Object.fromEntries(lastData.map(t=>[t.id,t]));
  const sameAlbum = (a,b)=> (a&&b && (a.album||'')===(b.album||''));
  const used = new Set();
  const pick = (r)=>{ if(!r) return null; used.add(r.id); return r; };

  // 特徴の整形
  const rows = lastData.map(t=>{
    const energy = safe(t.energy, .6);
    const dance  = safe(t.danceability, .6);
    const val    = safe(t.valence, .45);
    const tempo  = safe(t.tempo, 124);
    const pop    = safe(t.popularity, 0);
    const isAlt  = ALT_RE.test(t.name||'');
    const year   = (t.release_date||'').slice(0,4);
    return { id:t.id, t, energy, dance, val, tempo, pop, isAlt, album:(t.album||''), year };
  });

  // 総合スコア（人気主軸＋低valence・高energy微加点）
  const score = r => 0.5*(r.pop/100) + 0.18*r.energy + 0.12*r.dance + 0.12*(1-r.val) + 0.08*((r.tempo-110)/(140-110));

  // 基本プール（別Verは軽く控えめ）
  const pool0 = [...rows].sort((a,b)=> score(b)-score(a) || (b.pop-a.pop));

  // 1) Opener：118–126 BPM / 0.55–0.70 energy / val 0.35–0.60 / 非Alt優先
  function pickOpener(pool){
    const cand = pool.filter(r=>{
      return r.tempo>=118 && r.tempo<=126 && r.energy>=0.55 && r.energy<=0.70 && r.val>=0.35 && r.val<=0.60 && !r.isAlt;
    }).sort((a,b)=> (b.pop-a.pop) || (score(b)-score(a)));
    return cand[0] || pool[0];
  }

  // 2) Accelerator：openerより +5〜+12 BPM または +0.1 energy、同一アルバム連投は避ける
  function pickAccelerator(pool, op){
    const cand = pool.filter(r=>{
      const bpmUp = (r.tempo >= op.tempo+5 && r.tempo <= op.tempo+12);
      const enUp  = (r.energy >= op.energy+0.10);
      return (bpmUp || enUp) && !(sameAlbum(r,op) && !r.isAlt);
    }).sort((a,b)=> (score(b)-score(a)) || (b.pop-a.pop));
    return cand[0] || pool.find(r=>!sameAlbum(r,op)) || pool[0];
  }

  // 3) Anthem：人気トップ級・非Alt優先・サビ早め想定（BPM 120–132 推奨）
  function pickAnthem(pool){
    const cand = pool.filter(r=>!r.isAlt && r.tempo>=120 && r.tempo<=132)
                     .sort((a,b)=> (b.pop-a.pop) || (score(b)-score(a)));
    return cand[0] || pool.sort((a,b)=> (b.pop-a.pop) || (score(b)-score(a)))[0];
  }

  // 4) Contrast：落とす（energy -0.1〜、または tempo -6〜-15）or 質感反転、短めが理想
  function pickContrast(pool, base){
    const cand = pool.filter(r=>{
      const dropE = r.energy <= base.energy - 0.10;
      const dropT = r.tempo  <= base.tempo  - 6;
      return (dropE || dropT);
    }).sort((a,b)=> (score(b)-score(a)) || (a.isAlt - b.isAlt));
    return cand[0] || pool[0];
  }

  // 5) Payoff：章内ピーク（126–134 BPM / 高エナジー / Anthemと同アルバム連投は避ける）
  function pickPayoff(pool, avoid){
    const cand = pool.filter(r=> r.tempo>=126 && r.tempo<=134 && r.energy>=0.70 && !(avoid && sameAlbum(r,avoid)))
                     .sort((a,b)=> (score(b)-score(a)) || (b.pop-a.pop));
    return cand[0] || pool[0];
  }

  // ====== PIN対応で1〜5を確定 ======
  const getById = id => rows.find(r=>r.id===id);

  // 1
  let opener = PIN[1]? getById(PIN[1]) : pickOpener(pool0.filter(r=>!used.has(r.id)));
  opener = pick(opener);

  // 2
  let accel = PIN[2]? getById(PIN[2]) : pickAccelerator(pool0.filter(r=>!used.has(r.id)), opener);
  accel = pick(accel);

  // 3
  let anthem = PIN[3]? getById(PIN[3]) : pickAnthem(pool0.filter(r=>!used.has(r.id)));
  anthem = pick(anthem);

  // 4
  let contrast = PIN[4]? getById(PIN[4]) : pickContrast(pool0.filter(r=>!used.has(r.id)), anthem);
  contrast = pick(contrast);

  // 5
  let payoff = PIN[5]? getById(PIN[5]) : pickPayoff(pool0.filter(r=>!used.has(r.id)), anthem);
  payoff = pick(payoff);

  const head5 = [opener, accel, anthem, contrast, payoff].filter(Boolean);
  const headIds = head5.map(r=>r.id);

  // ===== 残りは現在の順序を保って続ける（頭5除外） =====
  const rest = lastData.filter(t=> !headIds.includes(t.id));

  // 同アルバム3連続の簡易回避（頭〜序盤だけ軽くスワップ）
  function fixRuns(arr, window=20){
    const out = [...arr];
    const albumOf = x => (x.album||'') + '::' + (x.artists||'');
    for (let i=2; i<Math.min(out.length, window); i++){
      const a = albumOf(out[i]), b = albumOf(out[i-1]), c = albumOf(out[i-2]);
      if (a===b && b===c){
        // 先の方から別アルバムを見つけてスワップ
        const j = out.findIndex((x,idx)=> idx>i && albumOf(x)!==a);
        if (j>i) { const tmp=out[i]; out[i]=out[j]; out[j]=tmp; }
      }
    }
    return out;
  }

  const newList = head5.map(r=>r.t).concat( fixRuns(rest) );

  // DOM更新
  const ol = document.querySelector('#tracks');
  if (ol) {
    ol.innerHTML = newList.map((r,i)=>{
      const link = (r.external_urls && r.external_urls.spotify) ? r.external_urls.spotify : `https://open.spotify.com/track/${r.id}`;
      const tag  = (i<5) ? ['OPENER','ACCEL','ANTHEM','CONTRAST','PAYOFF'][i] : '';
      const mark = tag ? ` <strong>[${tag}]</strong>` : '';
      return `<li>${i+1}. <a href="${link}" target="_blank" rel="noopener">${r.name}</a> — ${r.artists}${mark} <small>(pop:${r.popularity}${r.tempo?`, tempo:${Math.round(r.tempo)}`:''})</small></li>`;
    }).join('');
  }

  // lastData を新順序で置き換え（このまま「Create Playlist」で反映可）
  lastData = newList;

  // 完了メッセージ
  const st = document.querySelector('#status');
  if (st) st.textContent = `Head-5 fixed: ${head5.map(h=>h.t.name).join(' / ')} — total ${lastData.length}`;
  else console.log('Head-5 fixed:', head5.map(h=>h.t.name));

})();
