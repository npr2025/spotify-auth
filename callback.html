<!doctype html>
<meta charset="utf-8">
<title>Spotify — ALL (Strict) & Private Playlist</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<body style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:980px;margin:40px auto">
  <h1>Spotify Authentication</h1>
  <p id="status">Signed in. Build ALL → Create Private Playlist.</p>

  <section id="app" style="display:block">
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin:12px 0">
      <label>Groups:
        <select id="groups">
          <option value="album,single,appears_on,compilation" selected>All</option>
          <option value="album,single">Albums + Singles</option>
          <option value="appears_on,compilation">Appears/Compilations</option>
        </select>
      </label>
      <label><input type="checkbox" id="strict" checked> Strict artist filter</label>
      <label><input type="checkbox" id="primaryOnly"> Primary only</label>
      <label><input type="checkbox" id="allMarkets" checked> All markets (no region filter)</label>
      <label>Market (only when All markets is OFF):
        <select id="market">
          <option value="US" selected>US</option><option value="JP">JP</option>
          <option value="GB">GB</option><option value="DE">DE</option>
        </select>
      </label>
      <label><input type="checkbox" id="useTopTracks" checked> Fallback: artist Top Tracks (multi markets)</label>
      <label><input type="checkbox" id="noLimit" checked> No limit (ALL)</label>
      <label><input type="checkbox" id="wantFeatures"> Fetch audio-features (optional)</label>
      <button id="btnFetch">Build ALL (strict) with Links</button>
      <button id="btnDLhtml">Download HTML</button>
      <button id="btnDLjson">Download JSON</button>
      <button id="btnDLcsv">Download CSV</button>
    </div>

    <!-- ★ プレイリスト作成（既定=非公開） -->
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin:10px 0;padding:10px;border:1px solid #ddd;border-radius:8px">
      <input id="plName"  style="min-width:320px" value="PROGAPANDA • ALL (TDCS)">
      <label><input id="plPublic" type="checkbox"> Make Public</label>
      <button id="btnCreate">Create Playlist (Private by default)</button>
      <span id="plLink"></span>
    </div>

    <ol id="tracks"></ol>
  </section>

<script>
/* ====== Config ====== */
const CLIENT_ID    = "1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI = "https://npr2025.github.io/spotify-auth/callback.html";
const ARTIST_ID    = "55fvQ5I2IZUfcFT2DV02T3"; // The Darrow Chem Syndicate
const TOP_MARKETS  = ["US","JP","GB","DE","BR","MX","CA","AU","FR","ES"]; // Top Tracks補完用
/* ==================== */

const $=(s)=>document.querySelector(s);
const setStatus=(t)=>{$("#status").textContent=t; console.log(t);};

/* ---- PKCE token handling ---- */
function clearPkce(){sessionStorage.removeItem("pkce_verifier");sessionStorage.removeItem("pkce_state");}
function saveToken(t){sessionStorage.setItem("sp_access_token",t.access_token);
  if(t.refresh_token)sessionStorage.setItem("sp_refresh_token",t.refresh_token);
  sessionStorage.setItem("sp_exp_at",String(Date.now()+(t.expires_in||3600)*1000));}
function getToken(){return{access:sessionStorage.getItem("sp_access_token"),refresh:sessionStorage.getItem("sp_refresh_token"),
  expAt:Number(sessionStorage.getItem("sp_exp_at")||0)};}
async function exchangeAuthCode(code,verifier){
  const body=new URLSearchParams({client_id:CLIENT_ID,grant_type:"authorization_code",code,redirect_uri:REDIRECT_URI,code_verifier:verifier});
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok) throw new Error("Token exchange failed: "+r.status); return r.json();}
async function refreshAccessToken(refresh){
  const body=new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:refresh});
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok) throw new Error("Refresh failed: "+r.status); return r.json();}
async function ensureToken(){
  let {access,refresh,expAt}=getToken();
  if(access && Date.now()<expAt-60000) return access;
  if(refresh){const t=await refreshAccessToken(refresh); saveToken(t); return t.access_token;}
  throw new Error("No valid token (open auth.html and sign in)");
}

/* ---- Utils ---- */
function chunk(a,n){const o=[];for(let i=0;i<a.length;i+=n)o.push(a.slice(i,i+n));return o;}
const esc=(s)=>(''+(s??'')).replace(/"/g,'""');
const delay=(ms)=>new Promise(r=>setTimeout(r,ms));

/* ---- Spotify helpers（強化：指数バックオフ） ---- */
async function spGet(path, params={}, retry=8, base=600){
  let attempt=0;
  while(true){
    const token=await ensureToken();
    const url=new URL("https://api.spotify.com/v1/"+path);
    Object.entries(params).forEach(([k,v])=>{if(v!==undefined&&v!==null&&v!=="")url.searchParams.set(k,v);});
    const r=await fetch(url,{headers:{Authorization:"Bearer "+token}});
    if(r.ok) return r.json();

    if(r.status===401 && retry>0){sessionStorage.removeItem("sp_access_token"); retry--; continue;}
    if((r.status===429||r.status>=500)&&retry>0){
      const ra=Number(r.headers.get("retry-after"))||0;
      const backoff = ra? ra*1000 : base * Math.pow(2, attempt++);
      setStatus(`API ${path} ${r.status} — retry in ${Math.ceil(backoff/1000)}s`);
      await delay(backoff); retry--; continue;
    }
    const txt=await r.text(); throw new Error(`API ${path} ${r.status} ${txt.slice(0,160)}`);
  }
}
async function spReq(method,path,body=null,params={},retry=8,base=600){
  let attempt=0;
  while(true){
    const token=await ensureToken();
    const url=new URL("https://api.spotify.com/v1/"+path);
    Object.entries(params).forEach(([k,v])=>{if(v!==undefined&&v!==null&&v!=="")url.searchParams.set(k,v);});
    const r=await fetch(url,{method,headers:{Authorization:"Bearer "+token,"Content-Type":"application/json"},body:body?JSON.stringify(body):null});
    if(r.ok) return r.json();
    if((r.status===429||r.status>=500)&&retry>0){
      const ra=Number(r.headers.get("retry-after"))||0;
      const backoff = ra? ra*1000 : base * Math.pow(2, attempt++);
      setStatus(`API ${method} ${path} ${r.status} — retry in ${Math.ceil(backoff/1000)}s`);
      await delay(backoff); retry--; continue;
    }
    const txt=await r.text(); throw new Error(`API ${method} ${path} ${r.status} ${txt.slice(0,160)}`);
  }
}
const spPost=(path,body,params)=>spReq("POST",path,body,params);

/* ---- Collectors（厳密フィルタ付き） ---- */
async function fetchAllAlbums(artistId, include_groups, allMarkets, market){
  let items=[],offset=0;
  while(true){
    const params={include_groups,limit:50,offset}; if(!allMarkets) params.market=market;
    const page=await spGet(`artists/${artistId}/albums`,params);
    items.push(...(page.items||[])); if(!page.next) break; offset+=50;
  }
  const seen=new Set(), albums=[]; for(const a of items){ if(!seen.has(a.id)){seen.add(a.id); albums.push(a);} }
  return albums;
}

async function fetchAlbumTracksStrict(albumId, allMarkets, market, artistId, primaryOnly){
  let tracks=[], offset=0;
  while(true){
    const params={limit:50,offset}; if(!allMarkets) params.market=market;
    const page=await spGet(`albums/${albumId}/tracks`,params);
    const keep=(page.items||[]).filter(t=>{
      const has = Array.isArray(t.artists) && t.artists.some(a=>a?.id===artistId);
      if(!has) return false;
      if(primaryOnly) return t.artists?.[0]?.id===artistId;
      return true;
    });
    tracks.push(...keep.map(t=>t.id));
    if(!page.next) break; offset+=50;
  }
  return tracks;
}

async function fetchArtistTopTracksMulti(artistId){
  const ids=new Set();
  for(const m of TOP_MARKETS){
    try{
      const res=await spGet(`artists/${artistId}/top-tracks`,{market:m});
      (res.tracks||[]).forEach(t=>ids.add(t.id));
      await delay(150); // 軽いスロットリング
    }catch{}
  }
  return [...ids];
}

/* ---- Audio features（任意） ---- */
async function fetchAudioFeaturesSafe(trackIds){
  const out={}; for(const batch of chunk(trackIds.filter(Boolean),50)){
    try{
      const data=await spGet("audio-features",{ids:batch.join(",")});
      (data.audio_features||[]).forEach(f=>{if(f&&f.id) out[f.id]=f;});
    }catch(_){
      for(const id of batch){ try{ const f=await spGet(`audio-features/${id}`,{}); if(f&&f.id) out[f.id]=f; } catch{ out[id]=null; } }
    }
  } return out;
}

/* ---- Builder ---- */
let running=false, lastData=[];
function toCSV(rows){ if(!rows.length) return ""; const head=Object.keys(rows[0]); const lines=[head.join(",")];
  for(const r of rows) lines.push(head.map(k=>`"${esc(r[k])}"`).join(",")); return lines.join("\n");}
function download(name,text,mime){const b=new Blob([text],{type:mime}); const a=document.createElement("a"); a.href=URL.createObjectURL(b); a.download=name; a.click(); URL.revokeObjectURL(a.href);}
function htmlList(rows,title="All Tracks — TDCS"){
  const items=rows.map((r,i)=>{const t=`<a href="${r.track_url}" target="_blank" rel="noopener">${esc(r.name)}</a>`;
    const al=r.album_url?` • <a href="${r.album_url}" target="_blank" rel="noopener">${esc(r.album)}</a>`:"";
    const as=r.artist_urls? r.artist_urls.split(" | ").map((u,j)=>`<a href="${u}" target="_blank" rel="noopener">${esc(r.artists.split(", ")[j]||"Artist")}</a>`).join(", "):esc(r.artists);
    return `<li>${i+1}. ${t} — ${as}${al} <small>(pop:${r.popularity}${r.tempo?`, tempo:${r.tempo}`:""})</small></li>`;}).join("\n");
  return `<!doctype html><meta charset="utf-8"><title>${esc(title)}</title><body style="font-family:system-ui,-apple-system;max-width:900px;margin:40px auto"><h1>${esc(title)}</h1><ol>${items}</ol></body>`;
}

async function runAll(){
  if(running) return; running=true;
  try{
    setStatus("Building ALL (strict)…");
    const groups=$("#groups").value||"album,single,appears_on,compilation";
    const allMarkets=$("#allMarkets").checked; const market=$("#market").value||"US";
    const strict=$("#strict").checked; const primaryOnly=$("#primaryOnly").checked;
    const useTop=$("#useTopTracks").checked; const noLimit=$("#noLimit").checked;
    const wantFeatures=$("#wantFeatures").checked;

    // 1) 全アルバム
    const albums=await fetchAllAlbums(ARTIST_ID,groups,allMarkets,market);
    setStatus(`Collecting from ${albums.length} albums…`);

    // 2) アルバムから曲を厳密抽出
    let trackIds=[];
    for(const batch of chunk(albums,8)){
      const packs = await Promise.all(batch.map(a=>fetchAlbumTracksStrict(a.id,allMarkets,market,ARTIST_ID,primaryOnly).catch(()=>[])));
      packs.forEach(ids=>trackIds.push(...ids));
      await delay(120); // 穏やかに
    }

    // 3) 補完（アーティスト Top Tracks のみ）
    if(useTop){
      setStatus("Adding artist Top Tracks (multi markets) …");
      const extra = await fetchArtistTopTracksMulti(ARTIST_ID);
      trackIds.push(...extra);
    }

    // 4) 重複排除 → 詳細取得（ALL）
    trackIds=[...new Set(trackIds)];
    setStatus(`Fetching track details (${trackIds.length})…`);
    let tracks=[]; for(const ids of chunk(trackIds,50)){ const d=await spGet("tracks",{ids:ids.join(",")}); tracks.push(...(d.tracks||[])); await delay(80); }
    // 念のためここでも厳密フィルタ（検索/TopTracksで混入しないが安全のため）
    if(strict){
      tracks = tracks.filter(t=>{
        const has = t.artists?.some(a=>a?.id===ARTIST_ID);
        return primaryOnly ? (has && t.artists?.[0]?.id===ARTIST_ID) : has;
      });
    }
    tracks = tracks.filter(Boolean).sort((a,b)=>(b.popularity||0)-(a.popularity||0));
    if(!noLimit) tracks = tracks.slice(0,120);

    // 5) audio-features（任意）
    let featById={}; if(wantFeatures){ setStatus("Fetching audio-features…"); featById=await fetchAudioFeaturesSafe(tracks.map(t=>t.id)); }

    // 6) 整形
    lastData=tracks.map(t=>{
      const f=featById[t.id]||{};
      const artistNames=t.artists.map(a=>a.name).join(", ");
      const artistUrls =t.artists.map(a=>a.external_urls?.spotify||"").filter(Boolean).join(" | ");
      const trackUrl   =t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`;
      const albumUrl   =t.album?.external_urls?.spotify || "";
      const avail=Array.isArray(t.available_markets)?t.available_markets.length:
        (t.album&&Array.isArray(t.album.available_markets)?t.album.available_markets.length:"");
      return {id:t.id,name:t.name,artists:artistNames,artist_urls:artistUrls,popularity:t.popularity,isrc:t.external_ids?.isrc||"",
        preview_url:t.preview_url||"",track_url:trackUrl,album:t.album?.name||"",album_url:albumUrl,release_date:t.album?.release_date||"",
        available_markets_count:avail,duration_ms:t.duration_ms,tempo:f.tempo??"",energy:f.energy??"",danceability:f.danceability??"",
        valence:f.valence??"",loudness:f.loudness??""};
    });

    // 7) 表示
    const ol=$("#tracks"); ol.innerHTML="";
    lastData.forEach((r,i)=>{const li=document.createElement("li"); const a=document.createElement("a");
      a.href=r.track_url; a.textContent=r.name; a.target="_blank"; a.rel="noopener";
      li.append(`${i+1}. `); li.append(a); li.append(` — ${r.artists} (pop:${r.popularity}${r.tempo?`, tempo:${r.tempo}`:""})`);
      ol.appendChild(li);});
    setStatus(`Loaded ${lastData.length} tracks ${strict?"[strict]":""} ${noLimit?"(ALL)":""}`);
  }catch(e){ setStatus(e.message||String(e)); }
  finally{ running=false; }
}

/* ---- Downloads ---- */
document.getElementById("btnDLhtml").onclick=()=>lastData.length&&download("spotify_all_with_links.html",htmlList(lastData),"text/html");
document.getElementById("btnDLjson").onclick=()=>lastData.length&&download("spotify_all_with_links.json",JSON.stringify(lastData,null,2),"application/json");
document.getElementById("btnDLcsv").onclick =()=>lastData.length&&download("spotify_all_with_links.csv",toCSV(lastData),"text/csv");

/* ---- Playlist（既定=非公開） ---- */
async function getMe(){return spGet("me",{});}
async function createPlaylist(name,desc,isPublic){
  const me=await getMe();
  return spPost(`users/${me.id}/playlists`,{name,description:desc,public:!!isPublic});
}
async function addTracksToPlaylist(playlistId,trackIds){
  const uris=[...new Set(trackIds)].filter(Boolean).map(id=>`spotify:track:${id}`);
  for(const batch of chunk(uris,100)){ await spPost(`playlists/${playlistId}/tracks`,{uris:batch}); await delay(250); }
}
document.getElementById("btnCreate").onclick=async()=>{
  try{
    if(!lastData.length){ setStatus("先に Build ALL を実行して曲を用意してね"); return; }
    const name=$("#plName").value||"TDCS — ALL";
    const isPublic=$("#plPublic").checked; // 既定OFF = 非公開
    setStatus(`Creating ${isPublic?"public":"private"} playlist…`);
    const pl=await createPlaylist(name,"Auto-built from TDCS discography (strict, all markets).",isPublic);
    setStatus("Adding tracks…");
    await addTracksToPlaylist(pl.id,lastData.map(x=>x.id));
    const url = pl.external_urls?.spotify || `https://open.spotify.com/playlist/${pl.id}`;
    $("#plLink").innerHTML=`<a href="${url}" target="_blank" rel="noopener">Open playlist</a>`;
    setStatus(`Done — ${lastData.length} tracks added (${isPublic?"public":"private"}).`);
  }catch(e){ setStatus("Playlist error: "+(e.message||e)); }
};

/* ---- Boot: PKCE callback ---- */
(async function init(){
  const qp=new URLSearchParams(location.search);
  const code=qp.get("code"); const state=qp.get("state");
  if(code){
    const saved=sessionStorage.getItem("pkce_state"); const verifier=sessionStorage.getItem("pkce_verifier");
    if(!verifier||!saved||state!==saved){ setStatus("State/Verifier mismatch. Start from auth.html"); return; }
    try{ const tok=await exchangeAuthCode(code,verifier); clearPkce(); history.replaceState({},document.title,location.pathname); saveToken(tok);}
    catch(e){ setStatus(e.message); return; }
  }
  document.getElementById("btnFetch").onclick=()=>runAll();
})();
</script>
</body>
</html>
