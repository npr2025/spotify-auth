<!doctype html>
<meta charset="utf-8">
<title>Spotify — TDCS ONLY / EXACT 120 (Private Playlist)</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<body style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:980px;margin:40px auto">
  <h1>Spotify Authentication</h1>
  <p id="status">Signed in. Build TDCS-only (exact 120) → Create Private Playlist.</p>

  <section id="app" style="display:block">
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin:12px 0">
      <label>Groups:
        <select id="groups">
          <!-- appears_on を外す（他人名義混入を避ける） -->
          <option value="album,single,compilation" selected>Albums + Singles + Compilations</option>
          <option value="album,single">Albums + Singles</option>
        </select>
      </label>
      <label><input type="checkbox" id="allMarkets" checked> All markets (no region filter)</label>
      <label>Market (only when All markets is OFF):
        <select id="market">
          <option value="US" selected>US</option><option value="JP">JP</option>
          <option value="GB">GB</option><option value="DE">DE</option>
        </select>
      </label>
      <label><input type="checkbox" id="wantFeatures"> Fetch audio-features (optional)</label>

      <button id="btnFetch">Build TDCS-only (exact 120)</button>
      <button id="btnDLhtml">Download HTML</button>
      <button id="btnDLjson">Download JSON</button>
      <button id="btnDLcsv">Download CSV</button>
    </div>

    <!-- ★ プレイリスト作成（既定=非公開） -->
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin:10px 0;padding:10px;border:1px solid #ddd;border-radius:8px">
      <input id="plName"  style="min-width:320px" value="PROGAPANDA • TOP120 (TDCS ONLY)">
      <label><input id="plPublic" type="checkbox"> Make Public</label>
      <button id="btnCreate">Create Playlist (Private by default)</button>
      <span id="plLink"></span>
    </div>

    <ol id="tracks"></ol>
  </section>

<script>
/* ====== Fixed config ====== */
const CLIENT_ID    = "1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI = "https://npr2025.github.io/spotify-auth/callback.html";
const ARTIST_ID    = "55fvQ5I2IZUfcFT2DV02T3"; // The Darrow Chem Syndicate
const EXACT_LIMIT  = 120;                         // ← ちょうど120に固定
/* ========================== */

const $=(s)=>document.querySelector(s);
const setStatus=(t)=>{$("#status").textContent=t; console.log(t);};

/* ---- PKCE token handling ---- */
function clearPkce(){sessionStorage.removeItem("pkce_verifier");sessionStorage.removeItem("pkce_state");}
function saveToken(t){sessionStorage.setItem("sp_access_token",t.access_token);
  if(t.refresh_token)sessionStorage.setItem("sp_refresh_token",t.refresh_token);
  sessionStorage.setItem("sp_exp_at",String(Date.now()+(t.expires_in||3600)*1000));}
function getToken(){return{access:sessionStorage.getItem("sp_access_token"),refresh:sessionStorage.getItem("sp_refresh_token"),
  expAt:Number(sessionStorage.getItem("sp_exp_at")||0)};}
async function exchangeAuthCode(code,verifier){
  const body=new URLSearchParams({client_id:CLIENT_ID,grant_type:"authorization_code",code,redirect_uri:REDIRECT_URI,code_verifier:verifier});
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok) throw new Error("Token exchange failed: "+r.status); return r.json();}
async function refreshAccessToken(refresh){
  const body=new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:refresh});
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok) throw new Error("Refresh failed: "+r.status); return r.json();}
async function ensureToken(){
  let {access,refresh,expAt}=getToken();
  if(access && Date.now()<expAt-60000) return access;
  if(refresh){const t=await refreshAccessToken(refresh); saveToken(t); return t.access_token;}
  throw new Error("No valid token (open auth.html and sign in)");
}

/* ---- Utils ---- */
function chunk(a,n){const o=[];for(let i=0;i<a.length;i+=n)o.push(a.slice(i,i+n));return o;}
const esc=(s)=>(''+(s??'')).replace(/"/g,'""');
const delay=(ms)=>new Promise(r=>setTimeout(r,ms));

/* ---- Spotify helpers（指数バックオフ） ---- */
async function spGet(path, params={}, retry=8, base=600){
  let attempt=0;
  while(true){
    const token=await ensureToken();
    const url=new URL("https://api.spotify.com/v1/"+path);
    Object.entries(params).forEach(([k,v])=>{if(v!==undefined&&v!==null&&v!=="")url.searchParams.set(k,v);});
    const r=await fetch(url,{headers:{Authorization:"Bearer "+token}});
    if(r.ok) return r.json();

    if(r.status===401 && retry>0){sessionStorage.removeItem("sp_access_token"); retry--; continue;}
    if((r.status===429||r.status>=500)&&retry>0){
      const ra=Number(r.headers.get("retry-after"))||0;
      const backoff = ra? ra*1000 : base * Math.pow(2, attempt++);
      setStatus(`API ${path} ${r.status} — retry in ${Math.ceil(backoff/1000)}s`);
      await delay(backoff); retry--; continue;
    }
    const txt=await r.text(); throw new Error(`API ${path} ${r.status} ${txt.slice(0,160)}`);
  }
}
async function spReq(method,path,body=null,params={},retry=8,base=600){
  let attempt=0;
  while(true){
    const token=await ensureToken();
    const url=new URL("https://api.spotify.com/v1/"+path);
    Object.entries(params).forEach(([k,v])=>{if(v!==undefined&&v!==null&&v!=="")url.searchParams.set(k,v);});
    const r=await fetch(url,{method,headers:{Authorization:"Bearer "+token,"Content-Type":"application/json"},body:body?JSON.stringify(body):null});
    if(r.ok) return r.json();
    if((r.status===429||r.status>=500)&&retry>0){
      const ra=Number(r.headers.get("retry-after"))||0;
      const backoff = ra? ra*1000 : base * Math.pow(2, attempt++);
      setStatus(`API ${method} ${path} ${r.status} — retry in ${Math.ceil(backoff/1000)}s`);
      await delay(backoff); retry--; continue;
    }
    const txt=await r.text(); throw new Error(`API ${method} ${path} ${r.status} ${txt.slice(0,160)}`);
  }
}
const spPost=(path,body,params)=>spReq("POST",path,body,params);

/* ---- Collectors（TDCS限定） ---- */
async function fetchAllAlbums(artistId, include_groups, allMarkets, market){
  let items=[],offset=0;
  while(true){
    const params={include_groups,limit:50,offset}; if(!allMarkets) params.market=market;
    const page=await spGet(`artists/${artistId}/albums`,params);
    items.push(...(page.items||[])); if(!page.next) break; offset+=50;
  }
  // 重複除去
  const seen=new Set(), albums=[];
  for(const a of items){ if(!seen.has(a.id)){ seen.add(a.id); albums.push(a); } }
  return albums;
}

async function fetchAlbumTracks_TDCS(album, allMarkets, market, artistId){
  // アルバム自体に TDCS が含まれない場合はスキップ
  const albumHasTDCS = (album.artists||[]).some(a=>a?.id===artistId);
  if(!albumHasTDCS) return [];
  let keep=[], offset=0;
  while(true){
    const params={limit:50,offset}; if(!allMarkets) params.market=market;
    const page=await spGet(`albums/${album.id}/tracks`,params);
    // 各曲の artists[] にも TDCS が含まれるものだけ採用
    const ok=(page.items||[]).filter(t=> Array.isArray(t.artists) && t.artists.some(a=>a?.id===artistId) );
    keep.push(...ok.map(t=>t.id));
    if(!page.next) break; offset+=50;
  }
  return keep;
}

/* ---- Audio features（任意） ---- */
async function fetchAudioFeaturesSafe(trackIds){
  if(!$("#wantFeatures").checked) return {};
  const out={}; for(const batch of chunk(trackIds.filter(Boolean),50)){
    try{
      const data=await spGet("audio-features",{ids:batch.join(",")});
      (data.audio_features||[]).forEach(f=>{if(f&&f.id) out[f.id]=f;});
    }catch(_){
      for(const id of batch){ try{ const f=await spGet(`audio-features/${id}`,{}); if(f&&f.id) out[f.id]=f; } catch{ out[id]=null; } }
    }
    await delay(1000);
  } return out;
}

/* ---- Builder ---- */
let running=false, lastData=[];
function toCSV(rows){ if(!rows.length) return ""; const head=Object.keys(rows[0]); const lines=[head.join(",")];
  for(const r of rows) lines.push(head.map(k=>`"${esc(r[k])}"`).join(",")); return lines.join("\n");}
function download(name,text,mime){const b=new Blob([text],{type:mime}); const a=document.createElement("a"); a.href=URL.createObjectURL(b); a.download=name; a.click(); URL.revokeObjectURL(a.href);}
function htmlList(rows,title="TDCS ONLY — 120"){
  const items=rows.map((r,i)=>{const t=`<a href="${r.track_url}" target="_blank" rel="noopener">${esc(r.name)}</a>`;
    const al=r.album_url?` • <a href="${r.album_url}" target="_blank" rel="noopener">${esc(r.album)}</a>`:"";
    const as=r.artist_urls? r.artist_urls.split(" | ").map((u,j)=>`<a href="${u}" target="_blank" rel="noopener">${esc(r.artists.split(", ")[j]||"Artist")}</a>`).join(", "):esc(r.artists);
    return `<li>${i+1}. ${t} — ${as}${al} <small>(pop:${r.popularity}${r.tempo?`, tempo:${r.tempo}`:""})</small></li>`;}).join("\n");
  return `<!doctype html><meta charset="utf-8"><title>${esc(title)}</title><body style="font-family:system-ui,-apple-system;max-width:900px;margin:40px auto"><h1>${esc(title)}</h1><ol>${items}</ol></body>`;
}

async function runTDCSOnly(){
  if(running) return; running=true;
  try{
    setStatus("Building TDCS-only…");
    const groups=$("#groups").value||"album,single,compilation";
    const allMarkets=$("#allMarkets").checked; const market=$("#market").value||"US";

    // 1) TDCS名義アルバム群
    const albums=await fetchAllAlbums(ARTIST_ID,groups,allMarkets,market);
    setStatus(`Collecting from ${albums.length} TDCS albums…`);

    // 2) 各アルバムから TDCS 含む曲のみ
    let trackIds=[];
    for(const batch of chunk(albums,8)){
      const packs = await Promise.all(batch.map(a=>fetchAlbumTracks_TDCS(a,allMarkets,market,ARTIST_ID).catch(()=>[])));
      packs.forEach(ids=>trackIds.push(...ids));
      await delay(120);
    }
    // 3) 重複排除
    trackIds=[...new Set(trackIds)];

    // 4) 詳細取得
    setStatus(`Fetching track details (${trackIds.length})…`);
    let tracks=[]; for(const ids of chunk(trackIds,50)){ const d=await spGet("tracks",{ids:ids.join(",")}); tracks.push(...(d.tracks||[])); await delay(80); }

    // 5) 念のための最終フィルタ（曲にもTDCSがいるものだけ）
    tracks = tracks.filter(t=> t && t.artists?.some(a=>a?.id===ARTIST_ID));

    // 6) 人気降順 → 120曲ちょうど
    tracks = tracks.sort((a,b)=>(b.popularity||0)-(a.popularity||0));
    if (tracks.length >= EXACT_LIMIT) {
      tracks = tracks.slice(0, EXACT_LIMIT);
    } else {
      setStatus(`Only ${tracks.length} tracks found for TDCS-only. (不足: ${EXACT_LIMIT - tracks.length})`);
    }

    // 7) features（任意）
    let featById={}; try{ featById=await fetchAudioFeaturesSafe(tracks.map(t=>t.id)); } catch(e){ setStatus("features skipped: "+(e.message||e)); }

    // 8) 整形
    lastData=tracks.map(t=>{
      const f=featById[t.id]||{};
      const artistNames=t.artists.map(a=>a.name).join(", ");
      const artistUrls =t.artists.map(a=>a.external_urls?.spotify||"").filter(Boolean).join(" | ");
      const trackUrl   =t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`;
      const albumUrl   =t.album?.external_urls?.spotify || "";
      const avail=Array.isArray(t.available_markets)?t.available_markets.length:
        (t.album&&Array.isArray(t.album.available_markets)?t.album.available_markets.length:"");
      return {id:t.id,name:t.name,artists:artistNames,artist_urls:artistUrls,popularity:t.popularity,isrc:t.external_ids?.isrc||"",
        preview_url:t.preview_url||"",track_url:trackUrl,album:t.album?.name||"",album_url:albumUrl,release_date:t.album?.release_date||"",
        available_markets_count:avail,duration_ms:t.duration_ms,tempo:f.tempo??"",energy:f.energy??"",danceability:f.danceability??"",
        valence:f.valence??"",loudness:f.loudness??""};
    });

    // 9) 表示
    const ol=$("#tracks"); ol.innerHTML="";
    lastData.forEach((r,i)=>{const li=document.createElement("li"); const a=document.createElement("a");
      a.href=r.track_url; a.textContent=r.name; a.target="_blank"; a.rel="noopener";
      li.append(`${i+1}. `); li.append(a); li.append(` — ${r.artists} (pop:${r.popularity}${r.tempo?`, tempo:${r.tempo}`:""})`);
      ol.appendChild(li);});
    setStatus(`Loaded ${lastData.length} tracks — TDCS ONLY${lastData.length===EXACT_LIMIT?" (exact 120)":""}`);
  }catch(e){ setStatus(e.message||String(e)); }
  finally{ running=false; }
}

/* ---- Downloads ---- */
document.getElementById("btnDLhtml").onclick=()=>lastData.length&&download("tdcs_only_120.html",htmlList(lastData),"text/html");
document.getElementById("btnDLjson").onclick=()=>lastData.length&&download("tdcs_only_120.json",JSON.stringify(lastData,null,2),"application/json");
document.getElementById("btnDLcsv").onclick =()=>lastData.length&&download("tdcs_only_120.csv",toCSV(lastData),"text/csv");

/* ---- Playlist（既定=非公開） ---- */
async function getMe(){return spGet("me",{});}
async function createPlaylist(name,desc,isPublic){
  const me=await getMe();
  return spPost(`users/${me.id}/playlists`,{name,description:desc,public:!!isPublic});
}
async function addTracksToPlaylist(playlistId,trackIds){
  const uris=[...new Set(trackIds)].filter(Boolean).map(id=>`spotify:track:${id}`);
  for(const batch of chunk(uris,100)){ await spPost(`playlists/${playlistId}/tracks`,{uris:batch}); await delay(250); }
}
document.getElementById("btnCreate").onclick=async()=>{
  try{
    if(!lastData.length){ setStatus("先に Build TDCS-only を実行して曲を用意してね"); return; }
    const name=$("#plName").value||"PROGAPANDA • TOP120 (TDCS ONLY)";
    const isPublic=$("#plPublic").checked; // 既定OFF = 非公開
    setStatus(`Creating ${isPublic?"public":"private"} playlist…`);
    const pl=await createPlaylist(name,"Auto-built (TDCS ONLY, exact 120).",isPublic);
    setStatus("Adding tracks…");
    await addTracksToPlaylist(pl.id,lastData.map(x=>x.id));
    const url = pl.external_urls?.spotify || `https://open.spotify.com/playlist/${pl.id}`;
    $("#plLink").innerHTML=`<a href="${url}" target="_blank" rel="noopener">Open playlist</a>`;
    setStatus(`Done — ${lastData.length} tracks added (${isPublic?"public":"private"}).`);
  }catch(e){ setStatus("Playlist error: "+(e.message||e)); }
};

/* ---- Boot: PKCE callback ---- */
(async function init(){
  const qp=new URLSearchParams(location.search);
  const code=qp.get("code"); const state=qp.get("state");
  if(code){
    const saved=sessionStorage.getItem("pkce_state"); const verifier=sessionStorage.getItem("pkce_verifier");
    if(!verifier||!saved||state!==saved){ setStatus("State/Verifier mismatch. Start from auth.html"); return; }
    try{ const tok=await exchangeAuthCode(code,verifier); clearPkce(); history.replaceState({},document.title,location.pathname); saveToken(tok);}
    catch(e){ setStatus(e.message); return; }
  }
  document.getElementById("btnFetch").onclick=()=>runTDCSOnly();
})();
</script>
</body>
</html>
