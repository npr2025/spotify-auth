<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TDCS 130→120→100 (FAST / PKCE)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:1100px;margin:36px auto;padding:0 12px}
  h1{margin:0 0 8px}
  button{padding:8px 12px;border:1px solid #bbb;border-radius:8px;background:#f6f6f6;cursor:pointer}
  button:disabled{opacity:.45;cursor:not-allowed}
  input,select{padding:6px 8px;border:1px solid #ccc;border-radius:6px}
  #row{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
  #pins{display:grid;grid-template-columns:180px 1fr 160px;gap:8px;align-items:center;margin:10px 0;padding:10px;border:1px dashed #ddd;border-radius:8px;background:#fafafa}
  #log{background:#0b1220;color:#cfe3ff;padding:10px;border-radius:8px;max-height:360px;overflow:auto;white-space:pre-wrap;margin-top:12px}
  #debug{font-size:13px;color:#333;background:#f6f6f9;border:1px solid #e5e6ef;border-radius:8px;padding:8px;margin:12px 0}
  ol{line-height:1.5}
  label.small{font-size:12px;color:#666}
</style>
</head>
<body>
<h1>Spotify Authentication / FAST Builder</h1>
<p id="status">Booting…</p>

<div id="row">
  <label>Fetch market
    <select id="market">
      <option selected>US</option><option>JP</option><option>GB</option><option>DE</option>
    </select>
  </label>
  <label>Groups
    <select id="groups">
      <option value="album,single" selected>Albums + Singles</option>
      <option value="album">Albums only</option>
      <option value="album,single,compilation">Albums + Singles + Compilations</option>
    </select>
  </label>
  <button id="btnBuild">FAST Build 130 (Remix-only)</button>
  <button id="btnTrim"  disabled>Trim to 120</button>
  <button id="btnPick"  disabled>Balanced 100</button>
  <button id="btnHead5" disabled>Optimize Head-5</button>
  <input id="plName" style="min-width:360px" value="PROGAPANDA • Balanced100 (TDCS Remixes)">
  <label><input id="plPublic" type="checkbox"> Make Public</label>
  <button id="btnCreate" disabled>Create Playlist</button>
</div>

<div id="pins">
  <div><b>Pin Track IDs（固定）</b><div class="small">Remixのみ採用／“Mix”は全面除外。空欄は無視、重複は排除。</div></div>
  <input id="pinOpen"  value="0ueNjvhtXGDFkJQ5WBQ4mE" placeholder="先頭 (#1)">
  <span class="small">先頭 (#1)</span>
  <div></div>
  <input id="pinEarly" value="63dYSEftdSYwMAFBNfQYsA" placeholder="上旬（#8目安）">
  <span class="small">上旬 (目安 #8)</span>
  <div></div>
  <input id="pinMid"   value="3NQuIFfQPhTICaXGYe5dAt" placeholder="中盤（#45目安）">
  <span class="small">中盤 (目安 #45)</span>
  <div></div>
  <input id="pinLate"  value="7ltcrdlVsXyU5HU9VCAj6P" placeholder="後半（#75目安）">
  <span class="small">後半 (目安 #75)</span>
</div>

<div id="debug">
  <b>Token:</b> <span id="tokstate">–</span> |
  <button id="btnRefresh">Refresh token</button>
  <button id="btnReauth">Re-auth</button>
</div>

<ol id="tracks"></ol>
<pre id="log"></pre>

<script>
/*** 固定 ***/
const CLIENT_ID    = "1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI = "https://npr2025.github.io/spotify-auth/callback.html";
const ARTIST_ID    = "55fvQ5I2IZUfcFT2DV02T3";
const ARTIST_NAME  = "The Darrow Chem Syndicate";
const USER_ID      = "22fqn5mozguuegi2t3l2zeugy";
const DESIRED_SCOPES = ["playlist-modify-private","playlist-modify-public"];

/* リスト制御（速さ重視プリセット） */
const LIMIT_130=130, LIMIT_PREFETCH=90, LIMIT_120=120, LIMIT_100=100;
/* アルバム収集を浅く、足りなければ singles を少量だけ（セーフ上限） */
const FAST = { CAP_ALBUMS_PRIMARY: 30, CAP_ALBUMS_FALLBACK: 10 };
/* “条件に合う曲” がこの件数に到達したら tracks 取得を早期終了 */
const TARGET_GOOD = 150;

/*** Util/UI ***/
const $=s=>document.querySelector(s);
const log=m=>{const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; console.log(m);}
const setStatus=t=>{ $("#status").textContent=t; log(t); }
async function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function stableHash(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=Math.imul(h,16777619);} return h>>>0; }

/*** Remix-only / “Mix”除外 ***/
function isRemixOnly(name){
  const s = name||"";
  const hasRemix   = /\bremix\b/i.test(s);
  const hasMixWord = /\bmix\b/i.test(s);
  return hasRemix && !hasMixWord;
}

/*** リミキサー抽出 ***/
function parseRemixerTokens(title){
  const s=(title||"").toLowerCase();
  if(!/remix/.test(s)) return new Set();
  let core="";
  const paren=s.match(/\(([^)]*?)\s*remix\)/i);
  if(paren) core=paren[1];
  else { const dash=s.match(/-\s*([^-\(\)]*?)\s*remix\b/i); core=dash?dash[1]:"unknown"; }
  return new Set(core.split(/(?:\s*(?:&|x|×|,|\/|\+)\s*|\s+vs\.?\s+|\s+feat\.?\s+)/i).map(t=>t.trim()).filter(Boolean));
}
function shareRemixer(a,b){ const A=a._remixers||new Set(), B=b._remixers||new Set(); for(const x of A) if(B.has(x)) return true; return false; }

/*** Token 管理（localStorage に refresh_token を複製、復帰容易化） ***/
function saveToken(t){
  const expAt=Date.now()+(t.expires_in||3600)*1000;
  sessionStorage.setItem("sp_access_token",t.access_token);
  if(t.refresh_token){
    sessionStorage.setItem("sp_refresh_token",t.refresh_token);
    localStorage.setItem("sp_refresh_token",t.refresh_token);
  }
  sessionStorage.setItem("sp_exp_at",String(expAt));
  sessionStorage.setItem("sp_scope",t.scope||"");
  updateTokenDebug();
}
function loadRT(){
  return sessionStorage.getItem("sp_refresh_token") || localStorage.getItem("sp_refresh_token") || "";
}
function clearToken(){
  ["sp_access_token","sp_refresh_token","sp_exp_at","sp_scope","pkce_state","pkce_verifier"].forEach(k=>sessionStorage.removeItem(k));
  // refresh_token は手動リセットのみ（Re-authボタンで消す）
  updateTokenDebug();
}
function nukeAllTokens(){
  clearToken();
  localStorage.removeItem("sp_refresh_token");
}
function scopeOk(req){ const s=(sessionStorage.getItem("sp_scope")||"").split(" "); return req.every(x=>s.includes(x)); }
function updateTokenDebug(){
  const exp=+sessionStorage.getItem("sp_exp_at")||0;
  const left=exp?Math.max(0,Math.floor((exp-Date.now())/1000)):0;
  const rt=!!loadRT();
  const sc=sessionStorage.getItem("sp_scope")||"";
  $("#tokstate").textContent=(sessionStorage.getItem("sp_access_token")?"OK":"NONE")+` / exp in ${left}s / refresh:${rt?"yes":"no"} / scope:[${sc}]`;
}
async function tokenByCode(code,verifier){
  const r=await fetch("https://accounts.spotify.com/api/token",{
    method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},
    body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"authorization_code",code,redirect_uri:REDIRECT_URI,code_verifier:verifier})
  });
  if(!r.ok){ const msg=await r.text(); throw new Error(`Token exchange ${r.status}: ${msg}`); }
  return r.json();
}
async function refreshTokenNow(){
  const rt=loadRT(); if(!rt) throw new Error("No refresh_token");
  const r=await fetch("https://accounts.spotify.com/api/token",{
    method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},
    body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:rt})
  });
  if(!r.ok){ const msg=await r.text(); nukeAllTokens(); throw new Error(`Refresh ${r.status}: ${msg}`); }
  saveToken(await r.json()); log("Token refreshed.");
}
async function ensureToken(req=DESIRED_SCOPES){
  updateTokenDebug();
  const tok=sessionStorage.getItem("sp_access_token");
  const exp=+sessionStorage.getItem("sp_exp_at")||0;
  if(tok && Date.now()<exp-120000){
    if(!scopeOk(req)) throw reauthError("Scope insufficient → re-auth");
    return tok;
  }
  const rt=loadRT();
  if(rt){
    await refreshTokenNow();
    if(!scopeOk(req)) throw reauthError("Scope insufficient after refresh → re-auth");
    return sessionStorage.getItem("sp_access_token");
  }
  throw reauthError("No token → re-auth");
}
function reauthError(reason){
  setStatus(reason);
  location.replace("auth.html");
  const err=new Error("REAUTH"); err._reauth=true; return err;
}

/*** 適応型レートリミッタ（429完全版・直列・ジッタ・指数後退） ***/
const RATE = {
  gapMs: 3000,          // 初期ギャップ（保守的）
  minGapMs: 1500,       // 下限（安定してOK連発時にここまで）
  maxGapMs: 60000,      // 上限
  okStreak: 0,          // 連続OK回数
  okToStepDown: 20,     // 短縮に必要なOK連続回数
  last: 0,
  consecutive429: 0,    // 連続429
};
function jitter(ms){ return ms + Math.floor(Math.random()*600) - 300; }
let _q = Promise.resolve();
async function _serialize(){ const prev=_q; let release; _q = new Promise(r=>release=r); await prev; return release; }
async function rateWait(){
  const release = await _serialize();
  try{
    const wait = Math.max(0, RATE.last + RATE.gapMs - Date.now());
    if(wait) await sleep(jitter(wait));
    RATE.last = Date.now();
  } finally { release(); }
}
function on429(retryAfterSec){
  RATE.okStreak = 0;
  RATE.consecutive429++;
  const after = (Number(retryAfterSec)||2)*1000 + 1000; // Retry-After + 1s
  // 直近のギャップとRetry-Afterの大きい方へ、さらに1.7倍の後退
  RATE.gapMs = Math.min(RATE.maxGapMs, Math.max(after, Math.floor(RATE.gapMs*1.7)));
  log(`429 → wait ${retryAfterSec||2}s, next gap≈${RATE.gapMs}ms (x${RATE.consecutive429})`);
}
function onOk(){
  RATE.consecutive429 = 0;
  RATE.okStreak++;
  if(RATE.okStreak >= RATE.okToStepDown){
    RATE.okStreak = 0;
    RATE.gapMs = Math.max(RATE.minGapMs, Math.floor(RATE.gapMs*0.9)); // 緩やかに短縮
  }
}

/*** 共通fetch（401/429/5xx/ネットワーク再試行 + タイムアウト） ***/
async function doFetch(url, options={}, needScopes){
  await rateWait();
  if(needScopes){ await ensureToken(needScopes); }
  const token = sessionStorage.getItem("sp_access_token");
  const headers = Object.assign({Authorization:"Bearer "+token}, options.headers||{});
  const maxRetry = 6;
  for(let attempt=0; attempt<maxRetry; attempt++){
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), 35000); // 35sタイムアウト
    try{
      const r = await fetch(url, Object.assign({}, options, {headers, signal: ctrl.signal}));
      clearTimeout(t);
      if(r.status===401){
        log("401 → refresh and retry");
        await refreshTokenNow();
        continue;
      }
      if(r.status===429){
        const ra=+r.headers.get("retry-after")||2;
        on429(ra);
        await sleep(ra*1000 + 1000);
        continue;
      }
      if(r.status>=500 && r.status<600){
        // サーバ側一時障害：指数バックオフ
        const back = Math.min(6000, 1000 * Math.pow(1.7, attempt));
        log(`5xx ${r.status} → retry in ${back}ms`);
        await sleep(back);
        continue;
      }
      if(!r.ok){
        const msg=await r.text().catch(()=>String(r.status));
        throw new Error(`${r.status} ${msg}`);
      }
      onOk();
      return r;
    }catch(err){
      clearTimeout(t);
      if(err.name==="AbortError"){
        const back = Math.min(8000, 1500 * Math.pow(1.7, attempt));
        log(`Timeout → retry in ${back}ms`);
        await sleep(back);
        continue;
      }
      // ネットワーク系：指数バックオフ継続
      const back = Math.min(8000, 1200 * Math.pow(1.7, attempt));
      log(`Network error "${err.message}" → retry in ${back}ms`);
      await sleep(back);
    }
  }
  throw new Error("Max retry exceeded");
}

/*** Spotify APIラッパ ***/
async function spGet(path, params={}){
  const u=new URL("https://api.spotify.com/v1/"+path);
  Object.entries(params).forEach(([k,v])=>{ if(v!=null&&v!=="") u.searchParams.set(k,v);});
  const r=await doFetch(u, {method:"GET"});
  return r.json();
}
async function spPost(path, body, need=["playlist-modify-private"]){
  const r=await doFetch("https://api.spotify.com/v1/"+path,{
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify(body)
  }, need);
  return r.json();
}

/*** 取得系（段階化＋早期打ち切り） ***/
async function fetchAllAlbumIds(include="album,single", market="US", cap=80){
  const out=new Set(); let fetched=0, offset=0, limit=50;
  while(true){
    const d=await spGet(`artists/${ARTIST_ID}/albums`,{include_groups:include,market,limit,offset});
    const items=d?.items||[];
    for(const a of items){ out.add(a.id); }
    fetched+=items.length;
    if(!d?.next || items.length===0 || fetched>=cap) break;
    offset+=limit;
  }
  log(`albums collected: ${out.size} (groups=${include})`);
  return [...out];
}
async function fetchAlbumsWithTracks(albumIds, market="US"){
  const chunk=20, all=[];
  for(let i=0;i<albumIds.length;i+=chunk){
    const ids=albumIds.slice(i,i+chunk);
    const d=await spGet("albums",{ids:ids.join(","),market});
    for(const al of (d?.albums||[])){
      for(const t of (al?.tracks?.items||[])){ all.push({album:al.name, id:t.id, name:t.name}); }
    }
  }
  log(`album chunks: ${Math.ceil(albumIds.length/20)} → raw tracks: ${all.length}`);
  return all;
}
async function fetchTracksFullProgressive(ids, market="US", predicate=()=>true, target=TARGET_GOOD){
  const out=[], chunk=50; let good=0;
  for(let i=0;i<ids.length;i+=chunk){
    const part=ids.slice(i,i+chunk);
    const d=await spGet("tracks",{ids:part.join(","),market});
    for(const t of (d?.tracks||[])){
      if(t){ out.push(t); if(predicate(t)) good++; }
    }
    if(good>=target){
      log(`early stop: collected ${good} good tracks (target=${target})`);
      break;
    }
  }
  return out;
}

/*** 整形/UI描画 ***/
let pool=[], list120=[], list100=[], lastData=[];
function render(list){
  const ol=$("#tracks"); ol.innerHTML="";
  list.forEach((r,i)=>{
    const li=document.createElement("li");
    const a=document.createElement("a"); a.href=r.track_url; a.textContent=r.name; a.target="_blank"; a.rel="noopener";
    li.append(`${i+1}. `, a, ` — ${r.artists} (pop:${r.popularity})`); ol.appendChild(li);
  });
  const on=list.length>0;
  $("#btnTrim").disabled=!pool.length; $("#btnPick").disabled=!list120.length; $("#btnHead5").disabled=!on; $("#btnCreate").disabled=!on;
}
function getPins(){ return { open:($("#pinOpen").value||"").trim(), early:($("#pinEarly").value||"").trim(), mid:($("#pinMid").value||"").trim(), late:($("#pinLate").value||"").trim() }; }
function dropDupAndKeepLen(list, keepSet, target){
  const out=[], seen=new Set();
  for(const r of list){ if(seen.has(r.id)) continue; seen.add(r.id); out.push(r); }
  while(out.length>target){
    const last=out[out.length-1];
    if(keepSet.has(last.id)){
      let idx=-1; for(let i=out.length-1;i>=0;i--){ if(!keepSet.has(out[i].id)){ idx=i; break; } }
      if(idx<0) break; out.splice(idx,1);
    } else out.pop();
  }
  return out;
}
function capByAlbum(list, cap=2){
  const cnt={}, out=[];
  for(const r of list){
    const k=r.album+"::"+r.artists;
    cnt[k]=(cnt[k]||0);
    if(cnt[k]<cap){ out.push(r); cnt[k]++; }
  }
  return out;
}
function avoidAdjacentSharedRemixer(list){
  for(let i=1;i<list.length;i++){
    if(shareRemixer(list[i-1],list[i])){
      let j=i+1; while(j<list.length && shareRemixer(list[i-1],list[j])) j++;
      if(j<list.length){ const tmp=list[i]; list[i]=list[j]; list[j]=tmp; }
    }
  } return list;
}

/*** BUILD 130（高速モード） ***/
$("#btnBuild").onclick = async ()=>{
  $("#btnBuild").disabled=true; $("#btnTrim").disabled=true; $("#btnPick").disabled=true; $("#btnHead5").disabled=true; $("#btnCreate").disabled=true;
  try{
    const market=$("#market").value||"US";
    const groupsSel = $("#groups").value||"album,single";
    const [groupsPrimary, groupsFallback] =
      groupsSel==="album" ? ["album","single"] :
      groupsSel==="album,single,compilation" ? ["album,single,compilation","single"] :
      ["album","single"];

    setStatus("① FAST build via Albums-batch (albums first).");
    const alids1 = await fetchAllAlbumIds(groupsPrimary, market, FAST.CAP_ALBUMS_PRIMARY);
    const raw1   = await fetchAlbumsWithTracks(alids1, market);
    let remixIds = raw1.filter(x=>isRemixOnly(x.name)).map(x=>x.id);

    if(remixIds.length===0){
      setStatus("No remix in albums — adding singles (small).");
      const alidsS = await fetchAllAlbumIds(groupsFallback, market, FAST.CAP_ALBUMS_FALLBACK);
      const rawS   = await fetchAlbumsWithTracks(alidsS, market);
      remixIds = rawS.filter(x=>isRemixOnly(x.name)).map(x=>x.id);
    }else if(remixIds.length < 130){
      setStatus(`Albums found ${remixIds.length} remix tracks — topping up with singles (small).`);
      const alidsS = await fetchAllAlbumIds(groupsFallback, market, FAST.CAP_ALBUMS_FALLBACK);
      const rawS   = await fetchAlbumsWithTracks(alidsS, market);
      remixIds = remixIds.concat(rawS.filter(x=>isRemixOnly(x.name)).map(x=>x.id));
    }

    if(remixIds.length===0) throw new Error("No remix tracks found.");

    // 事前トリム（<= LIMIT_PREFETCH = 90）＆ 安定シャッフル
    const preIds = remixIds
      .map(id=>({id, h:stableHash(id)}))
      .sort((a,b)=>a.h-b.h)
      .slice(0, Math.min(LIMIT_PREFETCH, remixIds.length))
      .map(x=>x.id);
    log(`prefetch ids: ${preIds.length} (<=${LIMIT_PREFETCH})`);

    // 詳細取得は “条件に合う曲が TARGET_GOOD に達したら早期終了”
    const full = await fetchTracksFullProgressive(
      preIds, market,
      t => t?.artists?.some(a=>a.id===ARTIST_ID) && isRemixOnly(t.name),
      TARGET_GOOD
    );

    // TDCS参加 & Remix-only
    pool = full
      .filter(t=>t?.artists?.some(a=>a.id===ARTIST_ID))
      .filter(t=>isRemixOnly(t.name))
      .map(t=>{
        const row={ id:t.id, name:t.name, artists:t.artists.map(a=>a.name).join(", "),
          popularity:t.popularity||0, track_url:t.external_urls?.spotify||`https://open.spotify.com/track/${t.id}`,
          album:t.album?.name||"", album_url:t.album?.external_urls?.spotify||"" };
        row._remixers = parseRemixerTokens(row.name); return row;
      })
      .sort((a,b)=>(b.popularity||0)-(a.popularity||0));

    // Pins 補完（不足分のみ）
    const pins=getPins(); const pinSet=new Set([pins.open,pins.early,pins.mid,pins.late].filter(Boolean));
    const have=new Set(pool.map(x=>x.id));
    const missing=[...pinSet].filter(id=>!have.has(id));
    if(missing.length){
      const pinsFull = await fetchTracksFullProgressive(
        missing, market,
        t => t?.artists?.some(a=>a.id===ARTIST_ID) && isRemixOnly(t.name),
        missing.length
      );
      for(const t of pinsFull.reverse()){
        if(!t?.artists?.some(a=>a.id===ARTIST_ID)) continue;
        if(!isRemixOnly(t.name)) continue;
        pool.unshift({ id:t.id, name:t.name, artists:t.artists.map(a=>a.name).join(", "),
          popularity:t.popularity||0, track_url:t.external_urls?.spotify||`https://open.spotify.com/track/${t.id}`,
          album:t.album?.name||"", album_url:t.album?.external_urls?.spotify||"", _remixers:parseRemixerTokens(t.name) });
      }
    }

    // 130 にキャップ
    pool = dropDupAndKeepLen(pool, pinSet, Math.min(LIMIT_130, pool.length));
    render(pool);
    setStatus(`Loaded pool: ${pool.length} (FAST mode: albums-first + singles small-topup, adaptive rate-limit)`);
    $("#btnTrim").disabled=false;
  }catch(e){
    setStatus("Build error: "+(e.message||e));
  }
  $("#btnBuild").disabled=false;
};

/*** TRIM 120 / PICK 100 / Head-5 / Create Playlist ***/
$("#btnTrim").onclick = ()=>{
  if(!pool.length) return;
  const pins=getPins(); const pinSet=new Set([pins.open,pins.early,pins.mid,pins.late].filter(Boolean));
  let working = capByAlbum(pool, 2);
  working = dropDupAndKeepLen(working, pinSet, Math.min(LIMIT_120, working.length));
  working = avoidAdjacentSharedRemixer(working);
  list120 = working.slice(); lastData=list120.slice(); render(lastData);
  setStatus(`Trimmed to ${lastData.length} (albums≤2, pins ensured, no adjacent shared remixer)`);
  $("#btnPick").disabled=false;
};
$("#btnPick").onclick = async ()=>{
  if(!list120.length) return;
  const mk=$("#market").value||"US";
  const pins=getPins();
  let picked=list120.slice().sort((a,b)=>(b.popularity||0)-(a.popularity||0));
  picked = capByAlbum(picked, 2);
  picked = dropDupAndKeepLen(picked, new Set(), LIMIT_100);
  const plan=[ {id:pins.open,pos:0}, {id:pins.early,pos:7}, {id:pins.mid,pos:44}, {id:pins.late,pos:74} ].filter(p=>p.id);
  const byId=new Map(picked.map(x=>[x.id,x]));
  const missing=plan.map(p=>p.id).filter(id=>!byId.has(id));
  if(missing.length){
    const pinsFull=await fetchTracksFullProgressive(
      missing, mk,
      t => t?.artists?.some(a=>a.id===ARTIST_ID) && isRemixOnly(t.name),
      missing.length
    );
    for(const t of pinsFull){
      const row={ id:t.id, name:t.name, artists:t.artists.map(a=>a.name).join(", "),
        popularity:t.popularity||0, track_url:t.external_urls?.spotify||`https://open.spotify.com/track/${t.id}`,
        album:t.album?.name||"", album_url:t.album?.external_urls?.spotify||"", _remixers:parseRemixerTokens(t.name) };
      byId.set(row.id,row); picked.push(row);
    }
  }
  const pinSet=new Set(plan.map(p=>p.id));
  picked = picked.filter(x=>!pinSet.has(x.id));
  for(const p of plan){ const row=byId.get(p.id); if(!row) continue; const pos=Math.min(Math.max(p.pos,0),picked.length); picked.splice(pos,0,row); }
  picked = dropDupAndKeepLen(picked, pinSet, LIMIT_100);
  picked = avoidAdjacentSharedRemixer(picked);
  list100=picked.slice(); lastData=list100.slice(); render(lastData);
  setStatus("Balanced 100 ready (Pins fixed #1/#8/#45/#75, no adjacent shared remixer)");
};
$("#btnHead5").onclick=()=>{
  if(!lastData.length) return;
  const pins=getPins(); const pinSet=new Set(Object.values(pins).filter(Boolean));
  const isPinned=x=>pinSet.has(x.id);
  const pool=lastData.filter(t=>!isPinned(t)).map(t=>({t,score:t.popularity||0})).sort((a,b)=>b.score-a.score);
  const take=()=>pool.shift()?.t;
  const head=[take(),take(),take(),take(),take()].filter(Boolean);
  const idxs=lastData.map((x,i)=>({x,i})).filter(v=>!isPinned(v.x)).map(v=>v.i).slice(0,head.length);
  head.forEach((h,k)=>{ lastData[idxs[k]]=h; }); render(lastData);
  setStatus("Head-5 optimized (Pins preserved)");
};
$("#btnCreate").onclick=async ()=>{
  try{
    if(!lastData.length) return;
    const isPublic=$("#plPublic").checked;
    const need=[isPublic?"playlist-modify-public":"playlist-modify-private"];
    const me=await spGet("me");
    if(me?.id && me.id!==USER_ID) throw new Error(`Signed in as ${me.id}. Please sign in as ${USER_ID}.`);
    const pl=await spPost(`users/${USER_ID}/playlists`,{
      name:$("#plName").value||"PROGAPANDA • Balanced100 (TDCS Remixes)",
      description:"Album-batch FAST. Remix-only (no 'Mix'). Pins at #1/#8/#45/#75. TDCS 130→120→100.",
      public:!!isPublic
    }, need);
    const uris=[...new Set(lastData.map(x=>"spotify:track:"+x.id))];
    for(let i=0;i<uris.length;i+=100){
      await spPost(`playlists/${pl.id}/tracks`,{uris:uris.slice(i,i+100)}, need);
      await sleep(300);
    }
    const url=pl.external_urls?.spotify||`https://open.spotify.com/playlist/${pl.id}`;
    setStatus(`Done — ${lastData.length} tracks added (${isPublic?"public":"private"}). ${url}`);
  }catch(e){ setStatus("Playlist error: "+(e.message||e)); }
};

/*** Token ops ***/
$("#btnRefresh").onclick=()=>refreshTokenNow().catch(e=>setStatus("Refresh error: "+(e.message||e)));
$("#btnReauth").onclick=()=>{ nukeAllTokens(); location.replace("auth.html"); };

/*** 起動（PKCE code→token交換→UI解放） ***/
(async function boot(){
  try{
    // 1) codeパラメータがあれば交換
    const qp=new URLSearchParams(location.search);
    const code=qp.get("code"), state=qp.get("state");
    if(code){
      const saved=sessionStorage.getItem("pkce_state"), verifier=sessionStorage.getItem("pkce_verifier");
      if(saved && verifier && state===saved){
        const tok=await tokenByCode(code,verifier); saveToken(tok);
        sessionStorage.removeItem("pkce_state"); sessionStorage.removeItem("pkce_verifier");
        history.replaceState({},document.title,location.pathname); // URLの?codeを除去
      }else{
        throw new Error("State or verifier missing / mismatch");
      }
    }
    // 2) 有効トークン確認（無ければauthへ）
    await ensureToken();
    setStatus("Signed in. ①FAST Build 130（albums-first / early-stop）→ ②Trim 120 → ③Balanced 100（Pins & no-adjacent-remixer）→ ④Head-5 → ⑤Create Playlist");
  }catch(e){
    if(e && e._reauth) return; // auth.html へ遷移済
    setStatus("Boot error: "+(e.message||e));
  }
})();
</script>
</body>
</html>
