<!doctype html>
<meta charset="utf-8">
<title>Spotify — ALL with Links & Private Playlist</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<body style="font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:980px;margin:40px auto">
  <h1>Spotify Authentication</h1>
  <p id="status">Signed in. Build ALL → Create Private Playlist.</p>

  <section id="app" style="display:block">
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin:12px 0">
      <label>Groups:
        <select id="groups">
          <option value="album,single,appears_on,compilation" selected>All</option>
          <option value="album,single">Albums + Singles</option>
          <option value="appears_on,compilation">Appears/Compilations</option>
        </select>
      </label>
      <label><input type="checkbox" id="allMarkets" checked> All markets (no region filter)</label>
      <label>Market (only used when All markets is OFF):
        <select id="market">
          <option value="US" selected>US</option><option value="JP">JP</option>
          <option value="GB">GB</option><option value="DE">DE</option>
        </select>
      </label>
      <label><input type="checkbox" id="useSearch" checked> Search fallback</label>
      <label><input type="checkbox" id="noLimit" checked> No limit (ALL)</label>
      <button id="btnFetch">Build ALL with Links</button>
      <button id="btnDLhtml">Download HTML</button>
      <button id="btnDLjson">Download JSON</button>
      <button id="btnDLcsv">Download CSV</button>
    </div>

    <!-- ★ プレイリスト作成（既定は非公開） -->
    <div style="display:flex;gap:10px;flex-wrap:wrap;margin:10px 0;padding:10px;border:1px solid #ddd;border-radius:8px">
      <input id="plName"  style="min-width:320px" value="PROGAPANDA • ALL (TDCS)">
      <label><input id="plPublic" type="checkbox"> Make Public</label>
      <button id="btnCreate">Create Playlist (Private by default)</button>
      <span id="plLink"></span>
    </div>

    <ol id="tracks"></ol>
  </section>

<script>
/* ====== Config ====== */
const CLIENT_ID    = "1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI = "https://npr2025.github.io/spotify-auth/callback.html";
const ARTIST_ID    = "55fvQ5I2IZUfcFT2DV02T3"; // The Darrow Chem Syndicate
/* ==================== */

const $ = (s)=>document.querySelector(s);
const setStatus = (t)=>$("#status").textContent=t;

/* ---- PKCE token handling ---- */
function clearPkce(){ sessionStorage.removeItem("pkce_verifier"); sessionStorage.removeItem("pkce_state"); }
function saveToken(t){
  sessionStorage.setItem("sp_access_token", t.access_token);
  if (t.refresh_token) sessionStorage.setItem("sp_refresh_token", t.refresh_token);
  sessionStorage.setItem("sp_exp_at", String(Date.now() + (t.expires_in||3600)*1000));
}
function getToken(){ return {
  access: sessionStorage.getItem("sp_access_token"),
  refresh: sessionStorage.getItem("sp_refresh_token"),
  expAt: Number(sessionStorage.getItem("sp_exp_at")||0)
};}
function logoutToAuth(){ location.href="auth.html"; }
async function exchangeAuthCode(code, verifier){
  const body = new URLSearchParams({ client_id: CLIENT_ID, grant_type:"authorization_code", code, redirect_uri: REDIRECT_URI, code_verifier: verifier });
  const r = await fetch("https://accounts.spotify.com/api/token",{ method:"POST", headers:{ "Content-Type":"application/x-www-form-urlencoded" }, body });
  if(!r.ok) throw new Error("Token exchange failed: "+r.status);
  return await r.json();
}
async function refreshAccessToken(refreshToken){
  const body = new URLSearchParams({ client_id: CLIENT_ID, grant_type:"refresh_token", refresh_token: refreshToken });
  const r = await fetch("https://accounts.spotify.com/api/token",{ method:"POST", headers:{ "Content-Type":"application/x-www-form-urlencoded" }, body });
  if(!r.ok) throw new Error("Refresh failed: "+r.status);
  return await r.json();
}
async function ensureToken(){
  let {access, refresh, expAt} = getToken();
  if (access && Date.now() < expAt - 60_000) return access;
  if (refresh){ const t = await refreshAccessToken(refresh); saveToken(t); return t.access_token; }
  throw new Error("No valid token");
}

/* ---- Utils ---- */
function chunk(arr, size){ const out=[]; for(let i=0;i<arr.length;i+=size) out.push(arr.slice(i,i+size)); return out; }
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
const esc = (s)=>(''+(s??'')).replace(/"/g,'""');

/* ---- Spotify API helper with retries (429/5xx) ---- */
async function spGet(path, params={}, retry=6){
  while(true){
    const token = await ensureToken();
    const url = new URL("https://api.spotify.com/v1/" + path);
    Object.entries(params).forEach(([k,v])=>{ if(v!==undefined && v!==null && v!=="") url.searchParams.set(k,v); });
    const r = await fetch(url, { headers:{ Authorization:"Bearer "+token }});
    if (r.ok) return r.json();

    if (r.status === 401 && retry>0){ sessionStorage.removeItem("sp_access_token"); retry--; continue; }
    if ((r.status === 429 || r.status >= 500) && retry>0){
      const ra = Number(r.headers.get("retry-after"));
      const backoff = ra ? ra*1000 : (600 * (7 - retry));
      setStatus(`API ${path} ${r.status} — retry in ${Math.ceil(backoff/1000)}s`); await sleep(backoff); retry--; continue;
    }
    const txt = await r.text();
    throw new Error(`API ${path} ${r.status} ${txt.slice(0,160)}`);
  }
}

/* ---- POST/PUT helper (for playlist) ---- */
async function spReq(method, path, body=null, params={}, retry=6){
  while(true){
    const token = await ensureToken();
    const url = new URL("https://api.spotify.com/v1/" + path);
    Object.entries(params).forEach(([k,v])=>{ if(v!==undefined && v!==null && v!=="") url.searchParams.set(k,v); });
    const r = await fetch(url, {
      method,
      headers:{ Authorization:"Bearer "+token, "Content-Type":"application/json" },
      body: body ? JSON.stringify(body) : null
    });
    if (r.ok) return r.json();
    if ((r.status===429 || r.status>=500) && retry>0){
      const ra = Number(r.headers.get("retry-after"));
      const backoff = ra ? ra*1000 : (600*(7-retry));
      setStatus(`API ${method} ${path} ${r.status} — retry in ${Math.ceil(backoff/1000)}s`); await sleep(backoff); retry--; continue;
    }
    const txt = await r.text();
    throw new Error(`API ${method} ${path} ${r.status} ${txt.slice(0,160)}`);
  }
}
const spPost = (path, body, params)=>spReq("POST", path, body, params);

/* ---- Data collectors ---- */
async function fetchAllAlbums(artistId, include_groups, allMarkets, market){
  let items=[], offset=0;
  while(true){
    const params = { include_groups, limit:50, offset };
    if (!allMarkets) params.market = market; // All markets ON の時は付けない
    const page = await spGet(`artists/${artistId}/albums`, params);
    items.push(...(page.items||[]));
    if(!page.next) break;
    offset += 50;
  }
  const seen=new Set(), albums=[];
  for(const a of items){ if(!seen.has(a.id)){ seen.add(a.id); albums.push(a); } }
  return albums;
}
async function fetchAlbumTracks(albumId, allMarkets, market){
  let ids=[], offset=0;
  while(true){
    const params = { limit:50, offset };
    if (!allMarkets) params.market = market;
    const page = await spGet(`albums/${albumId}/tracks`, params);
    (page.items||[]).forEach(t=> ids.push(t.id));
    if(!page.next) break;
    offset += 50;
  }
  return ids;
}
async function fetchArtistInfo(artistId){ return spGet(`artists/${artistId}`, {}); }
async function searchArtistTrackIds(artistName, pages=12){
  const ids=new Set();
  for(let i=0;i<pages;i++){
    const res = await spGet("search", { q: `artist:"${artistName}"`, type:"track", limit:50, offset:i*50 });
    (res.tracks?.items||[]).forEach(t=> ids.add(t.id));
    if(!res.tracks?.next) break;
  }
  return [...ids];
}

/* ---- Audio features: robust ---- */
async function fetchAudioFeaturesSafe(trackIds) {
  const out = {};
  for (const batch of chunk(trackIds.filter(Boolean), 50)) {
    try {
      const data = await spGet("audio-features", { ids: batch.join(",") });
      (data.audio_features || []).forEach(f => { if (f && f.id) out[f.id] = f; });
    } catch (_) {
      for (const id of batch) {
        try {
          const f = await spGet(`audio-features/${id}`, {});
          if (f && f.id) out[f.id] = f;
        } catch { out[id] = null; }
      }
    }
  }
  return out;
}

/* ---- Builder ---- */
let lastData=[];
function toCSV(rows){
  if(!rows.length) return "";
  const head = Object.keys(rows[0]);
  const lines=[ head.join(",") ];
  for(const r of rows) lines.push(head.map(k=>`"${esc(r[k])}"`).join(","));
  return lines.join("\n");
}
function download(filename, text, mime){
  const blob = new Blob([text], {type: mime});
  const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = filename; a.click();
  URL.revokeObjectURL(a.href);
}
function htmlList(rows, title="All Tracks — TDCS"){
  const items = rows.map((r,i)=>{
    const t = `<a href="${r.track_url}" target="_blank" rel="noopener">${esc(r.name)}</a>`;
    const al = r.album_url ? ` • <a href="${r.album_url}" target="_blank" rel="noopener">${esc(r.album)}</a>` : "";
    const as = r.artist_urls ? r.artist_urls.split(" | ").map((u,j)=>`<a href="${u}" target="_blank" rel="noopener">${esc(r.artists.split(", ")[j]||"Artist")}</a>`).join(", ") : esc(r.artists);
    return `<li>${i+1}. ${t} — ${as}${al} <small>(pop:${r.popularity}${r.tempo?`, tempo:${r.tempo}`:""})</small></li>`;
  }).join("\n");
  return `<!doctype html><meta charset="utf-8"><title>${esc(title)}</title><body style="font-family:system-ui,-apple-system;max-width:900px;margin:40px auto"><h1>${esc(title)}</h1><ol>${items}</ol></body>`;
}

async function runAll(){
  try{
    setStatus("Building ALL with links…");
    const groups     = $("#groups").value || "album,single,appears_on,compilation";
    const allMarkets = $("#allMarkets").checked;
    const market     = $("#market").value || "US";
    const useSearch  = $("#useSearch").checked;

    // 1) 全アルバム収集
    const albums = await fetchAllAlbums(ARTIST_ID, groups, allMarkets, market);
    setStatus(`Collecting tracks from ${albums.length} albums…`);

    // 2) 各アルバムの全曲ID
    let trackIds=[];
    for(const batch of chunk(albums, 10)){
      const results = await Promise.all(batch.map(a=>fetchAlbumTracks(a.id, allMarkets, market).catch(()=>[])));
      results.forEach(ids=> trackIds.push(...ids));
    }

    // 3) 検索補完
    if(useSearch){
      setStatus("Searching tracks for fallback…");
      const artist = await fetchArtistInfo(ARTIST_ID);
      const fromSearch = await searchArtistTrackIds(artist.name, 12);
      trackIds.push(...fromSearch);
    }

    // 4) 重複排除
    trackIds = [...new Set(trackIds)];

    // 5) 詳細取得 → popularity 降順（ALL）
    setStatus(`Fetching track details (${trackIds.length})…`);
    let tracks=[];
    for(const ids of chunk(trackIds, 50)){
      const data = await spGet("tracks", { ids: ids.join(",") });
      tracks.push(...(data.tracks||[]));
    }
    tracks = tracks.filter(Boolean).sort((a,b)=>(b.popularity||0)-(a.popularity||0));

    // 6) audio-features（失敗しても続行）
    setStatus("Fetching audio features…");
    let featById = {};
    try { featById = await fetchAudioFeaturesSafe(tracks.map(t=>t.id)); }
    catch(e){ setStatus("audio-features skipped: "+(e.message||e)); featById = {}; }

    // 7) 整形（リンク含む）
    lastData = tracks.map(t=>{
      const f = featById[t.id] || {};
      const artistNames = t.artists.map(a=>a.name).join(", ");
      const artistUrls  = t.artists.map(a=> (a.external_urls&&a.external_urls.spotify)||"").filter(Boolean).join(" | ");
      const trackUrl    = (t.external_urls&&t.external_urls.spotify) || `https://open.spotify.com/track/${t.id}`;
      const albumUrl    = (t.album&&t.album.external_urls&&t.album.external_urls.spotify) || "";
      const avail = Array.isArray(t.available_markets) ? t.available_markets.length
                   : (t.album && Array.isArray(t.album.available_markets) ? t.album.available_markets.length : "");
      return {
        id: t.id,
        name: t.name,
        artists: artistNames,
        artist_urls: artistUrls,
        popularity: t.popularity,
        isrc: (t.external_ids||{}).isrc || "",
        preview_url: t.preview_url || "",
        track_url: trackUrl,
        album: (t.album||{}).name || "",
        album_url: albumUrl,
        release_date: (t.album||{}).release_date || "",
        available_markets_count: avail,
        duration_ms: t.duration_ms,
        tempo: f.tempo ?? "",
        energy: f.energy ?? "",
        danceability: f.danceability ?? "",
        valence: f.valence ?? "",
        loudness: f.loudness ?? ""
      };
    });

    // 8) 表示（曲名リンク）
    const ol = $("#tracks"); ol.innerHTML="";
    lastData.forEach((r,i)=>{
      const li=document.createElement("li");
      const a=document.createElement("a");
      a.href=r.track_url; a.textContent=r.name; a.target="_blank"; a.rel="noopener";
      li.append(`${i+1}. `); li.append(a); li.append(` — ${r.artists} (pop:${r.popularity}${r.tempo?`, tempo:${r.tempo}`:""})`);
      ol.appendChild(li);
    });
    setStatus(`Loaded ${lastData.length} tracks (ALL)`);
  }catch(e){
    setStatus(e.message||String(e));
  }
}

/* ---- Downloads ---- */
document.getElementById("btnDLhtml").onclick = ()=> lastData.length &&
  download("spotify_all_with_links.html", htmlList(lastData), "text/html");
document.getElementById("btnDLjson").onclick = ()=> lastData.length &&
  download("spotify_all_with_links.json", JSON.stringify(lastData, null, 2), "application/json");
document.getElementById("btnDLcsv").onclick  = ()=> lastData.length &&
  download("spotify_all_with_links.csv",  toCSV(lastData), "text/csv");

/* ---- Playlist (非公開が既定) ---- */
async function getMe(){ return spGet("me", {}); }
async function createPlaylist(name, description, isPublic){
  const me = await getMe();
  return spPost(`users/${me.id}/playlists`, { name, description, public: !!isPublic });
}
async function addTracksToPlaylist(playlistId, trackIds){
  const uris = [...new Set(trackIds)].filter(Boolean).map(id=>`spotify:track:${id}`);
  for (const batch of chunk(uris, 100)){
    await spPost(`playlists/${playlistId}/tracks`, { uris: batch });
    await sleep(250);
  }
}
document.getElementById("btnCreate").onclick = async ()=>{
  try{
    if(!lastData.length){ setStatus("先に Build ALL を実行して曲を集めてね"); return; }
    const name = $("#plName").value || "TDCS — ALL";
    const isPublic = $("#plPublic").checked; // 既定はfalse（非公開）
    setStatus(`Creating ${isPublic?"public":"private"} playlist…`);
    const pl = await createPlaylist(name, "Auto-built from TDCS discography (all markets).", isPublic);
    setStatus("Adding tracks…");
    await addTracksToPlaylist(pl.id, lastData.map(x=>x.id));
    const url = (pl.external_urls && pl.external_urls.spotify) || `https://open.spotify.com/playlist/${pl.id}`;
    $("#plLink").innerHTML = `<a href="${url}" target="_blank" rel="noopener">Open playlist</a>`;
    setStatus(`Done — ${lastData.length} tracks added (${isPublic?"public":"private"}).`);
  }catch(e){ setStatus("Playlist error: " + (e.message||e)); }
};

/* ---- Boot: PKCE callback ---- */
(async function init(){
  const qp = new URLSearchParams(location.search);
  const code = qp.get("code"); const state = qp.get("state");
  if(code){
    const savedState = sessionStorage.getItem("pkce_state");
    const verifier   = sessionStorage.getItem("pkce_verifier");
    if(!verifier || !savedState || state!==savedState){ setStatus("State/Verifier mismatch. Start from auth.html"); return; }
    try {
      const tok = await exchangeAuthCode(code, verifier);
      clearPkce(); history.replaceState({}, document.title, location.pathname);
      saveToken(tok);
    } catch(e){ setStatus(e.message); return; }
  }
  document.getElementById("btnFetch").onclick = ()=>runAll();
})();
</script>
</body>
</html>
