<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TDCS Full Tracks Harvester — Ultra Ultra Safe</title>
<link rel="preconnect" href="https://accounts.spotify.com"/>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans JP';margin:2rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;margin-bottom:1rem}
  .row{display:flex;flex-wrap:wrap;gap:1rem;align-items:center}
  button{padding:.6rem 1rem;border-radius:8px;border:1px solid #999;background:#111;color:#fff;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=file]{border:1px dashed #bbb;padding:.75rem;border-radius:8px;background:#fafafa}
  code,.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace}
  .muted{color:#666}.ok{color:#0a7f29}.bad{color:#b00020}
  progress{width:100%;height:14px}
  table{border-collapse:collapse;width:100%}th,td{border:1px solid #eee;padding:.5rem;font-size:.9rem;text-align:left}
  .pill{display:inline-block;padding:.1rem .5rem;border:1px solid #ccc;border-radius:999px;font-size:.8rem;background:#f6f6f6}
  .small{font-size:.85rem}
</style>
</head>
<body>
<header class="card">
  <h1>TDCS Full Tracks Harvester — Ultra Ultra Safe</h1>
  <div class="small muted">Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> | Redirect: <code>https://npr2025.github.io/spotify-auth/callback.html</code></div>
  <div class="row">
    <a href="./auth.html"><button>Spotifyに接続</button></a>
    <span id="authStatus" class="muted">未接続</span>
  </div>
</header>

<section class="card">
  <h2>入力と実行設定</h2>
  <div class="row">
    <input type="file" id="csvFile" accept=".csv"/>
    <label>最小間隔(ms)：<input id="minDelayMs" type="number" value="4000" step="50" style="width:7rem"></label>
    <label>RPM上限(1分)：<input id="rpmCap" type="number" value="5" step="1" style="width:5rem"></label>
    <label>1時間予算(req)：<input id="hourBudget" type="number" value="300" step="50" style="width:6rem"></label>
    <label>最大バックオフ(ms)：<input id="maxBackoffMs" type="number" value="30000" step="500" style="width:7rem"></label>
    <label>最大リトライ：<input id="maxRetries" type="number" value="9" step="1" style="width:5rem"></label>
    <label>429ロングCD(ms)：<input id="cooldownMs" type="number" value="600000" step="60000" style="width:8rem"></label>
  </div>
  <div class="row">
    <label>アルバムバッチ間隔(ms)：<input id="batchPauseMs" type="number" value="1500" step="100" style="width:7rem"></label>
    <label>トラックページ間隔(ms)：<input id="pagePauseMs" type="number" value="400" step="50" style="width:6rem"></label>
    <label>tracks?ids バッチ(≤50)：<input id="trkBatch" type="number" value="20" min="1" max="50" step="1" style="width:5rem"></label>
    <label>albums?ids バッチ(≤20)：<input id="albBatch" type="number" value="20" min="1" max="20" step="1" style="width:5rem"></label>
    <label>ロングブレイク：<input id="longBreakEvery" type="number" value="120" step="10" style="width:5rem"> req毎 / <input id="longBreakMs" type="number" value="300000" step="60000" style="width:7rem"> ms</label>
    <label><input id="slowJitter" type="checkbox" checked> ジッターON</label>
    <label><input id="emergencyMode" type="checkbox" checked> エマージェンシー自動化</label>
    <label>エマージェンシー間隔(ms)：<input id="emgPerReqMs" type="number" value="30000" step="1000" style="width:7rem"></label>
  </div>
  <div class="row">
    <label><input id="scanAllTracks" type="checkbox" checked> 全アルバムでトラック走査（フル）</label>
    <button id="startBtn" disabled>開始</button>
    <button id="pauseBtn" disabled>一時停止</button>
    <button id="resumeBtn" disabled>再開</button>
    <button id="clearChkBtn">チェックポイント削除</button>
  </div>
  <div id="fileInfo" class="small muted"></div>
  <div class="small muted">対応列：<code>spotify_url / UPC / ISRC / Album title / Album version / Track title</code></div>
</section>

<section class="card">
  <h2>進捗 <span id="ratePill" class="pill">idle</span></h2>
  <progress id="prog" value="0" max="100"></progress>
  <div id="log" class="mono" style="white-space:pre-wrap;max-height:260px;overflow:auto"></div>
</section>

<section class="card">
  <h2>エクスポート</h2>
  <div class="row">
    <button id="downloadTracksBtn" disabled>フルトラックCSV</button>
    <button id="downloadCheckpointBtn" disabled>チェックポイントCSV</button>
  </div>
  <div class="small muted">
    列：<code>
    album_id,album_url,album_name,album_type,album_artists,album_artist_ids,album_upc,release_date,release_date_precision,
    track_id,track_uri,track_url,track_name,disc_number,track_number,duration_ms,explicit,is_playable,preview_url,
    isrc,track_artists_names,track_artists_ids,track_artists_non_tdcs,contains_tdcs
    </code>
  </div>
</section>

<section class="card">
  <h2>プレビュー（10行）</h2>
  <table id="previewTbl"><thead></thead><tbody></tbody></table>
</section>

<script>
/*** 基本 ***/
const TARGET_ARTIST_ID="55fvQ5I2IZUfcFT2DV02T3";
const CHECKPOINT_KEY="tdcs_fulltracks_checkpoint_v2";
const $=s=>document.querySelector(s);
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const jitter=v=> ($("#slowJitter").checked? v+Math.floor(Math.random()*Math.floor(v*0.2)) : v);
function log(m){ const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function setRate(t){ $("#ratePill").textContent=t; }
function token(){ const raw=localStorage.getItem('sp_token'); if(!raw) return null; try{const o=JSON.parse(raw); if(Date.now()<o.expires_at) return o.access_token;}catch{} return null;}
function setAuthStatus(ok,txt){ const el=$("#authStatus"); el.textContent=txt; el.className=ok?'ok':'bad'; }
function rowsToCSV(rows){ if(!rows.length) return ''; const H=Object.keys(rows[0]); const esc=v=>(v==null?'':'"'+String(v).replace(/"/g,'""')+'"'); return [H.map(esc).join(','),...rows.map(r=>H.map(h=>esc(r[h])).join(','))].join('\r\n');}
function setPreview(rows){ const thead=$("#previewTbl thead"), tbody=$("#previewTbl tbody"); thead.innerHTML=''; tbody.innerHTML=''; const samp=rows.slice(0,10); if(!samp.length) return; const H=Object.keys(samp[0]); const tr=document.createElement('tr'); H.forEach(h=>{const th=document.createElement('th'); th.textContent=h; tr.appendChild(th)}); thead.appendChild(tr); samp.forEach(r=>{const trb=document.createElement('tr'); H.forEach(h=>{const td=document.createElement('td'); td.textContent=(r[h]==null?'':r[h]); trb.appendChild(td)}); tbody.appendChild(trb)})}

/*** CSV 列検出 ***/
function detectCols(header){
  const lc=header.map(h=>String(h||'').toLowerCase());
  const pick=(...c)=>{ for(const x of c){ const i=lc.indexOf(String(x).toLowerCase()); if(i>-1) return header[i]; } return null; };
  return { url: pick('spotify_url','url','link'),
           upc: pick('upc','UPC'),
           isrc: pick('isrc','ISRC'),
           album: pick('album title','album'),
           version: pick('album version','version'),
           track: pick('track title','track') };
}
function parseSpotifyUrl(u){ try{ const m=u.match(/open\.spotify\.com\/(album|track)\/([A-Za-z0-9]+)/); if(m) return {type:m[1], id:m[2]}; }catch(e){} return null; }

/*** 時間窓レート制御 + 適応ダイヤルダウン ***/
let lastCall=0, consec429=0, globalCooldownUntil=0, paused=false;
const reqTimestamps=[]; // 過去1時間のリクエスト時刻(ms)
let reqCountSinceBreak=0;

async function api(path, params={}){
  const tkn=token(); if(!tkn) throw new Error('No token');

  let minDelay=+$("#minDelayMs").value||4000;
  const maxBackoff=+$("#maxBackoffMs").value||30000;
  const maxRetries=+$("#maxRetries").value||9;
  let rpmCap=+$("#rpmCap").value||5;
  const cooldownBase=+$("#cooldownMs").value||600000; // 10分
  const hourBudget=+$("#hourBudget").value||300; // 1時間の最大リクエスト
  const longEvery=+$("#longBreakEvery").value||120;
  const longMs=+$("#longBreakMs").value||300000;
  const emergencyOn=$("#emergencyMode").checked;
  const emgPerReq=+$("#emgPerReqMs").value||30000;

  // 1h 窓の古いタイムスタンプ掃除
  const now=Date.now();
  while(reqTimestamps.length && (now - reqTimestamps[0]) > 3600_000) reqTimestamps.shift();

  // 時間窓予算が埋まっていたら窓が空くまで待つ
  while(reqTimestamps.length >= hourBudget){
    const until = reqTimestamps[0] + 3600_000;
    const wait = Math.max(1000, until - Date.now());
    setRate(`hour cap wait ${wait}ms`);
    await sleep(wait);
    const n=Date.now();
    while(reqTimestamps.length && (n - reqTimestamps[0]) > 3600_000) reqTimestamps.shift();
  }

  // RPMゲート
  const perReqMs=Math.max(1000, Math.ceil(60000/Math.max(1,rpmCap)));
  // エマージェンシー（連続429で自動）
  const enforcedGap = (consec429>=4 && emergencyOn) ? Math.max(perReqMs, emgPerReq) : perReqMs;

  // グローバルCD
  if(Date.now()<globalCooldownUntil){
    const w=globalCooldownUntil-Date.now(); setRate('GLOBAL cooldown '+w+'ms'); await sleep(w);
  }

  // 長めの小休止（定期）
  if(longEvery>0 && reqCountSinceBreak>0 && (reqCountSinceBreak % longEvery===0)){
    setRate('long break '+longMs+'ms'); log('long break '+longMs+'ms');
    await sleep(jitter(longMs));
  }

  // RPM spacing
  const wait=Math.max(0, lastCall+enforcedGap - Date.now());
  if(wait>0){ setRate('rpm gate '+wait+'ms'); await sleep(wait); }
  lastCall=Date.now();

  // URL作成
  const url=new URL('https://api.spotify.com'+path);
  Object.entries(params).forEach(([k,v])=> v!=null && url.searchParams.set(k,v));

  let backoff=minDelay, attempt=0;
  while(true){
    if(paused){ setRate('paused'); await sleep(500); continue; }

    attempt++;

    // 発火
    let res, text;
    try{
      res=await fetch(url,{headers:{Authorization:'Bearer '+tkn}});
      text=await res.text();
      reqTimestamps.push(Date.now());
      reqCountSinceBreak++;
    }catch(e){
      if(attempt>maxRetries) throw new Error('Network error after retries: '+(e.message||e));
      const d=Math.min(backoff, maxBackoff);
      log('net err → '+d+'ms'); await sleep(d); backoff=Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    if(res.ok && res.status!==429){
      consec429=0;
      const left=minDelay-(Date.now()-lastCall); if(left>0){ setRate('throttle '+left+'ms'); await sleep(left); }
      setRate('ok');
      try{return JSON.parse(text);}catch{return text;}
    }

    // 429/5xx ハンドリング
    let body; try{body=JSON.parse(text);}catch{body=text;}

    if(res.status===429){
      consec429++;
      const ra=parseFloat(res.headers.get('Retry-After')||'0'); // sec
      let delay = ra? ra*1000 : backoff;

      // ダイヤルダウン
      if(!ra){
        // 連続段数に応じて厳しく
        // 1) レートを下げる
        rpmCap = Math.max(2, Math.floor(rpmCap*0.7));
        $("#rpmCap").value = rpmCap;
        // 2) 待機を増やす
        minDelay = Math.min(maxBackoff, Math.floor(minDelay*1.3));
        $("#minDelayMs").value = minDelay;
        // 3) ページ/バッチを重く→軽く
        const curPage=+$("#pagePauseMs").value||400;
        $("#pagePauseMs").value = Math.floor(curPage*1.3);
        const curBatch=+$("#trkBatch").value||20;
        $("#trkBatch").value = Math.max(10, Math.floor(curBatch*0.8));

        log(`429 x${consec429} → rpmCap=${rpmCap}, minDelay=${minDelay}ms, pagePause=${$("#pagePauseMs").value}ms, trkBatch=${$("#trkBatch").value}`);
      }

      // ロングCD（窓リセット）
      if(consec429>=3){
        const hard = Math.max(delay, +$("#cooldownMs").value||600000);
        globalCooldownUntil = Date.now() + hard;
        log(`HARD cooldown ${hard}ms`);
        setRate('HARD cooldown '+hard+'ms');
        await sleep(hard);
      }else{
        delay = Math.min(delay, maxBackoff);
        log('429 backoff '+delay+'ms'); setRate('429 wait '+delay+'ms'); await sleep(delay);
      }
      backoff=Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    if(res.status>=500 && res.status<600){
      if(attempt>maxRetries) throw new Error('HTTP '+res.status+' after '+attempt+' attempts');
      const d=Math.min(backoff, maxBackoff);
      log(res.status+' → retry '+d+'ms'); setRate(res.status+' wait '+d+'ms'); await sleep(d);
      backoff=Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    throw new Error('HTTP '+res.status+': '+(typeof body==='string'?body:JSON.stringify(body)));
  }
}

/*** 参照キャッシュ ***/
const upcCache=new Map(), isrcCache=new Map(), albumMetaCache=new Map();

/*** 検索補助 ***/
async function findByUPC(upc){
  if(!upc) return null; if(upcCache.has(upc)) return upcCache.get(upc);
  const res=await api('/v1/search',{q:'upc:'+upc, type:'album', limit:1});
  let out=null; if(res.albums?.items?.length){ const a=res.albums.items[0]; out={albumId:a.id, url:a.external_urls.spotify}; }
  upcCache.set(upc,out); return out;
}
async function findByISRC(isrc){
  if(!isrc) return null; if(isrcCache.has(isrc)) return isrcCache.get(isrc);
  const res=await api('/v1/search',{q:'isrc:'+isrc, type:'track', limit:1});
  let out=null; if(res.tracks?.items?.length){ const t=res.tracks.items[0]; out={trackId:t.id, albumId:t.album.id, url:t.external_urls.spotify, albumUrl:t.album.external_urls.spotify}; }
  isrcCache.set(isrc,out); return out;
}
async function findByText(row,cols){
  const parts=[]; if(cols.album && row[cols.album]) parts.push('album:"'+String(row[cols.album]).trim()+'"');
  parts.push('artist:"The Darrow Chem Syndicate"'); if(cols.version && row[cols.version]) parts.push('"'+String(row[cols.version]).trim()+'"');
  const res=await api('/v1/search',{q:parts.join(' '), type:'album', limit:1});
  if(res.albums?.items?.length){ const a=res.albums.items[0]; return {albumId:a.id, url:a.external_urls.spotify}; }
  return null;
}

/*** 入力CSV処理 ***/
let _rows=[], _cols={}, _outTracks=[], _albumMap=new Map(), _albumOrder=[];
let _nextAlbumIdx=0;

$("#csvFile").addEventListener('change', ev=>{
  const f=ev.target.files[0]; if(!f) return;
  $("#fileInfo").textContent = `${f.name} / ${(f.size/1024).toFixed(1)} KB`;
  Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{
    _rows=res.data||[]; _cols=detectCols(res.meta.fields||[]);
    $("#startBtn").disabled=false;
    log('CSV loaded: '+_rows.length+' rows');
    log('Detected columns: '+JSON.stringify(_cols));
  }});
});

/*** key resolve ***/
function keyForRow(row){
  if(_cols.url && row[_cols.url]){ const u=String(row[_cols.url]).trim(); const p=parseSpotifyUrl(u); if(p) return (p.type==='album'?'album:':'track:')+p.id; }
  if(_cols.upc && row[_cols.upc]) return 'upc:'+String(row[_cols.upc]).trim();
  if(_cols.isrc && row[_cols.isrc]) return 'isrc:'+String(row[_cols.isrc]).trim();
  const a=(_cols.album&&row[_cols.album])? String(row[_cols.album]).trim() : '';
  const v=(_cols.version&&row[_cols.version])? String(row[_cols.version]).trim() : '';
  return 'text:'+a+'|'+v;
}

/*** albums?ids（UPC/メタ含む） ***/
async function batchGetAlbums(ids){
  const size=Math.min(20, Math.max(1, +$("#albBatch").value||20));
  const chunks=[]; for(let i=0;i<ids.length;i+=size) chunks.push(ids.slice(i,i+size));
  const meta=new Map();
  const pause=+$("#batchPauseMs").value||1500;
  for(const ch of chunks){
    const res=await api('/v1/albums',{ids:ch.join(',')});
    (res.albums||[]).forEach(a=>{
      meta.set(a.id,{
        album_type:a.album_type,
        album_artists:(a.artists||[]).map(x=>({id:x.id,name:x.name})),
        album_name:a.name||'',
        release_date:a.release_date||'',
        release_date_precision:a.release_date_precision||'',
        upc:(a.external_ids&&a.external_ids.upc)||''
      });
    });
    await sleep(jitter(pause));
  }
  return meta;
}

/*** 1アルバム：tracks一覧 → tracks?ids で完全取得 ***/
async function harvestAlbumTracksFull(albumId, albumMeta, albumUrl){
  // tracks一覧（paging）
  let items=[], offset=0, limit=50, page;
  const pagePause=+$("#pagePauseMs").value||400;
  do{
    page=await api(`/v1/albums/${albumId}/tracks`,{limit, offset});
    items=items.concat(page.items||[]); offset+=limit;
    await sleep(jitter(pagePause));
  }while(page && page.next);

  // tracks?ids でフル
  const ids=items.map(t=>t.id).filter(Boolean);
  const bsize=Math.min(50, Math.max(1, +$("#trkBatch").value||20));
  const fullMap=new Map();
  for(let i=0;i<ids.length;i+=bsize){
    const slice=ids.slice(i,i+bsize);
    const res=await api('/v1/tracks',{ids:slice.join(',')});
    (res.tracks||[]).forEach(t=>{ if(t) fullMap.set(t.id,t); });
    await sleep(jitter(250));
  }

  // rows 作成
  const rows=[];
  for(const simp of items){
    const t=fullMap.get(simp.id)||{};
    const tArtists=(t.artists||simp.artists||[]).map(x=>({id:x.id,name:x.name}));
    const containsTDCS=tArtists.some(a=>a.id===TARGET_ARTIST_ID);
    const nonTDCS=tArtists.filter(a=>a.id!==TARGET_ARTIST_ID).map(a=>a.name);
    rows.push({
      album_id: albumId,
      album_url: albumUrl || ('https://open.spotify.com/album/'+albumId),
      album_name: albumMeta.album_name||'',
      album_type: albumMeta.album_type||'',
      album_artists: (albumMeta.album_artists||[]).map(a=>a.name).join(' ; '),
      album_artist_ids: (albumMeta.album_artists||[]).map(a=>a.id).join(' ; '),
      album_upc: albumMeta.upc||'',
      release_date: albumMeta.release_date||'',
      release_date_precision: albumMeta.release_date_precision||'',
      track_id: simp.id||'',
      track_uri: simp.id? ('spotify:track:'+simp.id):'',
      track_url: simp.id? ('https://open.spotify.com/track/'+simp.id):'',
      track_name: t.name || simp.name || '',
      disc_number: t.disc_number ?? simp.disc_number ?? '',
      track_number: t.track_number ?? simp.track_number ?? '',
      duration_ms: t.duration_ms ?? '',
      explicit: t.explicit ?? '',
      is_playable: t.is_playable ?? '',
      preview_url: t.preview_url ?? '',
      isrc: (t.external_ids&&t.external_ids.isrc) || '',
      track_artists_names: tArtists.map(a=>a.name).join(' ; '),
      track_artists_ids: tArtists.map(a=>a.id).join(' ; '),
      track_artists_non_tdcs: nonTDCS.join(' ; '),
      contains_tdcs: containsTDCS ? '1':'0'
    });
  }
  return rows;
}

/*** チェックポイント ***/
function saveCheckpoint(state){ try{ localStorage.setItem(CHECKPOINT_KEY, JSON.stringify(state)); }catch(e){} }
function loadCheckpoint(){ try{ const raw=localStorage.getItem(CHECKPOINT_KEY); return raw? JSON.parse(raw): null; }catch(e){ return null; } }
function clearCheckpoint(){ localStorage.removeItem(CHECKPOINT_KEY); }

/*** フロー ***/
let _outTracks=[], _albumMap=new Map(), _albumOrder=[], _cols={}, _rows=[];
let _nextAlbumIdx=0;

$("#startBtn").addEventListener('click', ()=> run(true));
$("#resumeBtn").addEventListener('click', ()=> run(false));
$("#pauseBtn").addEventListener('click', ()=> { paused=true; setRate('paused'); });
$("#clearChkBtn").addEventListener('click', ()=> { clearCheckpoint(); log('checkpoint cleared'); });

$("#downloadCheckpointBtn").addEventListener('click', ()=>{
  if(!_outTracks.length){ alert('まだ出力がありません'); return; }
  const csv=rowsToCSV(_outTracks);
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download='tdcs_full_tracks_checkpoint.csv';
  document.body.appendChild(a); a.click(); a.remove();
});

async function run(fresh){
  const t=token(); if(!t){ alert('先にSpotify認証'); return; }
  $("#pauseBtn").disabled=false; $("#resumeBtn").disabled=false;

  const prog=$("#prog"); prog.max=100; prog.value=0;
  paused=false;

  if(fresh){
    // unique keys
    const seen=new Set(); _albumMap.clear(); _albumOrder.length=0; _outTracks.length=0; _nextAlbumIdx=0;
    for(const row of _rows){ const k=keyForRow(row); if(seen.has(k)) continue; seen.add(k); _albumOrder.push(k); }
    log('Unique keys: '+_albumOrder.length);

    // resolve
    for(let i=0;i<_albumOrder.length;i++){
      if(paused){ await sleep(300); i--; continue; }
      const k=_albumOrder[i];
      try{
        let albumId=null, url='';
        if(k.startsWith('album:')){ albumId=k.split(':')[1]; url='https://open.spotify.com/album/'+albumId; }
        else if(k.startsWith('track:')){ const trackId=k.split(':')[1]; const tr=await api('/v1/tracks/'+trackId); albumId=tr.album.id; url=tr.album.external_urls.spotify; }
        else if(k.startsWith('upc:')){ const r=await findByUPC(k.slice(4)); if(r){albumId=r.albumId; url=r.url;} }
        else if(k.startsWith('isrc:')){ const r=await findByISRC(k.slice(5)); if(r){albumId=r.albumId; url=r.albumUrl||r.url;} }
        else { const [a,v]=k.slice(5).split('|'); const dummy={}; dummy[_cols.album]=a; dummy[_cols.version]=v; const r=await findByText(dummy,_cols); if(r){albumId=r.albumId; url=r.url;} }
        if(albumId){ _albumMap.set(k,{albumId,url}); }
      }catch(e){ log('Resolve err: '+k+' → '+(e.message||e)); }
      if((i+1)%20===0){ setRate(`resolve ${i+1}/${_albumOrder.length}`); }
    }
    log('Unique albums to audit: '+ new Set([..._albumMap.values()].map(v=>v.albumId)).size);

    // batch album meta
    const albumIds=[...new Set([..._albumMap.values()].map(v=>v.albumId))].filter(Boolean);
    const metaMap = await batchGetAlbums(albumIds);
    albumIds.forEach(id=>{ if(metaMap.has(id)) albumMetaCache.set(id, metaMap.get(id)); });

    saveCheckpoint({ step:'metaDone', albumOrder:_albumOrder, albumMap:[..._albumMap.entries()], nextAlbumIdx:0, outRows:_outTracks.length });
  } else {
    const cp=loadCheckpoint();
    if(!cp || !cp.albumOrder){ log('no checkpoint to resume'); return; }
    _albumOrder = cp.albumOrder;
    _albumMap = new Map(cp.albumMap);
    _nextAlbumIdx = cp.nextAlbumIdx||0;
    log('resumed from album index: '+_nextAlbumIdx);
  }

  // full tracks per album
  for(let i=_nextAlbumIdx; i<_albumOrder.length; i++){
    if(paused){ await sleep(300); i--; continue; }
    const k=_albumOrder[i];
    const res=_albumMap.get(k); if(!res || !res.albumId) continue;
    const albumId=res.albumId, albumUrl=res.url;
    try{
      const meta = albumMetaCache.get(albumId) || {album_type:'',album_artists:[],album_name:'',release_date:'',release_date_precision:'',upc:''};
      const rows = await harvestAlbumTracksFull(albumId, meta, albumUrl);
      _outTracks.push(...rows);

      // checkpoint per album
      saveCheckpoint({ step:'tracks', albumOrder:_albumOrder, albumMap:[..._albumMap.entries()], nextAlbumIdx:i+1, outRows:_outTracks.length });

      // UI
      setPreview(_outTracks);
      $("#downloadCheckpointBtn").disabled=false;
      setRate(`album ${i+1}/${_albumOrder.length} (tracks ${_outTracks.length})`);
      const p = Math.round(((i+1)/_albumOrder.length)*100); $("#prog").value=p;

      // album間の小休止
      await sleep(jitter(600));
    }catch(e){
      log(`Album ${albumId} error → ${e.message||e}`);
    }
  }

  // export
  const csv=rowsToCSV(_outTracks);
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
  const url=URL.createObjectURL(blob);
  const btn=$("#downloadTracksBtn");
  btn.onclick=()=>{ const a=document.createElement('a'); a.href=url; a.download='tdcs_full_tracks.csv'; document.body.appendChild(a); a.click(); a.remove(); };
  btn.disabled=false;
  setPreview(_outTracks);
  log('Done (tracks='+_outTracks.length+').');
}

/*** CSV load → start ***/
$("#resumeBtn").disabled = !loadCheckpoint();
$("#csvFile").addEventListener('change', ev=>{
  const f=ev.target.files[0]; if(!f) return;
  $("#fileInfo").textContent = `${f.name} / ${(f.size/1024).toFixed(1)} KB`;
  Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{
    _rows=res.data||[]; _cols=detectCols(res.meta.fields||[]);
    $("#startBtn").disabled=false;
    log('CSV loaded: '+_rows.length+' rows');
    log('Detected columns: '+JSON.stringify(_cols));
  }});
});

/*** init ***/
(function(){
  const t=token(); setAuthStatus(!!t, t?'トークンOK（有効）':'未接続');
})();
</script>
</body>
</html>