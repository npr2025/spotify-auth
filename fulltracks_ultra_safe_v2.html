<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TDCS Full Tracks Harvester — Ultra Ultra Safe v2 (no-search)</title>
<link rel="preconnect" href="https://accounts.spotify.com"/>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans JP';margin:2rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;margin-bottom:1rem}
  .row{display:flex;flex-wrap:wrap;gap:1rem;align-items:center}
  button{padding:.6rem 1rem;border-radius:8px;border:1px solid #999;background:#111;color:#fff;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=file]{border:1px dashed #bbb;padding:.75rem;border-radius:8px;background:#fafafa}
  code,.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace}
  .muted{color:#666}.ok{color:#0a7f29}.bad{color:#b00020}
  progress{width:100%;height:14px}
  table{border-collapse:collapse;width:100%}th,td{border:1px solid #eee;padding:.5rem;font-size:.9rem;text-align:left}
  .pill{display:inline-block;padding:.1rem .5rem;border:1px solid #ccc;border-radius:999px;font-size:.8rem;background:#f6f6f6}
  .small{font-size:.85rem}
</style>
</head>
<body>
<header class="card">
  <h1>TDCS Full Tracks Harvester — Ultra Ultra Safe v2</h1>
  <div class="small muted">Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> | Redirect: <code>https://npr2025.github.io/spotify-auth/callback.html</code></div>
  <div class="row">
    <a href="./auth.html?v=20250919-3"><button>Spotifyに接続</button></a>
    <button id="clearBtn" style="background:#eee;color:#111;border-color:#bbb">保存トークン削除</button>
    <span id="authStatus" class="muted">未接続</span>
  </div>
</header>

<section class="card">
  <h2>入力と実行設定</h2>
  <div class="row">
    <input type="file" id="csvFile" accept=".csv"/>
    <label>最小間隔(ms)：<input id="minDelayMs" type="number" value="3200" step="50" style="width:7rem"></label>
    <label>RPM上限(1分)：<input id="rpmCap" type="number" value="8" step="1" style="width:5rem"></label>
    <label>1時間予算(req)：<input id="hourBudget" type="number" value="600" step="50" style="width:6rem"></label>
    <label>最大バックオフ(ms)：<input id="maxBackoffMs" type="number" value="30000" step="500" style="width:7rem"></label>
    <label>最大リトライ：<input id="maxRetries" type="number" value="6" step="1" style="width:5rem"></label>
    <label>429上限(ms)：<input id="cooldownCapMs" type="number" value="120000" step="10000" style="width:8rem"></label>
  </div>
  <div class="row">
    <label>アルバムバッチ間隔(ms)：<input id="batchPauseMs" type="number" value="1200" step="100" style="width:7rem"></label>
    <label>トラックページ間隔(ms)：<input id="pagePauseMs" type="number" value="300" step="50" style="width:6rem"></label>
    <label>tracks?ids バッチ(≤50)：<input id="trkBatch" type="number" value="40" min="1" max="50" step="1" style="width:5rem"></label>
    <label>albums?ids バッチ(≤20)：<input id="albBatch" type="number" value="20" min="1" max="20" step="1" style="width:5rem"></label>
    <label>ロングブレイク：<input id="longBreakEvery" type="number" value="160" step="10" style="width:5rem"> req毎 / <input id="longBreakMs" type="number" value="240000" step="60000" style="width:7rem"> ms</label>
    <label><input id="slowJitter" type="checkbox" checked> ジッターON</label>
    <label><input id="strictNoSearch" type="checkbox" checked> search完全禁止</label>
  </div>
  <div class="row">
    <label><input id="scanAllTracks" type="checkbox" checked> 全アルバムでトラック走査（フル）</label>
    <button id="startBtn" disabled>開始</button>
    <button id="pauseBtn" disabled>一時停止</button>
    <button id="resumeBtn" disabled>再開</button>
    <button id="clearChkBtn">チェックポイント削除</button>
    <button id="diagBtn" style="background:#0a7f29;border-color:#0a7f29">接続診断</button>
  </div>
  <div id="fileInfo" class="small muted"></div>
  <div class="small muted">対応列：<code>spotify_url / UPC / ISRC / Album title / Album version / Track title</code></div>
</section>

<section class="card">
  <h2>カタログ・インデックス <span id="indexPill" class="pill">idle</span></h2>
  <div id="indexLog" class="mono small" style="white-space:pre-wrap;max-height:160px;overflow:auto"></div>
</section>

<section class="card">
  <h2>進捗 <span id="ratePill" class="pill">idle</span></h2>
  <progress id="prog" value="0" max="100"></progress>
  <div id="log" class="mono" style="white-space:pre-wrap;max-height:260px;overflow:auto"></div>
</section>

<section class="card">
  <h2>エクスポート</h2>
  <div class="row">
    <button id="downloadTracksBtn" disabled>フルトラックCSV</button>
    <button id="downloadCheckpointBtn" disabled>チェックポイントCSV</button>
  </div>
</section>

<section class="card">
  <h2>プレビュー（10行）</h2>
  <table id="previewTbl"><thead></thead><tbody></tbody></table>
</section>

<script>
const TARGET_ARTIST_ID="55fvQ5I2IZUfcFT2DV02T3";
const CHECKPOINT_KEY="tdcs_fulltracks_checkpoint_v2";

const $=s=>document.querySelector(s);
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const jitter=v=> ($("#slowJitter").checked? v+Math.floor(Math.random()*Math.floor(v*0.2)) : v);
function log(m){ const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function ilog(m){ const el=$("#indexLog"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function setRate(t){ $("#ratePill").textContent=t; }
function setIndexState(t){ $("#indexPill").textContent=t; }
function fmtSec(s){const m=Math.floor(s/60),ss=s%60;return `${m}:${String(ss).padStart(2,'0')}`}

function getTokObj(){ try{ return JSON.parse(localStorage.getItem("sp_token")||"null"); }catch{ return null; } }
function putTokObj(o){ localStorage.setItem("sp_token",JSON.stringify(o)); }
function tokenStatusText(){
  const o=getTokObj(); if(!o) return "未接続";
  const left=Math.max(0,Math.floor((o.expires_at-Date.now())/1000));
  return `トークンOK（残り ${fmtSec(left)}） scope:${o.scope||"(none)"}`
}

async function refreshIfNeeded(){
  const o=getTokObj(); if(!o) throw new Error("no token");
  const skew=15000;
  if(Date.now()< (o.expires_at-skew)) return o.access_token;
  if(!o.refresh_token){ throw new Error("token expired (no refresh_token). 再認証してください。"); }
  const body=new URLSearchParams({ client_id:"378ef0f44b36499abd10d118ddbddc98", grant_type:"refresh_token", refresh_token:o.refresh_token });
  const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!res.ok){ throw new Error(`refresh failed: ${await res.text()}`); }
  const tok=await res.json();
  const next={ access_token: tok.access_token, token_type: tok.token_type||o.token_type||"Bearer", scope: tok.scope||o.scope||"", refresh_token: tok.refresh_token||o.refresh_token||"", expires_at: Date.now()+ (tok.expires_in||3600)*1000 - 10000 };
  putTokObj(next); return next.access_token;
}

/* 429対策：受信後しばらく全リクエストに遅延を上乗せ／Retry-Afterを最大120sにキャップ */
let penaltyUntil=0;
function inPenalty(){ return Date.now()<penaltyUntil; }

let reqCountMin=0, windowStart=Date.now();
let hourCount=0, hourStart=Date.now();

async function api(endpoint, params={}, opt={}){
  const base="https://api.spotify.com";
  const method=opt.method||"GET";
  const maxRetries=Number($("#maxRetries").value||6);
  const maxBackoff=Number($("#maxBackoffMs").value||30000);
  const minDelay=Number($("#minDelayMs").value||3200);
  const rpmCap=Number($("#rpmCap").value||8);
  const hourBudget=Number($("#hourBudget").value||600);
  const cooldownCapMs=Number($("#cooldownCapMs").value||120000);
  const longBreakEvery=Number($("#longBreakEvery").value||160);
  const longBreakMs=Number($("#longBreakMs").value||240000);

  const now=Date.now();
  if(now-windowStart>=60000){ windowStart=now; reqCountMin=0; }
  if(now-hourStart>=3600000){ hourStart=now; hourCount=0; }
  if(reqCountMin && (reqCountMin%longBreakEvery===0)){ setRate(`long break ${longBreakMs}ms`); await sleep(longBreakMs); }

  if(reqCountMin>=rpmCap){ const wait=60000-(now-windowStart)+50; setRate(`rpm-cap wait ${wait}ms`); await sleep(wait); }
  if(hourCount>=hourBudget){ setRate(`hour budget cooldown 120000ms`); await sleep(120000); hourStart=Date.now(); hourCount=0; }

  let baseDelay=jitter(minDelay);
  if(inPenalty()) baseDelay+=12000;
  await sleep(baseDelay);

  let url=base+endpoint;
  if(method==="GET" && params && Object.keys(params).length){
    const qs=new URLSearchParams(Object.entries(params).filter(([k,v])=>v!==undefined && v!==null));
    url+=`?${qs}`;
  }
  const token=await refreshIfNeeded();
  const headers={"Authorization":`Bearer ${token}`,"Accept":"application/json"};
  if(method!=="GET"){ headers["Content-Type"]="application/json"; }

  let attempt=0, backoff=800;
  while(true){
    try{
      const res=await fetch(url,{method,headers,body:method==="GET"?undefined:JSON.stringify(params)});
      reqCountMin++; hourCount++;

      if(res.status===401 && attempt===0){ await refreshIfNeeded(); attempt++; continue; }
      if(res.status===429){
        const ra=(Number(res.headers.get("Retry-After"))||60)*1000;
        const capped=Math.min(ra, cooldownCapMs);
        penaltyUntil=Date.now()+Math.max(capped,30000);
        setRate(`429 slow-mode ${capped}ms`); log(`[429] Retry-After(raw): ${Math.round(ra/1000)}s → cap ${Math.round(capped/1000)}s`);
        // search を使わないので、ここは待たずに throw して上位で「後回し」判定する
        const err=new Error("RATE_LIMIT"); err.code=429; err.retryAfter=capped; throw err;
      }
      if(res.status>=500){
        if(attempt>=maxRetries) throw new Error(`HTTP ${res.status} ${await res.text()}`);
        setRate(`5xx backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++; continue;
      }
      if(!res.ok){
        const bodyText=await res.text();
        throw new Error(`HTTP ${res.status} ${bodyText}`);
      }
      setRate("ok"); return await res.json();
    }catch(e){
      if(e && e.code===429){ throw e; }
      if(attempt>=maxRetries){ throw e; }
      setRate(`err backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++;
    }
  }
}

/** CSV 列検出／プレビュー */
function detectCols(headers){
  const hmap={}; headers.forEach(h=>hmap[h.trim().toLowerCase()]=h);
  const get=(...c)=> c.map(s=>s.toLowerCase()).find(k=>hmap[k]) ? hmap[c.map(s=>s.toLowerCase()).find(k=>hmap[k])] : null;
  return { url:get("spotify_url","url","spotify"), upc:get("upc","pos","ean"), isrc:get("isrc"),
           album:get("album title","album","release"), version:get("album version","version","mix"), track:get("track title","title","track") };
}
function previewTable(rows){
  const tbl=$("#previewTbl");
  const headers=rows.length?Object.keys(rows[0]):[];
  tbl.querySelector("thead").innerHTML=`<tr>${headers.map(h=>`<th>${h}</th>`).join("")}</tr>`;
  const bodyRows=rows.slice(0,10).map(r=>`<tr>${headers.map(h=>`<td>${(r[h]??"")}</td>`).join("")}</tr>`).join("");
  tbl.querySelector("tbody").innerHTML=bodyRows||"<tr><td>（なし）</td></tr>";
}

/** 正規化比較 */
function norm(s){ return String(s||"").toLowerCase().replace(/[^\p{Letter}\p{Number}]+/gu," ").trim(); }

/** カタログ・インデックス（search無し） */
const Catalog = {
  albumIds: new Set(),
  albumById: new Map(),       // id -> minimal album
  upcToAlbumId: new Map(),    // upc -> id
  nameToIds: new Map(),       // normalized album name -> [ids]
};

async function buildCatalogIndex(){
  setIndexState("building…");
  ilog(`[index] fetch artist albums for ${TARGET_ARTIST_ID}`);
  // 1) /v1/artists/{id}/albums を全ページ取得（album/single/compilation のみ）
  let offset=0, got=0;
  const seen=new Set();
  while(true){
    let page;
    try{
      page=await api(`/v1/artists/${TARGET_ARTIST_ID}/albums`,{
        include_groups:"album,single,compilation", limit:50, offset
      });
    }catch(e){
      if(e && e.code===429){ ilog(`[index] defer page offset=${offset}`); continue; }
      else throw e;
    }
    const items=page.items||[];
    for(const a of items){
      if(!a || !a.id || seen.has(a.id)) continue;
      seen.add(a.id); Catalog.albumIds.add(a.id);
      const nm = norm(a.name||"");
      if(nm){
        if(!Catalog.nameToIds.has(nm)) Catalog.nameToIds.set(nm,[]);
        Catalog.nameToIds.get(nm).push(a.id);
      }
    }
    got+=items.length; ilog(`[index] fetched ${got} albums (unique:${Catalog.albumIds.size})`);
    if(!page.next || !items.length) break;
    offset+=items.length;
  }

  // 2) /v1/albums?ids（≤20）で UPC を一括取得
  const ids=[...Catalog.albumIds];
  const batchSize=Math.min(20, Number($("#albBatch").value||20));
  for(let i=0;i<ids.length;i+=batchSize){
    const slice=ids.slice(i,i+batchSize);
    let resp;
    try{
      resp=await api(`/v1/albums`,{ids:slice.join(",")});
    }catch(e){
      if(e && e.code===429){ ilog(`[index] defer batch i=${i}`); i-=batchSize; continue; }
      else throw e;
    }
    for(const alb of (resp.albums||[])){
      if(!alb || !alb.id) continue;
      Catalog.albumById.set(alb.id,{
        id: alb.id, name: alb.name||"", label: alb.label||"",
        upc: (alb.external_ids&&alb.external_ids.upc)||"",
        url: alb.external_urls?.spotify || `https://open.spotify.com/album/${alb.id}`,
        release_date: alb.release_date||""
      });
      const upc = (alb.external_ids&&alb.external_ids.upc)||"";
      if(upc) Catalog.upcToAlbumId.set(upc, alb.id);
    }
    ilog(`[index] albums hydrated: ${Math.min(i+batchSize,ids.length)}/${ids.length}`);
    await sleep(jitter(Number($("#batchPauseMs").value||1200)));
  }
  ilog(`[index] UPC mapped: ${Catalog.upcToAlbumId.size}`);
  setIndexState("ready");
}

/** URL/UPC/テキストで解決（search完全禁止） */
function parseSpotifyId(u){
  if(!u) return null;
  try{
    if(u.startsWith("spotify:")){
      const parts=u.split(":"); return {type:parts[1], id:parts[2]};
    }
    const url=new URL(u);
    const seg=url.pathname.split("/").filter(Boolean);
    const type=seg[0], id=seg[1]?.split("?")[0];
    if(type && id) return {type,id};
  }catch{}
  return null;
}
function resolveByText(albumTitle, version){
  const key=norm(albumTitle+" "+(version||""));
  if(key && Catalog.nameToIds.has(key)){
    const id=Catalog.nameToIds.get(key)[0];
    const a=Catalog.albumById.get(id);
    return a?{albumId:a.id,url:a.url}:null;
  }
  const tkey=norm(albumTitle);
  if(tkey && Catalog.nameToIds.has(tkey)){
    const id=Catalog.nameToIds.get(tkey)[0];
    const a=Catalog.albumById.get(id);
    return a?{albumId:a.id,url:a.url}:null;
  }
  return null;
}

async function resolveAlbum(row, cols){
  // 0) URL最優先
  if(cols.url && row[cols.url]){
    const u=String(row[cols.url]).trim();
    const p=parseSpotifyId(u);
    if(p){
      if(p.type==="album") return {albumId:p.id, url:`https://open.spotify.com/album/${p.id}`};
      if(p.type==="track"){
        try{
          const tr=await api(`/v1/tracks/${p.id}`, {});
          return {albumId: tr.album.id, url: tr.album.external_urls.spotify};
        }catch(e){ log(`Resolve err: url:${u} → ${e.message||e}`); }
      }
    }
  }
  // 1) UPC → 事前インデックス
  if(cols.upc && row[cols.upc]){
    const upc=String(row[cols.upc]).trim();
    const id=Catalog.upcToAlbumId.get(upc);
    if(id){ const a=Catalog.albumById.get(id); return {albumId:id, url:a?.url||`https://open.spotify.com/album/${id}`}; }
  }
  // 2) タイトル照合
  const albumTitle=cols.album&&row[cols.album]?String(row[cols.album]).trim():'';
  const version=cols.version&&row[cols.version]?String(row[cols.version]).trim():'';
  const byText = resolveByText(albumTitle, version);
  if(byText) return byText;

  // 3) search は完全禁止（トグルが true でも呼ばない設計）
  throw Object.assign(new Error("UNRESOLVED_NOSEARCH"), {code:"UNRESOLVED_NOSEARCH"});
}

/** 収集 */
async function harvestAlbumTracksFull(albumId, sourceKey, albumUrl){
  const alb = Catalog.albumById.get(albumId) || await api(`/v1/albums/${albumId}`, {});
  const tracks=[]; let offset=0;
  while(true){
    const page=await api(`/v1/albums/${albumId}/tracks`, {limit:50, offset});
    (page.items||[]).forEach(x=>{ tracks.push({id:x.id,name:x.name,disc_number:x.disc_number,track_number:x.track_number,artists:(x.artists||[]).map(a=>a.name).join(" & ")}); });
    offset += page.items?.length||0;
    await sleep(jitter(Number($("#pagePauseMs").value||300)));
    if(!page.next) break;
  }
  const batchSize=Math.min(50, Number($("#trkBatch").value||40));
  const out=[];
  for(let i=0;i<tracks.length;i+=batchSize){
    const slice=tracks.slice(i,i+batchSize);
    const ids=slice.map(t=>t.id).filter(Boolean).join(",");
    if(!ids) continue;
    const resp=await api(`/v1/tracks`, {ids});
    const full=(resp.tracks||[]);
    for(const simp of slice){
      const f=full.find(x=>x && x.id===simp.id);
      if(!f) continue;
      out.push({
        source_key: sourceKey,
        album_id: albumId,
        album_url: albumUrl||alb.external_urls?.spotify||`https://open.spotify.com/album/${albumId}`,
        album_name: (alb.name||alb.album_name||""),
        album_label: (alb.label||""),
        album_release_date: (alb.release_date||""),
        album_upc: (alb.external_ids&&alb.external_ids.upc)||"",
        track_id: f.id,
        track_name: f.name||simp.name,
        disc_number: f.disc_number||simp.disc_number||"",
        track_number: f.track_number||simp.track_number||"",
        duration_ms: f.duration_ms||"",
        explicit: f.explicit?"true":"false",
        isrc: (f.external_ids&&f.external_ids.isrc)||"",
        artists: (f.artists||[]).map(a=>a.name).join(" & "),
        preview_url: f.preview_url||""
      });
    }
    await sleep(jitter(Number($("#batchPauseMs").value||1200)));
  }
  return out;
}

/*** Checkpoint ***/
let g={rows:[],cols:{},uniqueKeys:[],rowsByKey:null,results:[],doneKeys:new Set(),running:false,fileName:''};
let stopSignal=false;
function loadCheckpoint(){ try{ const cp=JSON.parse(localStorage.getItem(CHECKPOINT_KEY)||"null"); if(!cp) return null; g.doneKeys=new Set(cp.done||[]); g.results=cp.results||[]; return cp; }catch{return null;} }
function saveCheckpoint(){ const cp={ done:[...g.doneKeys], results:g.results }; localStorage.setItem(CHECKPOINT_KEY, JSON.stringify(cp)); $("#downloadCheckpointBtn").disabled=false; }
function clearCheckpoint(){ localStorage.removeItem(CHECKPOINT_KEY); g.doneKeys=new Set(); g.results=[]; $("#downloadCheckpointBtn").disabled=true; }

function buildRowsByKey(rows, cols){
  const map=new Map();
  for(const r of rows){
    const k = (cols.upc && r[cols.upc]) ? `upc:${String(r[cols.upc]).trim()}` :
              (cols.isrc && r[cols.isrc]) ? `isrc:${String(r[cols.isrc]).trim()}` :
              (cols.url && r[cols.url]) ? `url:${String(r[cols.url]).trim()}` :
              `txt:${(r[cols.album]||"")} | ${(r[cols.version]||"")} | ${(r[cols.track]||"")}`;
    if(!map.has(k)) map.set(k,[]);
    map.get(k).push(r);
  }
  return map;
}

function refreshAuthStatus(){ $("#authStatus").textContent = tokenStatusText(); }
function maybeEnableStart(){ $("#startBtn").disabled = !(g.rows?.length>0 && !!getTokObj()); }

async function run(){
  // 先にカタログインデックスを構築
  if(Catalog.upcToAlbumId.size===0){ await buildCatalogIndex(); }

  g.running=true; stopSignal=false; $("#pauseBtn").disabled=false; $("#startBtn").disabled=true; $("#resumeBtn").disabled=true;
  const total=g.uniqueKeys.length; let done=0;

  const deferred=[]; // 429等や未解決は後回し
  for(const key of g.uniqueKeys){
    if(g.doneKeys.has(key)){ done++; $("#prog").value=Math.round(done/total*100); continue; }
    if(stopSignal){ g.running=false; $("#resumeBtn").disabled=false; $("#pauseBtn").disabled=true; log("一時停止"); return; }

    log(`Resolve: ${key}`);
    try{
      const sampleRow=g.rowsByKey.get(key)[0];
      const r=await resolveAlbum(sampleRow, g.cols);
      if(!r){ log(`Resolve err: ${key} → not found`); }
      else{
        const outs=await harvestAlbumTracksFull(r.albumId, key, r.url);
        g.results.push(...outs);
        log(`album:${r.albumId} tracks:${outs.length}`);
      }
    }catch(e){
      if(e && e.code===429){
        log(`defer(rate-limit): ${key}`);
        deferred.push(key);
      }else if(e && e.code==="UNRESOLVED_NOSEARCH"){
        log(`skip(unmapped, no-search): ${key}`);
      }else{
        log(`Resolve err: ${key} → ${e.message||e}`);
      }
    }
    g.doneKeys.add(key);
    done++; $("#prog").value=Math.round(done/total*100);
    if(done%3===0) saveCheckpoint();
  }

  // 後回し分を最後に一巡だけ再試行
  if(deferred.length){
    log(`--- retry deferred ${deferred.length} keys ---`);
    for(const key of deferred){
      if(stopSignal){ g.running=false; $("#resumeBtn").disabled=false; $("#pauseBtn").disabled=true; log("一時停止"); return; }
      try{
        const sampleRow=g.rowsByKey.get(key)[0];
        const r=await resolveAlbum(sampleRow, g.cols);
        if(!r){ log(`deferred not found: ${key}`); continue; }
        const outs=await harvestAlbumTracksFull(r.albumId, key, r.url);
        g.results.push(...outs);
        log(`[deferred ok] album:${r.albumId} tracks:${outs.length}`);
      }catch(e){
        log(`[deferred err] ${key} → ${e.message||e}`);
      }
    }
  }

  saveCheckpoint(); $("#downloadTracksBtn").disabled = g.results.length===0; $("#pauseBtn").disabled=true; g.running=false; log("完了");
}

window.addEventListener("load", ()=>{
  refreshAuthStatus();
  $("#clearBtn").onclick=()=>{ localStorage.removeItem("sp_token"); refreshAuthStatus(); maybeEnableStart(); };

  $("#diagBtn").onclick=async()=>{
    const t=getTokObj();
    if(!t){ log("[diag] no token"); return; }
    log(`[diag] token present scope:${t.scope||"(none)"} exp_in:${Math.max(0,Math.floor((t.expires_at-Date.now())/1000))}s`);
    try{ const me=await api("/v1/me", {}); log(`[diag] me.id:${me.id||"-"} country:${me.country||"-"} product:${me.product||"-"}`); }catch(e){ log(`[diag] /me skipped: ${e.message||e}`); }
  };

  $("#csvFile").addEventListener("change",(ev)=>{
    const f=ev.target.files?.[0]; if(!f) return;
    g.fileName=f.name;
    Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{
      g.rows=res.data||[];
      g.cols=detectCols(res.meta.fields||[]);
      $("#fileInfo").textContent = `[CSV] loaded: ${g.rows.length} rows from ${f.name}\n[CSV] detected columns: ${JSON.stringify({url:g.cols.url,upc:g.cols.upc,isrc:g.cols.isrc,album:g.cols.album,version:g.cols.version,track:g.cols.track})}`;
      previewTable(g.rows);
      g.rowsByKey=buildRowsByKey(g.rows,g.cols);
      g.uniqueKeys=[...g.rowsByKey.keys()];
      log(`Unique keys: ${g.uniqueKeys.length}`);
      const cp=loadCheckpoint(); if(cp){ log(`resume: ${g.doneKeys.size} processed`); $("#downloadCheckpointBtn").disabled=false; } else { log(`no checkpoint to resume`); }
      maybeEnableStart();
    }});
  });

  $("#startBtn").onclick=()=>{ run(); };
  $("#pauseBtn").onclick=()=>{ stopSignal=true; };
  $("#resumeBtn").onclick=()=>{ if(!g.running){ stopSignal=false; run(); } };
  $("#clearChkBtn").onclick=()=>{ clearCheckpoint(); log("checkpoint cleared"); };

  $("#downloadTracksBtn").onclick=()=>{ 
    const rows=g.results;
    if(!rows.length){ alert("出力なし"); return; }
    const headers=Object.keys(rows[0]);
    const csv=[headers.join(","),...rows.map(r=>headers.map(h=>{
      const v=r[h]==null?"":String(r[h]).replace(/"/g,'""'); return /[",\n]/.test(v)?`"${v}"`:v;
    }).join(","))].join("\n");
    const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
    const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=`fulltracks_${g.fileName||'out'}.csv`; a.click(); URL.revokeObjectURL(a.href);
  };
  $("#downloadCheckpointBtn").onclick=()=>{ 
    const rows=[...g.doneKeys].map(k=>({key:k}));
    const headers=Object.keys(rows[0]||{key:""});
    const csv=[headers.join(","),...rows.map(r=>headers.map(h=>r[h]).join(","))].join("\n");
    const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
    const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=`checkpoint_${Date.now()}.csv`; a.click(); URL.revokeObjectURL(a.href);
  };

  setInterval(()=>{ refreshAuthStatus(); $("#resumeBtn").disabled = g.running || g.uniqueKeys.length===0; maybeEnableStart(); }, 1000);
});
</script>
</body>
</html>
