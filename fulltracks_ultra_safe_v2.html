<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TDCS Full Tracks Harvester — Ultra Ultra Safe v2 (no-scope)</title>
<link rel="preconnect" href="https://accounts.spotify.com"/>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans JP';margin:2rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;margin-bottom:1rem}
  .row{display:flex;flex-wrap:wrap;gap:1rem;align-items:center}
  button{padding:.6rem 1rem;border-radius:8px;border:1px solid #999;background:#111;color:#fff;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=file]{border:1px dashed #bbb;padding:.75rem;border-radius:8px;background:#fafafa}
  code,.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace}
  .muted{color:#666}.ok{color:#0a7f29}.bad{color:#b00020}
  progress{width:100%;height:14px}
  table{border-collapse:collapse;width:100%}th,td{border:1px solid #eee;padding:.5rem;font-size:.9rem;text-align:left}
  .pill{display:inline-block;padding:.1rem .5rem;border:1px solid #ccc;border-radius:999px;font-size:.8rem;background:#f6f6f6}
  .small{font-size:.85rem}
</style>
</head>
<body>
<header class="card">
  <h1>TDCS Full Tracks Harvester — Ultra Ultra Safe v2 (no-scope)</h1>
  <div class="small muted">Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> | Redirect: <code>https://npr2025.github.io/spotify-auth/callback.html</code></div>
  <div class="row">
    <a href="./auth.html?v=20250919-1"><button>Spotifyに接続</button></a>
    <button id="clearBtn" style="background:#eee;color:#111;border-color:#bbb">保存トークン削除</button>
    <span id="authStatus" class="muted">未接続</span>
  </div>
</header>

<section class="card">
  <h2>入力と実行設定</h2>
  <div class="row">
    <input type="file" id="csvFile" accept=".csv"/>
    <label>最小間隔(ms)：<input id="minDelayMs" type="number" value="4000" step="50" style="width:7rem"></label>
    <label>RPM上限(1分)：<input id="rpmCap" type="number" value="5" step="1" style="width:5rem"></label>
    <label>1時間予算(req)：<input id="hourBudget" type="number" value="300" step="50" style="width:6rem"></label>
    <label>最大バックオフ(ms)：<input id="maxBackoffMs" type="number" value="30000" step="500" style="width:7rem"></label>
    <label>最大リトライ：<input id="maxRetries" type="number" value="9" step="1" style="width:5rem"></label>
    <label>429ロングCD(ms)：<input id="cooldownMs" type="number" value="600000" step="60000" style="width:8rem"></label>
  </div>
  <div class="row">
    <label>アルバムバッチ間隔(ms)：<input id="batchPauseMs" type="number" value="1500" step="100" style="width:7rem"></label>
    <label>トラックページ間隔(ms)：<input id="pagePauseMs" type="number" value="400" step="50" style="width:6rem"></label>
    <label>tracks?ids バッチ(≤50)：<input id="trkBatch" type="number" value="20" min="1" max="50" step="1" style="width:5rem"></label>
    <label>albums?ids バッチ(≤20)：<input id="albBatch" type="number" value="20" min="1" max="20" step="1" style="width:5rem"></label>
    <label>ロングブレイク：<input id="longBreakEvery" type="number" value="120" step="10" style="width:5rem"> req毎 / <input id="longBreakMs" type="number" value="300000" step="60000" style="width:7rem"> ms</label>
    <label><input id="slowJitter" type="checkbox" checked> ジッターON</label>
    <label><input id="emergencyMode" type="checkbox" checked> エマージェンシー自動化</label>
    <label>エマージェンシー間隔(ms)：<input id="emgPerReqMs" type="number" value="30000" step="1000" style="width:7rem"></label>
  </div>
  <div class="row">
    <label><input id="scanAllTracks" type="checkbox" checked> 全アルバムでトラック走査（フル）</label>
    <button id="startBtn" disabled>開始</button>
    <button id="pauseBtn" disabled>一時停止</button>
    <button id="resumeBtn" disabled>再開</button>
    <button id="clearChkBtn">チェックポイント削除</button>
    <button id="diagBtn" style="background:#0a7f29;border-color:#0a7f29">接続診断</button>
  </div>
  <div id="fileInfo" class="small muted"></div>
  <div class="small muted">対応列：<code>spotify_url / UPC / ISRC / Album title / Album version / Track title</code></div>
</section>

<section class="card">
  <h2>進捗 <span id="ratePill" class="pill">idle</span></h2>
  <progress id="prog" value="0" max="100"></progress>
  <div id="log" class="mono" style="white-space:pre-wrap;max-height:260px;overflow:auto"></div>
</section>

<section class="card">
  <h2>エクスポート</h2>
  <div class="row">
    <button id="downloadTracksBtn" disabled>フルトラックCSV</button>
    <button id="downloadCheckpointBtn" disabled>チェックポイントCSV</button>
  </div>
</section>

<section class="card">
  <h2>プレビュー（10行）</h2>
  <table id="previewTbl"><thead></thead><tbody></tbody></table>
</section>

<script>
const TARGET_ARTIST_ID="55fvQ5I2IZUfcFT2DV02T3";
const CHECKPOINT_KEY="tdcs_fulltracks_checkpoint_v2";

const $=s=>document.querySelector(s);
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const jitter=v=> ($("#slowJitter").checked? v+Math.floor(Math.random()*Math.floor(v*0.2)) : v);
function log(m){ const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function setRate(t){ $("#ratePill").textContent=t; }
function fmtSec(s){const m=Math.floor(s/60),ss=s%60;return `${m}:${String(ss).padStart(2,'0')}`}

function getTokObj(){ try{ return JSON.parse(localStorage.getItem("sp_token")||"null"); }catch{ return null; } }
function putTokObj(o){ localStorage.setItem("sp_token",JSON.stringify(o)); }
function tokenStatusText(){
  const o=getTokObj(); if(!o) return "未接続";
  const left=Math.max(0,Math.floor((o.expires_at-Date.now())/1000));
  return `トークンOK（残り ${fmtSec(left)}） scope:${o.scope||"(none)"}`
}

async function refreshIfNeeded(){
  const o=getTokObj(); if(!o) throw new Error("no token");
  const skew=15000;
  if(Date.now()< (o.expires_at-skew)) return o.access_token;
  if(!o.refresh_token){ throw new Error("token expired (no refresh_token). 再認証してください。"); }
  const body=new URLSearchParams({ client_id:"378ef0f44b36499abd10d118ddbddc98", grant_type:"refresh_token", refresh_token:o.refresh_token });
  const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!res.ok){ throw new Error(`refresh failed: ${await res.text()}`); }
  const tok=await res.json();
  const next={ access_token: tok.access_token, token_type: tok.token_type||o.token_type||"Bearer", scope: tok.scope||o.scope||"", refresh_token: tok.refresh_token||o.refresh_token||"", expires_at: Date.now()+ (tok.expires_in||3600)*1000 - 10000 };
  putTokObj(next); return next.access_token;
}

let reqCountMin=0, windowStart=Date.now();
let hourCount=0, hourStart=Date.now();
async function api(endpoint, params={}, opt={}){
  const base="https://api.spotify.com";
  const method=opt.method||"GET";
  const maxRetries=Number($("#maxRetries").value||9);
  const maxBackoff=Number($("#maxBackoffMs").value||30000);
  const minDelay=Number($("#minDelayMs").value||4000);
  const rpmCap=Number($("#rpmCap").value||5);
  const hourBudget=Number($("#hourBudget").value||300);
  const cooldownMs=Number($("#cooldownMs").value||600000);

  const now=Date.now();
  if(now-windowStart>=60000){ windowStart=now; reqCountMin=0; }
  if(now-hourStart>=3600000){ hourStart=now; hourCount=0; }
  if(reqCountMin>=rpmCap){ const wait=60000-(now-windowStart)+50; setRate(`rpm-cap wait ${wait}ms`); await sleep(wait); }
  if(hourCount>=hourBudget){ setRate(`hour budget cooldown ${cooldownMs}ms`); await sleep(cooldownMs); hourStart=Date.now(); hourCount=0; }

  await sleep(jitter(minDelay));

  let url=base+endpoint;
  if(method==="GET" && params && Object.keys(params).length){
    const qs=new URLSearchParams(Object.entries(params).filter(([k,v])=>v!==undefined && v!==null));
    url+=`?${qs}`;
  }
  const token=await refreshIfNeeded();
  const headers={"Authorization":`Bearer ${token}`,"Accept":"application/json"};
  if(method!=="GET"){ headers["Content-Type"]="application/json"; }

  let attempt=0, backoff=800;
  while(true){
    try{
      const res=await fetch(url,{method,headers,body:method==="GET"?undefined:JSON.stringify(params)});
      reqCountMin++; hourCount++;

      if(res.status===401 && attempt===0){ await refreshIfNeeded(); attempt++; continue; }
      if(res.status===429){
        const ra=(Number(res.headers.get("Retry-After"))||Math.ceil(cooldownMs/1000))*1000;
        log(`[429] Retry-After: ${Math.round(ra/1000)}s → long wait`); setRate(`429 wait ${ra}ms`); await sleep(ra); attempt++; continue;
      }
      if(res.status>=500){
        if(attempt>=maxRetries) throw new Error(`HTTP ${res.status} ${await res.text()}`);
        setRate(`5xx backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++; continue;
      }
      if(!res.ok){
        const bodyText=await res.text();
        throw new Error(`HTTP ${res.status} ${bodyText}`);
      }
      setRate("ok"); return await res.json();
    }catch(e){
      if(attempt>=maxRetries){ throw e; }
      setRate(`err backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++;
    }
  }
}

/*** 検索は scope 不要。market 指定も不要（国依存回避）。 ***/
async function searchAlbumsByUPC(upc){ return api("/v1/search",{q:`upc:${upc}`,type:"album",limit:1}); }

function detectCols(headers){
  const hmap={}; headers.forEach(h=>hmap[h.trim().toLowerCase()]=h);
  const get=(...c)=> c.map(s=>s.toLowerCase()).find(k=>hmap[k]) ? hmap[c.map(s=>s.toLowerCase()).find(k=>hmap[k])] : null;
  return { url:get("spotify_url","url","spotify"), upc:get("upc","pos","ean"), isrc:get("isrc"),
           album:get("album title","album","release"), version:get("album version","version","mix"), track:get("track title","title","track") };
}

function previewTable(rows){
  const tbl=$("#previewTbl");
  const headers=rows.length?Object.keys(rows[0]):[];
  tbl.querySelector("thead").innerHTML=`<tr>${headers.map(h=>`<th>${h}</th>`).join("")}</tr>`;
  const bodyRows=rows.slice(0,10).map(r=>`<tr>${headers.map(h=>`<td>${(r[h]??"")}</td>`).join("")}</tr>`).join("");
  tbl.querySelector("tbody").innerHTML=bodyRows||"<tr><td>（なし）</td></tr>";
}

function makeKey(row, cols){
  if(cols.upc && row[cols.upc]) return `upc:${String(row[cols.upc]).trim()}`;
  if(cols.isrc && row[cols.isrc]) return `isrc:${String(row[cols.isrc]).trim()}`;
  if(cols.url && row[cols.url]) return `url:${String(row[cols.url]).trim()}`;
  const a=row[cols.album]||"", v=row[cols.version]||"", t=row[cols.track]||"";
  return `txt:${a} | ${v} | ${t}`;
}

function parseSpotifyId(u){
  if(!u) return null;
  try{
    if(u.startsWith("spotify:")){
      const parts=u.split(":"); return {type:parts[1], id:parts[2]};
    }
    const url=new URL(u);
    const seg=url.pathname.split("/").filter(Boolean);
    const type=seg[0], id=seg[1]?.split("?")[0];
    if(type && id) return {type,id};
  }catch{}
  return null;
}

async function resolveAlbum(row, cols){
  if(cols.url && row[cols.url]){
    const u=String(row[cols.url]).trim();
    const p=parseSpotifyId(u);
    if(p){
      if(p.type==="album") return {albumId:p.id, url:`https://open.spotify.com/album/${p.id}`};
      if(p.type==="track"){
        try{
          const tr=await api(`/v1/tracks/${p.id}`, {});
          return {albumId: tr.album.id, url: tr.album.external_urls.spotify};
        }catch(e){ log(`Resolve err: url:${u} → ${e.message||e}`); }
      }
    }
  }
  if(cols.upc && row[cols.upc]){
    const upc=String(row[cols.upc]).trim();
    try{
      const s=await searchAlbumsByUPC(upc);
      const a=s.albums?.items?.[0];
      if(a) return {albumId:a.id,url:a.external_urls.spotify};
    }catch(e){ log(`Resolve err: upc:${upc} → ${e.message||e}`); }
  }
  if(cols.isrc && row[cols.isrc]){
    const isrc=String(row[cols.isrc]).trim();
    try{
      const s=await api("/v1/search",{q:`isrc:${isrc}`,type:"track",limit:1});
      const t=s.tracks?.items?.[0];
      if(t&&t.album) return {albumId:t.album.id,url:t.album.external_urls.spotify};
    }catch(e){ log(`Resolve err: isrc:${isrc} → ${e.message||e}`); }
  }
  const albumTitle=cols.album&&row[cols.album]?String(row[cols.album]).trim():'';
  const version=cols.version&&row[cols.version]?String(row[cols.version]).trim():'';
  const trackTitle=cols.track&&row[cols.track]?String(row[cols.track]).trim():'';
  const queries=[];
  if(albumTitle) queries.push({q:`album:"${albumTitle}" artist:"The Darrow Chem Syndicate"${version?` "${version}"`:''}`,type:'album'});
  if(albumTitle) queries.push({q:`album:"${albumTitle}"${version?` "${version}"`:''}`,type:'album'});
  if(trackTitle) queries.push({q:`track:"${trackTitle}" artist:"The Darrow Chem Syndicate"${version?` "${version}"`:''}`,type:'track'});
  for(const q of queries){
    try{
      const res=await api('/v1/search',{...q,limit:3});
      if(q.type==='album' && res.albums?.items?.length){ const a=res.albums.items[0]; if(a) return {albumId:a.id,url:a.external_urls.spotify}; }
      if(q.type==='track' && res.tracks?.items?.length){ const t=res.tracks.items[0]; if(t&&t.album) return {albumId:t.album.id,url:t.album.external_urls.spotify}; }
    }catch(e){}
    await sleep(jitter(200));
  }
  return null;
}

async function harvestAlbumTracksFull(albumId, sourceKey, albumUrl){
  const alb = await api(`/v1/albums/${albumId}`, {});
  const tracks=[]; let offset=0;
  while(true){
    const page=await api(`/v1/albums/${albumId}/tracks`, {limit:50, offset});
    (page.items||[]).forEach(x=>{ tracks.push({id:x.id,name:x.name,disc_number:x.disc_number,track_number:x.track_number,artists:(x.artists||[]).map(a=>a.name).join(" & ")}); });
    offset += page.items?.length||0;
    await sleep(jitter(Number($("#pagePauseMs").value||400)));
    if(!page.next) break;
  }
  const batchSize=Math.min(50, Number($("#trkBatch").value||20));
  const out=[];
  for(let i=0;i<tracks.length;i+=batchSize){
    const slice=tracks.slice(i,i+batchSize);
    const ids=slice.map(t=>t.id).filter(Boolean).join(",");
    if(!ids) continue;
    const resp=await api(`/v1/tracks`, {ids});
    const full=(resp.tracks||[]);
    for(const simp of slice){
      const f=full.find(x=>x && x.id===simp.id);
      if(!f) continue;
      out.push({
        source_key: sourceKey,
        album_id: albumId,
        album_url: albumUrl||alb.external_urls?.spotify||`https://open.spotify.com/album/${albumId}`,
        album_name: alb.name||"",
        album_label: alb.label||"",
        album_release_date: alb.release_date||"",
        album_upc: (alb.external_ids&&alb.external_ids.upc)||"",
        track_id: f.id,
        track_name: f.name||simp.name,
        disc_number: f.disc_number||simp.disc_number||"",
        track_number: f.track_number||simp.track_number||"",
        duration_ms: f.duration_ms||"",
        explicit: f.explicit?"true":"false",
        isrc: (f.external_ids&&f.external_ids.isrc)||"",
        artists: (f.artists||[]).map(a=>a.name).join(" & "),
        preview_url: f.preview_url||""
      });
    }
    await sleep(jitter(Number($("#batchPauseMs").value||1500)));
  }
  return out;
}

/*** Checkpoint ***/
let g={rows:[],cols:{},uniqueKeys:[],rowsByKey:null,results:[],doneKeys:new Set(),running:false,fileName:''};
let stopSignal=false;
function loadCheckpoint(){ try{ const cp=JSON.parse(localStorage.getItem(CHECKPOINT_KEY)||"null"); if(!cp) return null; g.doneKeys=new Set(cp.done||[]); g.results=cp.results||[]; return cp; }catch{return null;} }
function saveCheckpoint(){ const cp={ done:[...g.doneKeys], results:g.results }; localStorage.setItem(CHECKPOINT_KEY, JSON.stringify(cp)); $("#downloadCheckpointBtn").disabled=true===false; }
function clearCheckpoint(){ localStorage.removeItem(CHECKPOINT_KEY); g.doneKeys=new Set(); g.results=[]; $("#downloadCheckpointBtn").disabled=true; }

async function run(){
  g.running=true; stopSignal=false; $("#pauseBtn").disabled=false; $("#startBtn").disabled=true; $("#resumeBtn").disabled=true;
  const total=g.uniqueKeys.length; let done=0;
  for(const key of g.uniqueKeys){
    if(stopSignal){ g.running=false; $("#resumeBtn").disabled=false; $("#pauseBtn").disabled=true; log("一時停止"); return; }
    if(g.doneKeys.has(key)){ done++; $("#prog").value=Math.round(done/total*100); continue; }
    log(`Resolve: ${key}`);
    try{
      const sampleRow=g.rowsByKey.get(key)[0];
      const r=await resolveAlbum(sampleRow, g.cols);
      if(!r){ log(`Resolve err: ${key} → not found`); g.doneKeys.add(key); done++; $("#prog").value=Math.round(done/total*100); saveCheckpoint(); continue; }
      const outs=await harvestAlbumTracksFull(r.albumId, key, r.url);
      g.results.push(...outs);
      log(`album:${r.albumId} tracks:${outs.length}`);
    }catch(e){ log(`Resolve err: ${key} → ${e.message||e}`); }
    g.doneKeys.add(key);
    done++; $("#prog").value=Math.round(done/total*100);
    if(done%3===0) saveCheckpoint();
  }
  saveCheckpoint(); $("#downloadTracksBtn").disabled = g.results.length===0; $("#pauseBtn").disabled=true; g.running=false; log("完了");
}

function detectCols(headers){
  const hmap={}; headers.forEach((h)=> hmap[h.trim().toLowerCase()]=h);
  const get=(...c)=> c.map(s=>s.toLowerCase()).find(k=>hmap[k]) ? hmap[c.map(s=>s.toLowerCase()).find(k=>hmap[k])] : null;
  return { url:get("spotify_url","url","spotify"), upc:get("upc","pos","ean"), isrc:get("isrc"),
           album:get("album title","album","release"), version:get("album version","version","mix"), track:get("track title","title","track") };
}

function previewTable(rows){
  const tbl=$("#previewTbl");
  const headers=rows.length?Object.keys(rows[0]):[];
  tbl.querySelector("thead").innerHTML=`<tr>${headers.map(h=>`<th>${h}</th>`).join("")}</tr>`;
  const bodyRows=rows.slice(0,10).map(r=>`<tr>${headers.map(h=>`<td>${(r[h]??"")}</td>`).join("")}</tr>`).join("");
  tbl.querySelector("tbody").innerHTML=bodyRows||"<tr><td>（なし）</td></tr>";
}

function buildRowsByKey(rows, cols){
  const map=new Map();
  for(const r of rows){
    const k = (cols.upc && r[cols.upc]) ? `upc:${String(r[cols.upc]).trim()}` :
              (cols.isrc && r[cols.isrc]) ? `isrc:${String(r[cols.isrc]).trim()}` :
              (cols.url && r[cols.url]) ? `url:${String(r[cols.url]).trim()}` :
              `txt:${(r[cols.album]||"")} | ${(r[cols.version]||"")} | ${(r[cols.track]||"")}`;
    if(!map.has(k)) map.set(k,[]);
    map.get(k).push(r);
  }
  return map;
}

function refreshAuthStatus(){ $("#authStatus").textContent = tokenStatusText(); }
function maybeEnableStart(){ $("#startBtn").disabled = !(g.rows?.length>0 && !!getTokObj()); }

window.addEventListener("load", ()=>{
  refreshAuthStatus();
  $("#clearBtn").onclick=()=>{ localStorage.removeItem("sp_token"); refreshAuthStatus(); maybeEnableStart(); };

  $("#diagBtn").onclick=async()=>{
    const t=getTokObj();
    if(!t){ log("[diag] no token"); return; }
    log(`[diag] token present scope:${t.scope||"(none)"} exp_in:${Math.max(0,Math.floor((t.expires_at-Date.now())/1000))}s`);
    try{ const me=await api("/v1/me", {}); log(`[diag] me.id:${me.id||"-"} country:${me.country||"-"} product:${me.product||"-"}`); }catch(e){ log(`[diag] /me skipped: ${e.message||e}`); }
  };

  $("#csvFile").addEventListener("change",(ev)=>{
    const f=ev.target.files?.[0]; if(!f) return;
    g.fileName=f.name;
    Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{
      g.rows=res.data||[];
      g.cols=detectCols(res.meta.fields||[]);
      $("#fileInfo").textContent = `[CSV] loaded: ${g.rows.length} rows from ${f.name}\n[CSV] detected columns: ${JSON.stringify({url:g.cols.url,upc:g.cols.upc,isrc:g.cols.isrc,album:g.cols.album,version:g.cols.version,track:g.cols.track})}`;
      previewTable(g.rows);
      g.rowsByKey=buildRowsByKey(g.rows,g.cols);
      g.uniqueKeys=[...g.rowsByKey.keys()];
      log(`Unique keys: ${g.uniqueKeys.length}`);
      const cp=loadCheckpoint(); if(cp){ log(`resume: ${g.doneKeys.size} processed`);} else { log(`no checkpoint to resume`); }
      maybeEnableStart();
    }});
  });

  $("#startBtn").onclick=()=>{ run(); };
  $("#pauseBtn").onclick=()=>{ stopSignal=true; };
  $("#resumeBtn").onclick=()=>{ if(!g.running){ stopSignal=false; run(); } };
  $("#clearChkBtn").onclick=()=>{ clearCheckpoint(); log("checkpoint cleared"); };
  $("#downloadTracksBtn").onclick=()=>{ 
    const rows=g.results;
    if(!rows.length){ alert("出力なし"); return; }
    const headers=Object.keys(rows[0]);
    const csv=[headers.join(","),...rows.map(r=>headers.map(h=>{
      const v=r[h]==null?"":String(r[h]).replace(/"/g,'""'); return /[",\n]/.test(v)?`"${v}"`:v;
    }).join(","))].join("\n");
    const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
    const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=`fulltracks_${g.fileName||'out'}.csv`; a.click(); URL.revokeObjectURL(a.href);
  };
  $("#downloadCheckpointBtn").onclick=()=>{ 
    const rows=[...g.doneKeys].map(k=>({key:k}));
    const headers=Object.keys(rows[0]||{key:""});
    const csv=[headers.join(","),...rows.map(r=>headers.map(h=>r[h]).join(","))].join("\n");
    const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
    const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=`checkpoint_${Date.now()}.csv`; a.click(); URL.revokeObjectURL(a.href);
  };

  setInterval(()=>{ refreshAuthStatus(); maybeEnableStart(); }, 1000);
});
</script>
</body>
</html>
