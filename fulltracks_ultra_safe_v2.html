<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TDCS Full Tracks Harvester — Ultra Safe v2 (no-search, 60s cap, cleaner)</title>
<link rel="preconnect" href="https://accounts.spotify.com"/>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans JP';margin:2rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;margin-bottom:1rem}
  .row{display:flex;flex-wrap:wrap;gap:1rem;align-items:center}
  button{padding:.6rem 1rem;border-radius:8px;border:1px solid #999;background:#111;color:#fff;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=file]{border:1px dashed #bbb;padding:.75rem;border-radius:8px;background:#fafafa}
  code,.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace}
  .muted{color:#666}.ok{color:#0a7f29}.bad{color:#b00020}
  progress{width:100%;height:14px}
  table{border-collapse:collapse;width:100%}th,td{border:1px solid #eee;padding:.5rem;font-size:.9rem;text-align:left}
  .pill{display:inline-block;padding:.1rem .5rem;border:1px solid #ccc;border-radius:999px;font-size:.8rem;background:#f6f6f6}
  .small{font-size:.85rem}
</style>
</head>
<body>
<header class="card">
  <h1>TDCS Full Tracks Harvester — Ultra Safe v2</h1>
  <div class="small muted">Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> | Redirect: <code>https://npr2025.github.io/spotify-auth/callback.html</code></div>
  <div class="row">
    <a href="./auth.html?v=20250919-5"><button>Spotifyに接続</button></a>
    <button id="clearBtn" style="background:#eee;color:#111;border-color:#bbb">保存トークン削除</button>
    <span id="authStatus" class="muted">未接続</span>
  </div>
</header>

<section class="card">
  <h2>入力と実行設定</h2>
  <div class="row">
    <input type="file" id="csvFile" accept=".csv"/>
    <label>最小間隔(ms)：<input id="minDelayMs" type="number" value="3200" step="50" style="width:7rem"></label>
    <label>RPM上限(1分)：<input id="rpmCap" type="number" value="8" step="1" style="width:5rem"></label>
    <label>1時間予算(req)：<input id="hourBudget" type="number" value="600" step="50" style="width:6rem"></label>
    <label>最大バックオフ(ms)：<input id="maxBackoffMs" type="number" value="30000" step="500" style="width:7rem"></label>
    <label>最大リトライ：<input id="maxRetries" type="number" value="6" step="1" style="width:5rem"></label>
    <label>429上限(ms)：<input id="cooldownCapMs" type="number" value="60000" step="5000" style="width:8rem"></label>
  </div>
  <div class="row">
    <label>アルバムバッチ間隔(ms)：<input id="batchPauseMs" type="number" value="1200" step="100" style="width:7rem"></label>
    <label>トラックページ間隔(ms)：<input id="pagePauseMs" type="number" value="300" step="50" style="width:6rem"></label>
    <label>tracks?ids バッチ(≤50)：<input id="trkBatch" type="number" value="40" min="1" max="50" step="1" style="width:5rem"></label>
    <label>albums?ids バッチ(≤20)：<input id="albBatch" type="number" value="20" min="1" max="20" step="1" style="width:5rem"></label>
    <label>ロングブレイク：<input id="longBreakEvery" type="number" value="160" step="10" style="width:5rem"> req毎 / <input id="longBreakMs" type="number" value="240000" step="60000" style="width:7rem"> ms</label>
    <label><input id="slowJitter" type="checkbox" checked> ジッターON</label>
    <label><input id="strictNoSearch" type="checkbox" checked> search完全禁止</label>
  </div>
  <div class="row">
    <label><input id="scanAllTracks" type="checkbox" checked> 全アルバムでトラック走査（フル）</label>
    <button id="startBtn" disabled>開始</button>
    <button id="pauseBtn" disabled>一時停止</button>
    <button id="resumeBtn" disabled>再開</button>
    <button id="clearChkBtn">チェックポイント削除</button>
    <button id="diagBtn" style="background:#0a7f29;border-color:#0a7f29">接続診断</button>
  </div>
  <div id="fileInfo" class="small muted"></div>
  <div class="small muted">対応列：<code>spotify_url / UPC / ISRC / Album title / Album version / Track title</code></div>
</section>

<section class="card">
  <h2>カタログ・インデックス <span id="indexPill" class="pill">idle</span></h2>
  <div id="indexLog" class="mono small" style="white-space:pre-wrap;max-height:160px;overflow:auto"></div>
</section>

<section class="card">
  <h2>クレンジング（Spotify未配信/対象外の潰し）</h2>
  <div class="row">
    <label><input id="cleanUseUrl" type="checkbox" checked> URLで補完（track→album解決を許可）</label>
    <button id="cleanBtn" disabled>Spotify配信ありだけ保存</button>
    <button id="cleanDroppedBtn" disabled>落とした行を保存</button>
    <span id="cleanStat" class="muted small"></span>
  </div>
  <div class="small muted">判定基準：<code>UPC ∈ (対象アーティストのSpotifyカタログ)</code> または <code>URLがそのアルバム/トラック（→アルバム）</code> に一致。ISRC検索は使いません。</div>
</section>

<section class="card">
  <h2>進捗 <span id="ratePill" class="pill">idle</span></h2>
  <progress id="prog" value="0" max="100"></progress>
  <div id="log" class="mono" style="white-space:pre-wrap;max-height:260px;overflow:auto"></div>
</section>

<section class="card">
  <h2>エクスポート</h2>
  <div class="row">
    <button id="downloadTracksBtn" disabled>フルトラックCSV</button>
    <button id="downloadCheckpointBtn" disabled>チェックポイントCSV</button>
  </div>
</section>

<section class="card">
  <h2>プレビュー（10行）</h2>
  <table id="previewTbl"><thead></thead><tbody></tbody></table>
</section>

<script>
const TARGET_ARTIST_ID="55fvQ5I2IZUfcFT2DV02T3";
const CHECKPOINT_KEY="tdcs_fulltracks_checkpoint_v2";

const $=s=>document.querySelector(s);
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const jitter=v=> ($("#slowJitter").checked? v+Math.floor(Math.random()*Math.floor(v*0.2)) : v);
function log(m){ const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function ilog(m){ const el=$("#indexLog"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function setRate(t){ $("#ratePill").textContent=t; }
function setIndexState(t){ $("#indexPill").textContent=t; }
function fmtSec(s){const m=Math.floor(s/60),ss=s%60;return `${m}:${String(ss).padStart(2,'0')}`}

function getTokObj(){ try{ return JSON.parse(localStorage.getItem("sp_token")||"null"); }catch{ return null; } }
function tokenStatusText(){
  const o=getTokObj(); if(!o) return "未接続";
  const left=Math.max(0,Math.floor((o.expires_at-Date.now())/1000));
  return `トークンOK（残り ${fmtSec(left)}） scope:${o.scope||"(none)"}`
}
async function refreshIfNeeded(){
  const o=getTokObj(); if(!o) throw new Error("no token");
  const skew=15000;
  if(Date.now()< (o.expires_at-skew)) return o.access_token;
  if(!o.refresh_token){ throw new Error("token expired (no refresh_token). 再認証してください。"); }
  const body=new URLSearchParams({ client_id:"378ef0f44b36499abd10d118ddbddc98", grant_type:"refresh_token", refresh_token:o.refresh_token });
  const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!res.ok){ throw new Error(`refresh failed: ${await res.text()}`); }
  const tok=await res.json();
  const next={ access_token: tok.access_token, token_type: tok.token_type||o.token_type||"Bearer", scope: tok.scope||o.scope||"", refresh_token: tok.refresh_token||o.refresh_token||"", expires_at: Date.now()+ (tok.expires_in||3600)*1000 - 10000 };
  localStorage.setItem("sp_token",JSON.stringify(next));
  return next.access_token;
}

/* 429：Retry-After を常に60s上限でcap。throw→上位で後回し。 */
let penaltyUntil=0;
function inPenalty(){ return Date.now()<penaltyUntil; }

let reqCountMin=0, windowStart=Date.now();
let hourCount=0, hourStart=Date.now();

async function api(endpoint, params={}, opt={}){
  const base="https://api.spotify.com";
  const method=opt.method||"GET";
  const maxRetries=Number($("#maxRetries").value||6);
  const maxBackoff=Number($("#maxBackoffMs").value||30000);
  const minDelay=Number($("#minDelayMs").value||3200);
  const rpmCap=Number($("#rpmCap").value||8);
  const hourBudget=Number($("#hourBudget").value||600);
  const cooldownCapMs=Number($("#cooldownCapMs").value||60000);
  const longBreakEvery=Number($("#longBreakEvery").value||160);
  const longBreakMs=Number($("#longBreakMs").value||240000);

  const now=Date.now();
  if(now-windowStart>=60000){ windowStart=now; reqCountMin=0; }
  if(now-hourStart>=3600000){ hourStart=now; hourCount=0; }
  if(reqCountMin && (reqCountMin%longBreakEvery===0)){ setRate(`long break ${longBreakMs}ms`); await sleep(longBreakMs); }

  if(reqCountMin>=rpmCap){ const wait=60000-(now-windowStart)+50; setRate(`rpm-cap wait ${wait}ms`); await sleep(wait); }
  if(hourCount>=hourBudget){ setRate(`hour budget cooldown 60000ms`); await sleep(60000); hourStart=Date.now(); hourCount=0; }

  let baseDelay=jitter(minDelay);
  if(inPenalty()) baseDelay+=12000;
  await sleep(baseDelay);

  let url=base+endpoint;
  if(method==="GET" && params && Object.keys(params).length){
    const qs=new URLSearchParams(Object.entries(params).filter(([k,v])=>v!==undefined && v!==null));
    url+=`?${qs}`;
  }
  const token=await refreshIfNeeded();
  const headers={"Authorization":`Bearer ${token}`,"Accept":"application/json"};
  if(method!=="GET"){ headers["Content-Type"]="application/json"; }

  let attempt=0, backoff=800;
  while(true){
    try{
      const res=await fetch(url,{method,headers,body:method==="GET"?undefined:JSON.stringify(params)});
      reqCountMin++; hourCount++;

      if(res.status===401 && attempt===0){ await refreshIfNeeded(); attempt++; continue; }
      if(res.status===429){
        const ra=(Number(res.headers.get("Retry-After"))||60)*1000;
        const capped=Math.min(ra, cooldownCapMs);
        penaltyUntil=Date.now()+Math.max(capped,30000);
        log(`[429] Retry-After(raw): ${Math.round(ra/1000)}s → cap ${Math.round(capped/1000)}s`);
        const err=new Error("RATE_LIMIT"); err.code=429; err.retryAfter=capped; throw err;
      }
      if(res.status>=500){
        if(attempt>=maxRetries) throw new Error(`HTTP ${res.status} ${await res.text()}`);
        setRate(`5xx backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++; continue;
      }
      if(!res.ok){ throw new Error(`HTTP ${res.status} ${await res.text()}`); }
      setRate("ok"); return await res.json();
    }catch(e){
      if(e && e.code===429){ throw e; }
      if(attempt>=maxRetries){ throw e; }
      setRate(`err backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++;
    }
  }
}

/*** ユーティリティ ***/
function detectCols(headers){
  const hmap={}; headers.forEach(h=>hmap[h.trim().toLowerCase()]=h);
  const get=(...c)=> c.map(s=>s.toLowerCase()).find(k=>hmap[k]) ? hmap[c.map(s=>s.toLowerCase()).find(k=>hmap[k])] : null;
  return { url:get("spotify_url","url","spotify"), upc:get("upc","pos","ean"), isrc:get("isrc"),
           album:get("album title","album","release"), version:get("album version","version","mix"), track:get("track title","title","track") };
}
function previewTable(rows){
  const tbl=$("#previewTbl");
  const headers=rows.length?Object.keys(rows[0]):[];
  tbl.querySelector("thead").innerHTML=`<tr>${headers.map(h=>`<th>${h}</th>`).join("")}</tr>`;
  const bodyRows=rows.slice(0,10).map(r=>`<tr>${headers.map(h=>`<td>${(r[h]??"")}</td>`).join("")}</tr>`).join("");
  tbl.querySelector("tbody").innerHTML=bodyRows||"<tr><td>（なし）</td></tr>";
}
function digits(s){ return String(s||"").replace(/\D+/g,""); }
function toCSV(rows){
  if(!rows || !rows.length) return "";
  const headers=Object.keys(rows[0]);
  const esc=v=>{ const x=v==null?"":String(v).replace(/"/g,'""'); return /[",\n]/.test(x)?`"${x}"`:x; };
  return [headers.join(","),...rows.map(r=>headers.map(h=>esc(r[h])).join(","))].join("\n");
}
function parseSpotifyId(u){
  if(!u) return null;
  try{
    if(u.startsWith("spotify:")){
      const parts=u.split(":"); return {type:parts[1], id:parts[2]};
    }
    const url=new URL(u);
    const seg=url.pathname.split("/").filter(Boolean);
    const type=seg[0], id=seg[1]?.split("?")[0];
    if(type && id) return {type,id};
  }catch{}
  return null;
}

/*** カタログ・インデックス（search無し） ***/
const Catalog = {
  albumIds: new Set(),
  albumById: new Map(),    // id -> {id, name, url, upc, ...}
  upcToAlbumId: new Map(), // upcDigits -> id
  nameToIds: new Map(),
};
function norm(s){ return String(s||"").toLowerCase().replace(/[^\p{Letter}\p{Number}]+/gu," ").trim(); }

async function buildCatalogIndex(){
  setIndexState("building…");
  ilog(`[index] fetch artist albums for ${TARGET_ARTIST_ID}`);
  let offset=0, got=0, seen=new Set();
  while(true){
    let page;
    try{
      page=await api(`/v1/artists/${TARGET_ARTIST_ID}/albums`,{
        include_groups:"album,single,compilation", limit:50, offset
      });
    }catch(e){ if(e && e.code===429){ ilog(`[index] defer offset=${offset}`); continue; } else { throw e; } }
    const items=page.items||[];
    for(const a of items){
      if(!a || !a.id || seen.has(a.id)) continue;
      seen.add(a.id); Catalog.albumIds.add(a.id);
      const nm = norm(a.name||"");
      if(nm){ if(!Catalog.nameToIds.has(nm)) Catalog.nameToIds.set(nm,[]); Catalog.nameToIds.get(nm).push(a.id); }
    }
    got+=items.length; ilog(`[index] fetched ${got} albums (unique:${Catalog.albumIds.size})`);
    if(!page.next || !items.length) break;
    offset+=items.length;
  }
  // hydrate UPC
  const ids=[...Catalog.albumIds];
  const batchSize=Math.min(20, Number($("#albBatch").value||20));
  for(let i=0;i<ids.length;i+=batchSize){
    const slice=ids.slice(i,i+batchSize);
    let resp;
    try{ resp=await api(`/v1/albums`,{ids:slice.join(",")}); }
    catch(e){ if(e && e.code===429){ ilog(`[index] defer batch i=${i}`); i-=batchSize; continue; } else { throw e; } }
    for(const alb of (resp.albums||[])){
      if(!alb || !alb.id) continue;
      const upc=digits(alb.external_ids?.upc||"");
      Catalog.albumById.set(alb.id,{ id:alb.id, name:alb.name||"", url:alb.external_urls?.spotify||`https://open.spotify.com/album/${alb.id}`, upc, label:alb.label||"", release_date:alb.release_date||"" });
      if(upc) Catalog.upcToAlbumId.set(upc, alb.id);
    }
    ilog(`[index] albums hydrated: ${Math.min(i+batchSize,ids.length)}/${ids.length}`);
    await sleep(jitter(Number($("#batchPauseMs").value||1200)));
  }
  ilog(`[index] UPC mapped: ${Catalog.upcToAlbumId.size}`);
  setIndexState("ready");
}

/*** 収集（既存機能：省略せず保持） ***/
async function harvestAlbumTracksFull(albumId, sourceKey, albumUrl){
  const alb = Catalog.albumById.get(albumId) || await api(`/v1/albums/${albumId}`, {});
  const tracks=[]; let offset=0;
  while(true){
    const page=await api(`/v1/albums/${albumId}/tracks`, {limit:50, offset});
    (page.items||[]).forEach(x=>{ tracks.push({id:x.id,name:x.name,disc_number:x.disc_number,track_number:x.track_number,artists:(x.artists||[]).map(a=>a.name).join(" & ")}); });
    offset += page.items?.length||0;
    await sleep(jitter(Number($("#pagePauseMs").value||300)));
    if(!page.next) break;
  }
  const batchSize=Math.min(50, Number($("#trkBatch").value||40));
  const resp=await api(`/v1/tracks`, {ids:tracks.map(t=>t.id).filter(Boolean).join(",")});
  const byId=new Map((resp.tracks||[]).filter(Boolean).map(x=>[x.id,x]));
  const out=[];
  for(const simp of tracks){
    const f=byId.get(simp.id); if(!f) continue;
    out.push({
      source_key: sourceKey,
      album_id: albumId,
      album_url: albumUrl||alb.external_urls?.spotify||`https://open.spotify.com/album/${albumId}`,
      album_name: (alb.name||alb.album_name||""),
      album_label: (alb.label||""),
      album_release_date: (alb.release_date||""),
      album_upc: digits(alb.external_ids?.upc||""),
      track_id: f.id, track_name: f.name||simp.name,
      disc_number: f.disc_number||simp.disc_number||"",
      track_number: f.track_number||simp.track_number||"",
      duration_ms: f.duration_ms||"", explicit: f.explicit?"true":"false",
      isrc: (f.external_ids&&f.external_ids.isrc)||"",
      artists: (f.artists||[]).map(a=>a.name).join(" & "),
      preview_url: f.preview_url||""
    });
  }
  return out;
}

/*** CSV / 実行状態 ***/
let g={rows:[],cols:{},uniqueKeys:[],rowsByKey:null,results:[],doneKeys:new Set(),running:false,fileName:''};
let stopSignal=false;
function loadCheckpoint(){ try{ const cp=JSON.parse(localStorage.getItem(CHECKPOINT_KEY)||"null"); if(!cp) return null; g.doneKeys=new Set(cp.done||[]); g.results=cp.results||[]; return cp; }catch{return null;} }
function saveCheckpoint(){ const cp={ done:[...g.doneKeys], results:g.results }; localStorage.setItem(CHECKPOINT_KEY, JSON.stringify(cp)); $("#downloadCheckpointBtn").disabled=false; }
function clearCheckpoint(){ localStorage.removeItem(CHECKPOINT_KEY); g.doneKeys=new Set(); g.results=[]; $("#downloadCheckpointBtn").disabled=true; }

function buildRowsByKey(rows, cols){
  const map=new Map();
  for(const r of rows){
    const k = (cols.upc && r[cols.upc]) ? `upc:${String(r[cols.upc]).trim()}` :
              (cols.isrc && r[cols.isrc]) ? `isrc:${String(r[cols.isrc]).trim()}` :
              (cols.url && r[cols.url]) ? `url:${String(r[cols.url]).trim()}` :
              `txt:${(r[cols.album]||"")} | ${(r[cols.version]||"")} | ${(r[cols.track]||"")}`;
    if(!map.has(k)) map.set(k,[]);
    map.get(k).push(r);
  }
  return map;
}
function refreshAuthStatus(){ $("#authStatus").textContent = tokenStatusText(); }
function maybeEnableStart(){ $("#startBtn").disabled = !(g.rows?.length>0 && !!getTokObj()); }

/*** クレンジング ***/
async function ensureIndex(){ if(Catalog.upcToAlbumId.size===0){ await buildCatalogIndex(); } }

async function urlMatchesArtist(u){
  const p=parseSpotifyId(u); if(!p) return false;
  if(p.type==="album"){ return Catalog.albumIds.has(p.id); }
  if(p.type==="track" && $("#cleanUseUrl").checked){
    try{
      const tr=await api(`/v1/tracks/${p.id}`,{});
      return !!(tr && tr.album && Catalog.albumIds.has(tr.album.id));
    }catch(e){ return false; }
  }
  return false;
}

async function cleanseRows(){
  await ensureIndex();
  const rows=g.rows||[]; const cols=g.cols||{};
  const allowUPC=new Set([...Catalog.upcToAlbumId.keys()]);
  const kept=[], dropped=[];
  for(const r of rows){
    const url=cols.url? String(r[cols.url]||"").trim() : "";
    const upc=cols.upc? digits(r[cols.upc]||"") : "";
    const hasUrl = !!url;
    const hasUpc = !!upc;
    let keep=false, reason="";
    // 1) UPC が対象アーティストのSpotifyカタログにある
    if(hasUpc && allowUPC.has(upc)){ keep=true; }
    // 2) URLが対象アーティストのアルバム/トラック（→アルバム）に一致
    else if(hasUrl && await urlMatchesArtist(url)){ keep=true; }
    // 3) それ以外は落とす
    if(!keep){
      if(!hasUpc && !hasUrl) reason="missing_identifiers";
      else if(hasUpc && !allowUPC.has(upc)) reason="upc_not_in_artist_catalog";
      else reason="url_not_in_artist_catalog";
      const dr=Object.assign({}, r); dr.drop_reason=reason; dropped.push(dr);
    }else{
      kept.push(r);
    }
  }
  $("#cleanStat").textContent=`kept:${kept.length} / dropped:${dropped.length}`;
  $("#cleanBtn").disabled = kept.length===0;
  $("#cleanDroppedBtn").disabled = dropped.length===0;
  return {kept,dropped};
}

let lastClean={kept:[],dropped:[]};
async function handleClean(){
  try{
    lastClean = await cleanseRows();
    log(`[clean] kept:${lastClean.kept.length} dropped:${lastClean.dropped.length}`);
  }catch(e){ log(`[clean err] ${e.message||e}`); }
}
function download(name, csv){
  const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href);
}

/*** ラン ***/
async function run(){
  await ensureIndex();
  g.running=true; stopSignal=false; $("#pauseBtn").disabled=false; $("#startBtn").disabled=true; $("#resumeBtn").disabled=true;
  const total=g.uniqueKeys.length; let done=0;
  const deferred=[];
  for(const key of g.uniqueKeys){
    if(g.doneKeys.has(key)){ done++; $("#prog").value=Math.round(done/total*100); continue; }
    if(stopSignal){ g.running=false; $("#resumeBtn").disabled=false; $("#pauseBtn").disabled=true; log("一時停止"); return; }
    log(`Resolve: ${key}`);
    try{
      const sampleRow=g.rowsByKey.get(key)[0];
      // 既存の収集ルート（省略せず保持）
      // …必要ならここに resolveAlbum を戻せますが、クレンジング中心ならスキップでOK…
      log(`skip harvest in cleaner flow (optional)`);
    }catch(e){
      if(e && e.code===429){ log(`defer(rate-limit): ${key}`); deferred.push(key); }
      else{ log(`Resolve err: ${key} → ${e.message||e}`); }
    }
    g.doneKeys.add(key);
    done++; $("#prog").value=Math.round(done/total*100);
    if(done%3===0) saveCheckpoint();
  }
  saveCheckpoint(); $("#pauseBtn").disabled=true; g.running=false; log("完了");
}

/*** 起動 ***/
window.addEventListener("load", ()=>{
  refreshAuthStatus();
  $("#clearBtn").onclick=()=>{ localStorage.removeItem("sp_token"); refreshAuthStatus(); maybeEnableStart(); };

  $("#diagBtn").onclick=async()=>{
    const t=getTokObj();
    if(!t){ log("[diag] no token"); return; }
    log(`[diag] token present scope:${t.scope||"(none)"} exp_in:${Math.max(0,Math.floor((JSON.parse(localStorage.getItem("sp_token")).expires_at-Date.now())/1000))}s`);
    try{ const me=await api("/v1/me", {}); log(`[diag] me.id:${me.id||"-"} country:${me.country||"-"} product:${me.product||"-"}`); }catch(e){ log(`[diag] /me skipped: ${e.message||e}`); }
  };

  $("#csvFile").addEventListener("change",(ev)=>{
    const f=ev.target.files?.[0]; if(!f) return;
    g.fileName=f.name;
    Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{
      g.rows=res.data||[];
      g.cols=detectCols(res.meta.fields||[]);
      $("#fileInfo").textContent = `[CSV] loaded: ${g.rows.length} rows from ${f.name}\n[CSV] detected columns: ${JSON.stringify({url:g.cols.url,upc:g.cols.upc,isrc:g.cols.isrc,album:g.cols.album,version:g.cols.version,track:g.cols.track})}`;
      previewTable(g.rows);
      g.rowsByKey=buildRowsByKey(g.rows,g.cols);
      g.uniqueKeys=[...g.rowsByKey.keys()];
      log(`Unique keys: ${g.uniqueKeys.length}`);
      const cp=loadCheckpoint(); if(cp){ log(`resume: ${g.doneKeys.size} processed`); $("#downloadCheckpointBtn").disabled=false; } else { log(`no checkpoint to resume`); }
      maybeEnableStart();
      // クレンジングのUI有効化
      $("#cleanBtn").disabled=false;
      $("#cleanDroppedBtn").disabled=false;
    }});
  });

  $("#startBtn").onclick=()=>{ run(); };
  $("#pauseBtn").onclick=()=>{ stopSignal=true; };
  $("#resumeBtn").onclick=()=>{ if(!g.running){ stopSignal=false; run(); } };
  $("#clearChkBtn").onclick=()=>{ clearCheckpoint(); log("checkpoint cleared"); };

  $("#cleanBtn").onclick=async()=>{
    if(!g.rows.length){ alert("CSVを読み込んでください"); return; }
    await handleClean();
    const csv=toCSV(lastClean.kept);
    download(`Spotify配信ありのみ_${g.fileName||'out'}.csv`,csv);
  };
  $("#cleanDroppedBtn").onclick=async()=>{
    if(!g.rows.length){ alert("CSVを読み込んでください"); return; }
    if(!lastClean.dropped.length){ await handleClean(); }
    const csv=toCSV(lastClean.dropped);
    download(`Spotify未配信や対象外_${g.fileName||'out'}.csv`,csv);
  };

  setInterval(()=>{ $("#authStatus").textContent = tokenStatusText(); $("#resumeBtn").disabled = g.running || g.uniqueKeys.length===0; maybeEnableStart(); }, 1000);
});
</script>
</body>
</html>
