<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Editions Builder â€” FULL AUTO</title>
<style>
:root{--bg:#0b1220;--fg:#cfe3ff}
body{font-family:system-ui;max-width:1180px;margin:32px auto;padding:0 12px}
fieldset{border:1px solid #ddd;border-radius:10px;padding:14px;margin:14px 0}
label{display:block;margin:6px 0}
input[type="text"],input[type="number"]{width:100%;max-width:760px;padding:6px 8px;border:1px solid #ccc;border-radius:6px}
input[type="file"]{margin:4px 0}
button{padding:9px 12px;border:1px solid #bbb;border-radius:8px;background:#fff;cursor:pointer;margin:6px 8px 0 0}
button:disabled{opacity:.5;cursor:not-allowed}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
#log{white-space:pre-wrap;background:var(--bg);color:var(--fg);padding:12px;border-radius:8px;min-height:280px}
small.hint{color:#666}
</style>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<h1>Editions Builder â€” FULL AUTO</h1>
<p id="status">æœªæ¥ç¶š</p>
<div>
  <button id="btnConnect">Spotifyã«ã‚µã‚¤ãƒ³ã‚¤ãƒ³</button>
  <button id="btnReset">åˆæœŸåŒ–ï¼ˆä¿å­˜ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤ï¼‰</button>
  <button id="btnCheck">æ¥ç¶šãƒã‚§ãƒƒã‚¯</button>
</div>

<fieldset>
  <legend>å›ºå®šï¼ˆDashboardã¨ä¸€è‡´ï¼‰</legend>
  <div class="grid2">
    <label>CLIENT_ID <input type="text" value="1fd6350fcf4945a0b3ddffa2d5730d4e" disabled></label>
    <label>REDIRECT_URI <input type="text" value="https://npr2025.github.io/spotify-auth/callback.html" disabled></label>
  </div>
</fieldset>

<fieldset>
  <legend>è¨­å®š</legend>
  <div class="grid2">
    <label>UK <input id="plUK" type="text" value="https://open.spotify.com/playlist/1zqDXSgnbc87v4BxbHxtKK"></label>
    <label>US <input id="plUS" type="text" value="https://open.spotify.com/playlist/2oeS8QglwS4hLtLuqvPZgH"></label>
    <label>EU <input id="plEU" type="text" value="https://open.spotify.com/playlist/2JWHMN3yxLI5S4XFdDZbwt"></label>
    <label>WORLD <input id="plWORLD" type="text" value="https://open.spotify.com/playlist/4SCclM9zLNuSPOmqORdVN8"></label>
  </div>
  <div class="grid2">
    <label>APIé–“éš”(ms) <input id="gap" type="number" value="900"></label>
    <label>å„ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³å‡ºåŠ›æ•° <input id="finalN" type="number" value="130"></label>
  </div>
  <div class="grid2">
    <label>äººæ°—ã®é‡ã¿ï¼ˆSaveRateå´ï¼‰<input id="wPopularity" type="number" step="0.01" value="0.55"></label>
    <label class="hint">24/7/28=0.5/0.3/0.2 å›ºå®š</label>
  </div>
</fieldset>

<fieldset>
  <legend>ãƒ•ã‚¡ã‚¤ãƒ«</legend>
  <label>ã‚½ãƒ¼ã‚¹CSVï¼ˆPropgapandaã‚½ãƒ¼ã‚¹.csvï¼‰<input id="fileSource" type="file" accept=".csv"></label>
  <label>åˆ†æï¼ˆExcel .xlsx / CSVï¼‰<input id="fileAnalytics" type="file" accept=".xlsx,.csv"></label>
  <small class="hint">åˆ—ã®é¸æŠã¯ä¸è¦ã€‚ä¸­èº«ã‹ã‚‰å…¨è‡ªå‹•ã§æ¤œå‡ºã—ã¾ã™ã€‚</small>
</fieldset>

<fieldset>
  <legend>ãƒ­ã‚°</legend>
  <pre id="log">Bootingâ€¦</pre>
</fieldset>

<script>
/*** æœ¬å½“ã«å…¨è‡ªå‹• ***/
const AUTO_RUN = true;   // ä¸¡ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠï¼†ã‚µã‚¤ãƒ³ã‚¤ãƒ³æ¸ˆã¿ãªã‚‰å³é–‹å§‹
const AUTO_WRITE = true; // è§£æ±ºç‡ãŒé–¾å€¤ä»¥ä¸Šãªã‚‰è‡ªå‹•ã§ä¸Šæ›¸ã

/*** å¼·åˆ¶ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDï¼ˆThe Darrow Chem Syndicateï¼‰ ***/
const FORCED_ARTIST_IDS = ["55fvQ5I2IZUfcFT2DV02T3"];

/*** Spotifyã‚¢ãƒ—ãƒªè¨­å®š ***/
const CLIENT_ID="1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI="https://npr2025.github.io/spotify-auth/callback.html";
const SCOPES="playlist-modify-public playlist-modify-private ugc-image-upload";

/*** util ***/
const LS={acc:"sp_access_token",ref:"sp_refresh_token",exp:"sp_token_exp",ver:"sp_code_verifier"};
const $=id=>document.getElementById(id);
const log=s=>{const el=$("log"); el.textContent+=(el.textContent?"\n":"")+s; el.scrollTop=el.scrollHeight;};
const clearLog=()=>{$("log").textContent="";};
const isAuthed=()=>!!localStorage.getItem(LS.acc)&&Date.now()<(+localStorage.getItem(LS.exp)||0)-5000;
function setStatus(){ $("status").textContent=isAuthed()?"æ¥ç¶šä¸­ï¼ˆOKï¼‰":"æœªæ¥ç¶š"; maybeAutoGo(); }
function filesReady(){ return $("fileSource").files.length && $("fileAnalytics").files.length; }
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const num=x=>{const s=String(x??0).replace(/[ %,ï¼Œ]/g,"");const v=parseFloat(s);return isFinite(v)?v:0;};

/*** æ­£è¦åŒ–ãƒ»ãƒˆãƒ¼ã‚¯ãƒ³åŒ– ***/
const NFKC=s=>String(s||"").normalize("NFKC");
const rmMarks=s=>NFKC(s).normalize("NFKD").replace(/[\p{M}]/gu,"");
const norm=s=>rmMarks(s).toLowerCase()
  .replace(/[â€-â€’â€“â€”âˆ’]/g,"-")
  .replace(/[â€˜â€™â€šâ€›â€œâ€â€â€Ÿ"]/g," ")
  .replace(/[()ï¼»ï¼½\[\]{}ã€ã€‘]/g," ")
  .replace(/&/g," and ")
  .replace(/\s+/g," ")
  .trim();

const STOP=new Set(["feat","featuring","ft","vs","and","&","the","a","an","mix","remix","edit","version","vip","dub","club","radio","extended","original","instrumental","clean","dirty"]);
function tokensTitle(s){
  s=norm(s).replace(/ - /g," ").replace(/\((.*?)\)/g," $1 ").replace(/\[(.*?)\]/g," $1 ");
  return new Set(s.split(" ").filter(w=>w && !STOP.has(w)));
}
function canonVersion(s){
  s=norm(s);
  const map=[["original mix","original"],["orig mix","original"],["radio edit","radio"],["extended mix","extended"],["club mix","club"]];
  for(const [a,b] of map){ s=s.replace(a,b); }
  const vs=[]; const add=k=>{ if(k && !vs.includes(k)) vs.push(k); };
  if(/original/.test(s)) add("original");
  if(/radio/.test(s)) add("radio");
  if(/extended/.test(s)) add("extended");
  if(/instrumental/.test(s)) add("instrumental");
  if(/acoustic/.test(s)) add("acoustic");
  if(/vip/.test(s)) add("vip");
  if(/dub/.test(s)) add("dub");
  if(/club/.test(s)) add("club");
  if(/remix|rmx/.test(s)) add("remix");
  const rem = s.replace(/\b(original|radio|extended|instrumental|acoustic|vip|dub|club|remix|mix|edit)\b/g," ").trim();
  const remTok = tokensTitle(rem);
  return {kinds:new Set(vs), remTok};
}
function jaccard(a,b){ let inter=0; for(const x of a) if(b.has(x)) inter++; const union=a.size+b.size-inter; return union? inter/union:0; }

/*** Auth ***/
async function startAuth(){
  const ver=crypto.getRandomValues(new Uint8Array(64)).reduce((s,b)=>s+String.fromCharCode(97+(b%26)),"");
  localStorage.setItem(LS.ver,ver);
  const ch=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(ver)).then(b=>btoa(String.fromCharCode(...new Uint8Array(b))).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""));
  const u=new URL("https://accounts.spotify.com/authorize");
  u.searchParams.set("response_type","code"); u.searchParams.set("client_id",CLIENT_ID); u.searchParams.set("redirect_uri",REDIRECT_URI);
  u.searchParams.set("code_challenge_method","S256"); u.searchParams.set("code_challenge",ch); u.searchParams.set("scope",SCOPES);
  location.href=u.toString();
}
async function refreshTokenIfNeeded(){
  const exp=+localStorage.getItem(LS.exp||0); if(Date.now()<exp-5000) return;
  const rt=localStorage.getItem(LS.ref); if(!rt) return;
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({grant_type:"refresh_token",refresh_token:rt,client_id:CLIENT_ID})});
  if(!r.ok){ log("âš ï¸ refreshå¤±æ•— "+r.status); return; }
  const j=await r.json(); localStorage.setItem(LS.acc,j.access_token); localStorage.setItem(LS.exp,String(Date.now()+j.expires_in*1000)); if(j.refresh_token) localStorage.setItem(LS.ref,j.refresh_token);
}
async function spFetch(path,method="GET",body=null){
  await refreshTokenIfNeeded();
  const gap=+$("gap").value||900; await sleep(gap);
  for(let a=0;a<5;a++){
    const r=await fetch("https://api.spotify.com"+path,{method,headers:{"Authorization":"Bearer "+localStorage.getItem(LS.acc),"Content-Type":"application/json"},body: body?JSON.stringify(body):null});
    if(r.status===401){ await refreshTokenIfNeeded(); continue; }
    if(r.status===429){ const ra=+r.headers.get("Retry-After")||2; log(`â³429â†’${ra}så¾…æ©Ÿ`); await sleep(ra*1000); continue; }
    if(!r.ok){ const t=await r.text(); throw new Error(`Spotify ${r.status}: ${t.slice(0,180)}`); }
    if(r.status===204) return null; return await r.json();
  }
  throw new Error("Spotify API max retries");
}

/*** ãƒ•ã‚¡ã‚¤ãƒ«èª­è¾¼ ***/
let sourceRows=[], analyticsRows=[];
function readCSV(file){ return new Promise((resolve,reject)=>Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>resolve(r.data),error:reject})); }
async function readXLSX_allSheets(file){
  const buf=await file.arrayBuffer(); const wb=XLSX.read(buf,{type:"array"});
  let rows=[], details=[];
  for(const name of wb.SheetNames){
    const json=XLSX.utils.sheet_to_json(wb.Sheets[name],{defval:""});
    json.forEach(r=>r.__sheet=name); rows=rows.concat(json); details.push(`${name}:${json.length}`);
  }
  return { rows, details };
}
async function loadFiles(){
  clearLog(); log("ğŸ“¥ ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿â€¦");
  sourceRows=await readCSV($("fileSource").files[0]); log(`âœ… ã‚½ãƒ¼ã‚¹: ${sourceRows.length} è¡Œ`);
  const f2=$("fileAnalytics").files[0];
  if(f2.name.toLowerCase().endsWith(".xlsx")){
    const res=await readXLSX_allSheets(f2); analyticsRows=res.rows; log(`âœ… åˆ†æ: XLSX åˆè¨ˆ ${analyticsRows.length} è¡Œ [${res.details.join(", ")}]`);
  }else{ analyticsRows=await readCSV(f2); log(`âœ… åˆ†æ: CSV ${analyticsRows.length} è¡Œ`); }
  maybeAutoGo();
}

/*** åˆ—è‡ªå‹•æ¤œå‡º ***/
function columns(rows){ const s=new Set(); rows.slice(0,300).forEach(r=>Object.keys(r).forEach(k=>s.add(k))); return [...s]; }
const ISRC_RE=/^[A-Z]{2}-?[A-Z0-9]{3}-?\d{2}-?\d{5}$/i;
function pickByName(cols, prefers, forbids){
  const bad=new RegExp((forbids||[]).join("|"),"i");
  const L=cols.filter(c=>!bad.test(c)).map(c=>[c,norm(c)]);
  for(const k of prefers){ const n=norm(k); const hit=L.find(([o,nm])=> nm===n || nm.includes(n)); if(hit) return hit[0]; }
  return cols.sort((a,b)=> a.length-b.length)[0] || "";
}
function pickSourceColumns(rows){
  const cols=columns(rows);
  const scoreId=c=>{let m=0,n=0; for(const r of rows.slice(0,1000)){ const v=String(r[c]??""); if(!v) continue; n++; if(/spotify:track:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/track\/[A-Za-z0-9]{22}/.test(v)||/^[A-Za-z0-9]{22}$/.test(v)) m++; } return n? m/n:0;};
  const scoreIsrc=c=>{let m=0,n=0; for(const r of rows.slice(0,2000)){ const v=String(r[c]??""); if(!v) continue; n++; if(ISRC_RE.test(v)) m++; } return n? m/n:0;};
  const scoreArtistId=c=>{let m=0,n=0; for(const r of rows.slice(0,1500)){ const v=String(r[c]??""); if(!v) continue; n++; if(/spotify:artist:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/artist\/[A-Za-z0-9]{22}/.test(v)||/\b[A-Za-z0-9]{22}\b/.test(v)) m++; } return n? m/n:0;};

  const idCol       = cols.sort((a,b)=> scoreId(b)-scoreId(a))[0] || "";
  const isrcCol     = cols.sort((a,b)=> scoreIsrc(b)-scoreIsrc(a))[0] || "";
  const artistIdCol = cols.sort((a,b)=> scoreArtistId(b)-scoreArtistId(a))[0] || "";

  const nameCol   = pickByName(cols,["track title","track_name","title","æ›²å","ã‚¿ã‚¤ãƒˆãƒ«"],["album"]);
  const verCol    = pickByName(cols,["track version","version","ãƒãƒ¼ã‚¸ãƒ§ãƒ³"],[]);
  const artistCol = pickByName(cols,["track primary artists","primary artists","artists","artist","ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ"],["album"]);
  const remixCol  = pickByName(cols,["remixer","remixers","ãƒªãƒŸã‚­ã‚µãƒ¼"],[]);
  return {idCol,isrcCol,artistIdCol,nameCol,verCol,artistCol,remixCol};
}
function pickAnalyticColumns(rows, srcTitles){
  const cols=columns(rows);
  const idCol = pickByName(cols,["spotify_uri","track_uri","uri","url"],[]);
  const isrcCol = pickByName(cols,["isrc","isrc_code"],[]);
  const tCands=cols.filter(c=>/title|æ›²å|name/i.test(c)); const setSrc=new Set(srcTitles.slice(0,600).map(norm));
  let bestT=null, bestSc=-1;
  for(const c of tCands){
    let s=0,n=0; for(const r of rows.slice(0,800)){ const v=norm(String(r[c]??"")); if(!v) continue; n++; if(setSrc.has(v)) s++; }
    const sc=n? s/n:0; if(sc>bestSc){ bestSc=sc; bestT=c; }
  }
  const nameCol = bestT || pickByName(cols,["title"],[]);
  const artistCol = pickByName(cols,["artist","artists","artist_name","ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ"],["rank","score"]);
  const p24 = pickByName(cols,["plays_24h","p24","streams24","24h"],[]);
  const p7  = pickByName(cols,["plays_7d","p7","streams7","7d"],[]);
  const p28 = pickByName(cols,["plays_28d","p28","streams28","28d"],[]);
  const s24 = pickByName(cols,["save_rate_24h","sr24","save24"],[]);
  const s7  = pickByName(cols,["save_rate_7d","sr7","save7"],[]);
  const s28 = pickByName(cols,["save_rate_28d","sr28","save28"],[]);
  return {idCol,isrcCol,nameCol,artistCol,p24,p7,p28,s24,s7,s28};
}

/*** æŠ½å‡ºãƒ˜ãƒ«ãƒ‘ ***/
function extractTrackId(raw){
  const s=String(raw||"").trim(); if(!s) return "";
  let m=s.match(/spotify:track:([A-Za-z0-9]{22})/); if(m) return m[1];
  m=s.match(/open\.spotify\.com\/track\/([A-Za-z0-9]{22})/); if(m) return m[1];
  m=s.match(/\/track\/([A-Za-z0-9]{22})(?:\?|$)/); if(m) return m[1];
  m=s.match(/^([A-Za-z0-9]{22})$/); if(m) return m[1];
  return "";
}
function extractArtistIds(raw){
  if(raw==null) return [];
  const s=String(raw);
  const parts=s.split(/[,;\/|]+|\s{2,}/g).map(x=>x.trim()).filter(Boolean);
  const ids=[]; const push=id=>{ if(id && !ids.includes(id)) ids.push(id); };
  for(const p of parts){
    let m=p.match(/spotify:artist:([A-Za-z0-9]{22})/); if(m){ push(m[1]); continue; }
    m=p.match(/open\.spotify\.com\/artist\/([A-Za-z0-9]{22})/); if(m){ push(m[1]); continue; }
    m=p.match(/\b([A-Za-z0-9]{22})\b/); if(m){ push(m[1]); continue; }
  }
  return ids;
}

/*** ã‚½ãƒ¼ã‚¹ç´¢å¼• ***/
function buildSourceIndex(cfg){
  const {idCol,isrcCol,artistIdCol,nameCol,verCol,artistCol,remixCol}=cfg;
  const idxExact=new Map(), blob=[], titles=[];
  let hasArtistIds=0;

  for(const r of sourceRows){
    const id   = idCol? extractTrackId(r[idCol]) : "";
    const isrc = isrcCol? String(r[isrcCol]||"").trim().toUpperCase() : "";
    const title = String(r[nameCol]||"").trim();
    const ver   = String(r[verCol]||"").trim();
    const disp  = (!ver || /original\s*mix/i.test(ver)) ? title : `${title} - ${ver}`;
    const ttok  = tokensTitle(disp);
    const vinfo = canonVersion(ver+" "+String(r[remixCol]||""));

    const artistIds = artistIdCol ? extractArtistIds(r[artistIdCol]) : [];
    if(artistIds.length) hasArtistIds++;

    if(id)   idxExact.set("ID:"+id, r);
    if(isrc) idxExact.set("ISRC:"+isrc, r);
    if(disp) idxExact.set("NM:"+norm(disp), r);

    blob.push({r, disp, ttok, vinfo, artistIds});
    titles.push(disp);
  }
  log(`ğŸ¯ ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDä»˜ãè¡Œ: ${hasArtistIds} / ${sourceRows.length}`);
  return {idxExact, blob, titles, artistCol, remixCol, nameCol, verCol, artistIdCol};
}

/*** åˆ†æâ†’ã‚½ãƒ¼ã‚¹ çªåˆï¼ˆExactâ†’Fuzzy è‡ªå‹•ã—ãã„å€¤ï¼‰ ***/
function parseAnalysisTitle(a, cfg){
  const name=String(a[cfg.nameCol]||"");
  const art =cfg.artistCol? String(a[cfg.artistCol]||"") : "";
  const disp=name; const ttok=tokensTitle(disp+" "+art); const vinfo=canonVersion(disp);
  return {disp, ttok, vinfo};
}
function fuzzyBest(sourceBlob, an){
  let best=null;
  const titleWeight= an.vinfo.kinds.size? 0.75: 0.85;
  const verWeight=1-titleWeight;
  for(const s of sourceBlob){
    const ts = jaccard(an.ttok, s.ttok);
    const vk = jaccard(an.vinfo.kinds, s.vinfo.kinds);
    const vr = jaccard(an.vinfo.remTok, s.vinfo.remTok);
    const ver = 0.6*vk + 0.4*vr;
    const score = titleWeight*ts + verWeight*ver;
    if(!best || score>best.score) best={s,score,ts,ver};
  }
  return best;
}
function autoMatch(srcIdx, anCfg){
  const idA=anCfg.idCol, isrcA=anCfg.isrcCol;
  let thr=0.86; const minFrac=0.5;
  let rows=[], diag=null;

  for(; thr>=0.72; thr-=0.02){
    rows=[]; diag={exact:0,fuzzy:0,none:0};
    for(const a of analyticsRows){
      const id=idA? extractTrackId(a[idA]):""; const isc=isrcA? String(a[isrcA]||"").trim().toUpperCase():"";
      const an=parseAnalysisTitle(a, anCfg);
      let pick = (id && srcIdx.idxExact.get("ID:"+id)) || (isc && srcIdx.idxExact.get("ISRC:"+isc)) || srcIdx.idxExact.get("NM:"+norm(an.disp));
      let mode="exact", score=1;
      if(!pick){
        const best=fuzzyBest(srcIdx.blob, an);
        if(best && best.score>=thr){ pick=best.s.r; mode="fuzzy"; score=best.score; }
      }
      if(pick){ rows.push({ a, s:pick, _mode:mode, _score:score }); mode==="exact"? diag.exact++:diag.fuzzy++; }
      else{ diag.none++; }
    }
    const frac = rows.length / Math.max(1, analyticsRows.length);
    if(frac>=minFrac) break;
  }
  return {rows, thr, diag};
}

/*** ã‚¹ã‚³ã‚¢ ***/
function computeScores(rows, anCfg){
  const p24=anCfg.p24, p7=anCfg.p7, p28=anCfg.p28, s24=anCfg.s24, s7=anCfg.s7, s28=anCfg.s28;
  let max24=0,max7=0,max28=0; for(const r of rows){ max24=Math.max(max24,num(r.a[p24])); max7=Math.max(max7,num(r.a[p7])); max28=Math.max(max28,num(r.a[p28])); }
  for(const r of rows){
    const sr24=num(r.a[s24])/100, sr7=num(r.a[s7])/100, sr28=num(r.a[s28])/100;
    const pl24=max24? num(r.a[p24])/max24:0, pl7=max7? num(r.a[p7])/max7:0, pl28=max28? num(r.a[p28])/max28:0;
    const w=[0.5,0.3,0.2], wPop= +$("wPopularity").value || .55;
    const saveC=w[0]*sr24+w[1]*sr7+w[2]*sr28, playC=w[0]*pl24+w[1]*pl7+w[2]*pl28;
    r.score=wPop*saveC + (1-wPop)*playC;
  }
  rows.sort((a,b)=> b.score-a.score);
  return rows;
}

/*** URIè§£æ±ºï¼ˆã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDå¼·åˆ¶ï¼å¤šæ®µæ¤œç´¢ï¼‰ ***/
const _resolveCache = new Map();
const _topTracksCache = new Map(); // artistId|market -> tracks[]

async function fetchTopTracksByArtist(artistId, market){
  const key=`${artistId}|${market}`;
  if(_topTracksCache.has(key)) return _topTracksCache.get(key);
  const r = await spFetch(`/v1/artists/${artistId}/top-tracks?market=${market}`,"GET");
  const items = r?.tracks || [];
  _topTracksCache.set(key, items);
  return items;
}
function isrcVariants(isrcRaw){
  const s=String(isrcRaw||"").trim(); if(!s) return []; const up=s.toUpperCase();
  const nohy=up.replace(/-/g,""); const hy = up.includes("-")? up : up.replace(/^(.{2})(.{3})(.{2})(.{5})$/,"$1-$2-$3-$4");
  return Array.from(new Set([up, nohy, hy]));
}
function topArtistName(artistStr){
  const s=String(artistStr||""); const m=s.split(/,|;|&| with | feat\.? | featuring | ft\.? /i); return (m[0]||"").trim();
}
function makeQueries(item){
  const queries=[]; const full=String(item.name||"").trim(); const base=full.split(/\s+-\s+/)[0]||full; const art=topArtistName(item.artist||""); const rem=String(item.remixer||"").trim();
  if(item.isrc){ for(const v of isrcVariants(item.isrc)) queries.push({q:`isrc:${v}`,type:"isrc"}); }
  if(art){ queries.push({q:`track:"${base}" artist:"${art}"`,type:"field"}); if(full!==base) queries.push({q:`track:"${full}" artist:"${art}"`,type:"field"}); }
  if(rem){ queries.push({q:`"${base}" "${rem}" remix`,type:"free"}); if(full!==base) queries.push({q:`"${full}" "${rem}"`,type:"free"}); }
  queries.push({q:`"${base}" ${art||""}`.trim(),type:"free"}); if(full!==base) queries.push({q:`"${full}" ${art||""}`.trim(),type:"free"});
  const seen=new Set(); return queries.filter(x=>!seen.has(x.q)&&seen.add(x.q));
}
function scoreCandidate(item, cand){
  const candTitle = `${cand.name}${cand.version? " - "+cand.version:""}`;
  const candToks = tokensTitle(candTitle);
  const itemToks = tokensTitle(item.name);
  const baseToks = tokensTitle(item.name.split(/\s+-\s+/)[0]||item.name);
  const t1=jaccard(itemToks,candToks), t2=jaccard(baseToks,candToks);
  const titleScore=Math.max(t1,t2);
  const vi=canonVersion(item.name), vc=canonVersion(candTitle);
  const verScore=0.6*jaccard(vi.kinds,vc.kinds)+0.4*jaccard(vi.remTok,vc.remTok);
  return 0.80*titleScore + 0.20*verScore; // ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDã§ãƒ•ã‚£ãƒ«ã‚¿ã™ã‚‹ãŸã‚ååˆ†
}
async function searchOnce(q, market){
  const r = await spFetch(`/v1/search?q=${encodeURIComponent(q)}&type=track&limit=10&market=${market}`,"GET");
  return r?.tracks?.items || [];
}
async function resolveUriOne(item){
  const key = JSON.stringify({n:item.name||"", i:(item.isrc||""), A:(item.artistIds||[]).join(",")});
  if(_resolveCache.has(key)) return _resolveCache.get(key);
  if(item.id && item.id.length===22){ const u="spotify:track:"+item.id; _resolveCache.set(key,u); return u; }

  // å¼·åˆ¶ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDï¼ˆæŒ‡å®šãŒãªã‘ã‚Œã°FORCEDã‚’ä½¿ã†ï¼‰
  const artistIds = (item.artistIds && item.artistIds.length ? item.artistIds : FORCED_ARTIST_IDS);
  const mustFilterByArtist = artistIds.length>0;
  const markets=["from_token","JP","US","GB","DE","SE"];

  // 1) ISRC å…ˆè¡Œï¼ˆã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDã§ãƒ•ã‚£ãƒ«ã‚¿ï¼‰
  if(item.isrc){
    for(const v of isrcVariants(item.isrc)){
      try{
        const r=await spFetch(`/v1/search?q=${encodeURIComponent("isrc:"+v)}&type=track&limit=5&market=${markets[0]}`,"GET");
        const cand=(r?.tracks?.items||[]).find(t => !mustFilterByArtist || (t.artists||[]).some(a=>artistIds.includes(a.id)));
        if(cand?.id){ const u="spotify:track:"+cand.id; _resolveCache.set(key,u); return u; }
      }catch{}
    }
  }

  // 2) ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆID â†’ Top Tracksï¼ˆå¸‚å ´æ¨ªæ–­ï¼‰
  for(const mk of markets){
    for(const aid of artistIds){
      try{
        const tracks=await fetchTopTracksByArtist(aid, mk);
        let best=null;
        for(const cand of tracks){
          const sc=scoreCandidate(item,cand);
          if(!best || sc>best.sc) best={sc,cand};
        }
        if(best && best.sc>=0.70){ const u="spotify:track:"+best.cand.id; _resolveCache.set(key,u); return u; }
      }catch{}
    }
  }

  // 3) å¤šæ®µæ¤œç´¢ï¼ˆã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDã§å¼·åˆ¶ãƒ•ã‚£ãƒ«ã‚¿ï¼‰
  const queries = makeQueries(item);
  let best=null;
  try{
    for(const {q,type} of queries){
      for(const mk of markets){
        let items=[]; try{ items = await searchOnce(q,mk); }catch{}
        items = items.filter(t => !mustFilterByArtist || (t.artists||[]).some(a=>artistIds.includes(a.id)));
        for(const cand of items){
          const sc = (type==="isrc") ? 1.0 : scoreCandidate(item,cand);
          if(!best || sc>best.sc) best={sc,cand};
        }
        if(best && best.sc>=0.80) break;
      }
      if(best && best.sc>=0.80) break;
    }
  }catch{}

  const THRESH=0.62;
  if(best && best.sc>=THRESH && best.cand?.id){
    const uri="spotify:track:"+best.cand.id; _resolveCache.set(key,uri); return uri;
  }
  return "";
}
async function toUrisResolved(items){
  const uris=[]; let ok=0,ng=0; for(const it of items){ const u=await resolveUriOne(it); if(u){uris.push(u); ok++;} else {ng++;} } log(`ğŸ”— URIè§£æ±º: æˆåŠŸ${ok} / å¤±æ•—${ng}`); return uris;
}

/*** ä¸Šæ›¸ã ***/
async function replacePlaylist(pid, uris){
  const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
  if(!chunks.length) chunks.push([]);
  await spFetch(`/v1/playlists/${pid}/tracks`,"PUT",{uris:chunks[0]}); log(`ğŸ§¹ ç½®æ›: ${chunks[0].length}ä»¶`);
  for(let i=1;i<chunks.length;i++){ await spFetch(`/v1/playlists/${pid}/tracks`,"POST",{uris:chunks[i]}); log(`â• è¿½åŠ : ${chunks[i]}`); }
}
function extractPlaylistId(s){ s=String(s||""); let m=s.match(/playlist\/([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/^([A-Za-z0-9]{22})$/); if(m) return m[1]; return ""; }

/*** ãƒ¡ã‚¤ãƒ³å…¨è‡ªå‹• ***/
async function autoFlow(){
  try{
    clearLog(); log("ğŸ§  åˆ—è‡ªå‹•æ¤œå‡ºâ†’å†…å®¹çªåˆâ†’URIè§£æ±ºâ†’ä¸Šæ›¸ãâ€¦");

    // 1) ã‚½ãƒ¼ã‚¹åˆ—æ¤œå‡º & ç´¢å¼•
    const srcCols=pickSourceColumns(sourceRows);
    const srcIdx=buildSourceIndex(srcCols);

    // 2) åˆ†æåˆ—æ¤œå‡ºï¼ˆã‚½ãƒ¼ã‚¹ã‚¿ã‚¤ãƒˆãƒ«ã§ title é¸å®šï¼‰
    const anCols=pickAnalyticColumns(analyticsRows, srcIdx.titles);

    log(`ğŸ“‘ æ¤œå‡º:
[ã‚½ãƒ¼ã‚¹] id:${srcCols.idCol||"-"}, isrc:${srcCols.isrcCol||"-"}, artistId:${srcCols.artistIdCol||"-"}, title:${srcCols.nameCol||"-"}, version:${srcCols.verCol||"-"}, artist:${srcCols.artistCol||"-"}, remix:${srcCols.remixCol||"-"}
[åˆ†æ ] id:${anCols.idCol||"-"}, isrc:${anCols.isrcCol||"-"}, title:${anCols.nameCol||"-"}, artist:${anCols.artistCol||"-"}`);

    // 3) è‡ªå‹•çªåˆ
    const {rows:matched, thr, diag}=autoMatch(srcIdx, anCols);
    log(`ğŸ” è¨ºæ–­: exact=${diag.exact}, fuzzy=${diag.fuzzy}, æœªä¸€è‡´=${diag.none}, æ¡ç”¨=${matched.length}/${analyticsRows.length}, ã—ãã„å€¤=${thr.toFixed(2)}`);
    if(!matched.length){ log("âŒ ãƒãƒƒãƒ0ä»¶ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã®è¡¨è¨˜ã‚†ã‚Œã‚’ç¢ºèªã€‚"); return; }

    // 4) æ¤œç´¢ç”¨ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åŸ‹ã‚ï¼ˆï¼‹å¼·åˆ¶ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDåˆæµï¼‰
    for(const r of matched){
      r.id = srcCols.idCol? extractTrackId(r.s[srcCols.idCol]):"";
      r.isrc = srcCols.isrcCol? String(r.s[srcCols.isrcCol]||"").toUpperCase():"";
      const title = String(r.s[srcCols.nameCol]||"").trim();
      const ver   = String(r.s[srcCols.verCol]||"").trim();
      r.name   = (!ver || /original\s*mix/i.test(ver)) ? title : `${title} - ${ver}`;
      r.artist = String(r.s[srcCols.artistCol]||"");
      r.remixer= String(r.s[srcCols.remixCol]||"");
      const srcAid = srcCols.artistIdCol ? extractArtistIds(r.s[srcCols.artistIdCol]) : [];
      r.artistIds = Array.from(new Set([...(srcAid||[]), ...FORCED_ARTIST_IDS]));
    }

    // 5) ã‚¹ã‚³ã‚¢åŒ– â†’ ä¸Šä½æŠ½å‡º
    const scored=computeScores(matched, anCols);
    const finalN=+$("finalN").value||130;
    const top=scored.slice(0,Math.max(finalN,130));
    const layout=(list,maxN)=>{ const out=[]; for(const it of list){ if(out.length>=maxN) break; const r=(it.remixer||"").toLowerCase(); if(out.length>0 && r && (out[out.length-1].remixer||"").toLowerCase()===r) continue; out.push(it);} for(const it of list){ if(out.length>=maxN) break; if(out.includes(it)) continue; out.push(it);} return out; };
    const edUK=layout(top,finalN), edUS=layout(top,finalN), edEU=layout(top,finalN), edWO=layout(top,finalN);

    // 6) URIè§£æ±ºï¼ˆå¼·åŒ–ï¼‰
    log("ğŸ”— URIè§£æ±ºï¼ˆã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDåˆ¶ç´„ï¼‹å¤šæ®µï¼‰â€¦");
    const uriUK=await toUrisResolved(edUK), uriUS=await toUrisResolved(edUS), uriEU=await toUrisResolved(edEU), uriWO=await toUrisResolved(edWO);
    const total=[uriUK,uriUS,uriEU,uriWO].reduce((a,b)=>a+b.length,0), target=finalN*4;
    const rate= total / Math.max(1,target);
    log(`ğŸ“ˆ è§£æ±ºç‡: ${(rate*100).toFixed(1)}%  (${total}/${target})`);
    if(rate<0.60){ log("â›” è§£æ±ºç‡ãŒä½ã„ãŸã‚ä¸­æ–­ã€‚ISRC/ã‚¿ã‚¤ãƒˆãƒ«è¡¨è¨˜ã‚’ç¢ºèªã€‚"); return; }

    // 7) ä¸Šæ›¸ã
    if(!isAuthed()) throw new Error("Spotifyæœªæ¥ç¶šã€‚ã‚µã‚¤ãƒ³ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚");
    const pidUK=extractPlaylistId($("plUK").value), pidUS=extractPlaylistId($("plUS").value), pidEU=extractPlaylistId($("plEU").value), pidWO=extractPlaylistId($("plWORLD").value);
    if(!(pidUK&&pidUS&&pidEU&&pidWO)) throw new Error("ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆURL/IDãŒä¸æ­£ã§ã™ã€‚");

    if(AUTO_WRITE){
      log("ğŸš€ ä¸Šæ›¸ãé–‹å§‹â€¦ï¼ˆ429ã¯è‡ªå‹•å¾…æ©Ÿï¼‰");
      await replacePlaylist(pidUK,uriUK); await replacePlaylist(pidUS,uriUS); await replacePlaylist(pidEU,uriEU); await replacePlaylist(pidWO,uriWO);
      log("âœ… å®Œäº†");
    }else{
      log("ğŸ‘€ ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ã¿ï¼ˆAUTO_WRITE=falseï¼‰");
    }
  }catch(e){ log("ğŸ’¥ ERROR: "+e.message); console.error(e); }
}

/*** ç›£è¦–ï¼†ãƒˆãƒªã‚¬ ***/
function maybeAutoGo(){
  if(!AUTO_RUN) return;
  if(isAuthed() && filesReady()) autoFlow();
}

/*** events ***/
$("btnConnect").onclick=startAuth;
$("btnReset").onclick=()=>{ Object.values(LS).forEach(k=>localStorage.removeItem(k)); setStatus(); log("ğŸ§½ ãƒ­ãƒ¼ã‚«ãƒ«ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤"); };
$("btnCheck").onclick=async()=>{ try{ await refreshTokenIfNeeded(); const me=await spFetch("/v1/me","GET"); $("status").textContent=`æ¥ç¶šä¸­ï¼ˆ${me.display_name||me.id}ï¼‰`; log("âœ… APIç¢ºèª OK"); }catch(e){ log("âš ï¸ æ¥ç¶šã‚¨ãƒ©ãƒ¼: "+e.message);} };
$("fileSource").addEventListener("change",loadFiles);
$("fileAnalytics").addEventListener("change",loadFiles);
setStatus(); log("Ready. 1) ã‚µã‚¤ãƒ³ã‚¤ãƒ³ â†’ 2) 2ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ â†’ï¼ˆå…¨è‡ªå‹•ï¼‰â†’ ä¸Šæ›¸ã");
</script>
</body></html>
