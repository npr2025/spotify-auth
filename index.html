<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TDCS Editions Builder â€” Deep Divergence + Unique + No-Adj-Remixer + BP150</title>
<style>
:root{--bg:#0b1220;--fg:#cfe3ff}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:1180px;margin:32px auto;padding:0 12px}
h1{margin:0 0 8px}
fieldset{border:1px solid #ddd;border-radius:10px;padding:14px;margin:14px 0}
legend{font-weight:600}
label{display:block;margin:6px 0}
input[type="text"],input[type="number"],select,textarea{width:100%;max-width:880px;padding:6px 8px;border:1px solid #ccc;border-radius:6px}
input[type="file"]{margin:4px 0}
textarea{min-height:96px}
button{padding:9px 12px;border:1px solid #bbb;border-radius:8px;background:#fff;cursor:pointer;margin:6px 8px 0 0}
button:disabled{opacity:.5;cursor:not-allowed}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.grid4{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
small.hint{color:#666}
#log{white-space:pre-wrap;background:var(--bg);color:var(--fg);padding:12px;border-radius:8px;min-height:280px}
#progWrap{position:relative;height:12px;background:#e6eaf2;border-radius:6px;overflow:hidden;margin:6px 0}
#progBar{height:100%;width:0%;background:#4a90e2;transition:width .2s ease}
#progLine{font-variant-numeric:tabular-nums;margin:4px 0 0 0;color:#333}
.hidden{display:none}
.inline{display:inline-block;margin-right:16px}
.mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
.badge{display:inline-block;margin-left:8px;padding:2px 8px;border:1px solid #ccc;border-radius:999px;font-size:12px}
</style>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<h1>TDCS Editions Builder <span class="badge">Deep Divergence</span><span class="badge">15å›ºå®š</span><span class="badge">ç‰ˆå†…ãƒ¦ãƒ‹ãƒ¼ã‚¯</span><span class="badge">No Adj. Remixer</span><span class="badge">BP150</span></h1>
<p id="status">æœªæ¥ç¶š</p>
<div>
  <button id="btnConnect">Spotifyã«ã‚µã‚¤ãƒ³ã‚¤ãƒ³</button>
  <button id="btnReset">åˆæœŸåŒ–ï¼ˆä¿å­˜ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤ï¼‰</button>
  <button id="btnCheck">æ¥ç¶šãƒã‚§ãƒƒã‚¯</button>
</div>

<fieldset>
  <legend>å›ºå®š</legend>
  <div class="grid2">
    <label>CLIENT_ID <input type="text" id="clientId" value="1fd6350fcf4945a0b3ddffa2d5730d4e"></label>
    <label>REDIRECT_URI <input type="text" id="redir" value="" disabled></label>
  </div>
  <small class="hint">â€» REDIRECT_URI ã¯è‡ªå‹•ã§ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã® <code>callback.html</code> ã«è¨­å®šã€‚</small>
</fieldset>

<fieldset>
  <legend>ãƒ¢ãƒ¼ãƒ‰é¸æŠ</legend>
  <label class="inline"><input type="radio" name="mode" id="modeCsv" checked> CSVãƒ¢ãƒ¼ãƒ‰ï¼ˆCSVå†…ã®æ›²ã ã‘ï¼‰</label>
  <label class="inline"><input type="radio" name="mode" id="modeAuto"> Autoãƒ¢ãƒ¼ãƒ‰ï¼ˆå¸‚å ´èª¿æŸ»ï¼CSVä¸è¦ï¼‰</label>
</fieldset>

<fieldset id="boxCommon">
  <legend>å…±é€šè¨­å®šï¼ˆ5ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ï¼‰</legend>
  <div class="grid4">
    <label>UK ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆID/URL <input id="plUK" type="text" placeholder="ç©ºãªã‚‰æ–°è¦ä½œæˆ"></label>
    <label>US ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆID/URL <input id="plUS" type="text" placeholder="ç©ºãªã‚‰æ–°è¦ä½œæˆ"></label>
    <label>EU ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆID/URL <input id="plEU" type="text" placeholder="ç©ºãªã‚‰æ–°è¦ä½œæˆ"></label>
    <label>WORLD ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆID/URL <input id="plWORLD" type="text" placeholder="ç©ºãªã‚‰æ–°è¦ä½œæˆ"></label>
  </div>
  <div class="grid4">
    <label>BEATPORT ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆID/URL <input id="plBP" type="text" placeholder="ç©ºãªã‚‰æ–°è¦ä½œæˆï¼ˆ150æ›²ï¼‰"></label>
    <label>APIé–“éš”(ms) <input id="gap" type="number" value="1000"></label>
    <label>å„ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³å‡ºåŠ›æ•°ï¼ˆUK/US/EU/WORLDï¼‰<input id="finalN" type="number" value="130"></label>
    <label>ä¸»è¦ãƒãƒ¼ã‚±ãƒƒãƒˆï¼ˆå„ªå…ˆé †ï¼‰<input id="markets" type="text" value="ES,US,GB,NZ"></label>
  </div>
  <div class="grid4">
    <label>UKãƒ—ãƒªã‚»ãƒƒãƒˆ
      <select id="presetUK"><option selected>waves</option><option>rise</option><option>drop</option><option>dj</option></select>
    </label>
    <label>USãƒ—ãƒªã‚»ãƒƒãƒˆ
      <select id="presetUS"><option>waves</option><option selected>rise</option><option>drop</option><option>dj</option></select>
    </label>
    <label>EUãƒ—ãƒªã‚»ãƒƒãƒˆ
      <select id="presetEU"><option>waves</option><option>rise</option><option selected>drop</option><option>dj</option></select>
    </label>
    <label>WORLDãƒ—ãƒªã‚»ãƒƒãƒˆ
      <select id="presetWORLD"><option>waves</option><option>rise</option><option>drop</option><option selected>dj</option></select>
    </label>
  </div>
  <div class="grid3">
    <label>BEATPORTãƒ—ãƒªã‚»ãƒƒãƒˆ
      <select id="presetBP"><option selected>bp</option><option>drop</option><option>dj</option></select>
    </label>
    <label>Beatportè¿½åŠ æ›²æ•°ï¼ˆ+ï¼‰<input id="bpExtra" type="number" value="20" min="1" max="50"></label>
    <label>å…¬é–‹å¯å¦
      <select id="pub"><option value="0" selected>éå…¬é–‹</option><option value="1">å…¬é–‹</option></select>
    </label>
  </div>

  <label><input id="strictMarket" type="checkbox" checked> å¸‚å ´ä¸€è‡´ã‚’ã€Œå„ªå…ˆæ¡ç”¨ã€ã«ã™ã‚‹ï¼ˆä¸è¶³åˆ†ã¯å€™è£œã§è£œå®Œï¼‰</label>
  <label><input id="allowCrossDup" type="checkbox"> ç‰ˆé–“é‡è¤‡ã‚’è¨±å¯ï¼ˆâ€»OFF=ç‰ˆé–“ã®ä¸­èº«è¢«ã‚Šã‚’æŠ‘åˆ¶ï¼‰</label>
  <label><input id="allowWithinDup" type="checkbox"> ç‰ˆå†…é‡è¤‡ã‚’è¨±å¯ï¼ˆâ€»é€šå¸¸ã¯OFFã§ãƒ¦ãƒ‹ãƒ¼ã‚¯ç¶­æŒï¼‰</label>

  <div class="grid3">
    <label>å·®åˆ¥åŒ–ãƒ¬ãƒ™ãƒ«
      <select id="diverge">
        <option value="high" selected>HIGHï¼ˆå¤§å·®ï¼‰</option>
        <option value="medium">MEDIUM</option>
        <option value="low">LOW</option>
      </select>
    </label>
    <label>æ–°è¦ä½œæˆæ™‚ã®ãƒ™ãƒ¼ã‚¹å <input id="baseName" type="text" value="TDCS Editions"></label>
    <label>èª¬æ˜æ–‡ã®è¿½è¨˜ <input id="descNote" type="text" value="Auto-built (15 pinned; deep per-edition profiles; unique; no consecutive remixer; BP=+20)"></label>
  </div>
</fieldset>

<fieldset id="boxIntro">
  <legend>ã‚¤ãƒ³ãƒˆãƒ­å›ºå®šï¼ˆå…ˆé ­ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬é€šã‚Šã«å…±é€šåŒ–ï¼‰</legend>
  <div class="grid2">
    <label>ãƒ†ãƒ³ãƒ—ãƒ¬PL ID/URL
      <input id="introTpl" type="text" value="https://open.spotify.com/playlist/1v9jLD4ZxIaCDap2fPKGcJ?si=3f561ed29e554a20&pt=657aba40d6c86a1fffe7022ec0398916">
    </label>
    <label>ã‚¤ãƒ³ãƒˆãƒ­æ›²æ•°(10â€“20)
      <input id="introLen" type="number" value="15" min="10" max="20">
    </label>
  </div>
  <small class="hint">ãƒ†ãƒ³ãƒ—ãƒ¬å†…ã«ãªã„æ›²ã¯è‡ªå‹•ã‚¹ã‚­ãƒƒãƒ—ï¼ˆå€™è£œå¤–ã¯ä½¿ã„ã¾ã›ã‚“ï¼‰ã€‚æœªå…¥åŠ›æ™‚ã¯å€™è£œãƒ—ãƒ¼ãƒ«ã®å…ˆé ­ã‹ã‚‰å›ºå®šã€‚</small>
</fieldset>

<fieldset id="boxCsv">
  <legend>CSVãƒ¢ãƒ¼ãƒ‰ï¼ˆã“ã®CSVã ã‘ã§çµ„ã‚€ï¼‰</legend>
  <label>ã‚½ãƒ¼ã‚¹CSV <input id="fileCSV" type="file" accept=".csv"></label>
  <small class="hint">åˆ—ã¯è‡ªå‹•æ¤œå‡ºï¼štrack_uri/url/id, isrc, title/version, artistã€‚CSVé¸æŠâ†’è‡ªå‹•å®Ÿè¡Œã€‚</small>
</fieldset>

<fieldset id="boxAuto" class="hidden">
  <legend>Autoãƒ¢ãƒ¼ãƒ‰ï¼ˆå¸‚å ´èª¿æŸ»ã§é¸æ›²ï¼CSVä¸è¦ï¼‰</legend>
  <label>æ¤œç´¢ã‚¯ã‚¨ãƒªï¼ˆ1è¡Œ1ã‚¯ã‚¨ãƒª / Spotifyæ¤œç´¢æ§‹æ–‡ï¼‰
    <textarea id="autoQueries" class="mono">artist:"The Darrow Chem Syndicate" "drum and bass" year:1994-2016 -bootleg -"unofficial" -"DJ Mix" -"Continuous Mix" -podcast -mashup -cover -karaoke
label:"Nipponeer Records" "drum and bass" year:1994-2016 -bootleg -"unofficial" -"DJ Mix" -"Continuous Mix" -podcast -mashup -cover -karaoke</textarea>
  </label>
  <div class="grid3">
    <label>1ã‚¯ã‚¨ãƒªæœ€å¤§å–å¾— <input id="autoLimit" type="number" value="60"></label>
    <label>å…¨ä½“æœ€å¤§å€™è£œæ•° <input id="autoCap" type="number" value="300"></label>
    <label>é‡è¤‡é™¤å»
      <select id="autoDedup"><option value="1" selected>ã™ã‚‹</option><option value="0">ã—ãªã„</option></select>
    </label>
  </div>
</fieldset>

<div>
  <button id="btnRun">ãƒ“ãƒ«ãƒ‰å®Ÿè¡Œï¼ˆCSV/Autoï¼‰</button>
  <button id="btnExportXlsx" disabled>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆXLSXï¼‰</button>
  <button id="btnExportCsv"  disabled>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆCSVï¼‰</button>
</div>

<fieldset>
  <legend>é€²æ—</legend>
  <div id="progWrap" class="hidden"><div id="progBar"></div></div>
  <div id="progLine">0% â€” å¾…æ©Ÿä¸­</div>
</fieldset>

<fieldset>
  <legend>ãƒ­ã‚°</legend>
  <pre id="log">Bootingâ€¦</pre>
</fieldset>

<script>
/* ===== Errors ===== */
window.onerror=(m,src,lin,col,err)=>{ const el=document.getElementById("log"); el.textContent+=(el.textContent?"\n":"")+"ğŸ’¥ ScriptError: "+m+" @"+lin+":"+col; console.error(err||m); };
window.addEventListener("unhandledrejection",(e)=>{ const el=document.getElementById("log"); el.textContent+=(el.textContent?"\n":"")+"ğŸ’¥ PromiseRejection: "+(e.reason&&e.reason.message?e.reason.message:String(e.reason)); console.error(e.reason); });

/* ===== Consts ===== */
const zws=/[\u200B-\u200D\uFEFF]/g;
const LS={acc:"sp_access_token",ref:"sp_refresh_token",exp:"sp_token_exp",ver:"sp_code_verifier"};
const SCOPES="playlist-modify-public playlist-modify-private ugc-image-upload";

/* ===== DOM/UTIL ===== */
const $=(id)=>document.getElementById(id);
const val=(id,f="")=>{ const el=$(id); return el && "value" in el ? el.value : f; };
const setHidden=(id,on)=>{ const el=$(id); if(!el) return; el.classList[on?"add":"remove"]("hidden"); }
const log=(s)=>{ const el=$("log"); el.textContent+=(el.textContent?"\n":"")+s; el.scrollTop=el.scrollHeight; };
const progress=(p,msg)=>{ $("progWrap").classList.remove("hidden"); $("progBar").style.width=Math.max(0,Math.min(100,p))+"%"; if(msg) $("progLine").textContent=Math.round(p)+"% â€” "+msg; }
const subProgress=(i,t,s,e,l)=>{ const f=t?i/t:0; progress(s+(e-s)*f,`${l} (${i}/${t})`); }
const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
const round4=(x)=> (typeof x==="number"&&isFinite(x))?Math.round(x*10000)/10000:"";
const uniq=(a)=>Array.from(new Set(a));

/* ===== Redirect URI ===== */
(function(){ const base = location.origin + location.pathname.replace(/index\.html?$/,''); const uri = base + "callback.html"; const red = $("redir"); if(red) red.value = uri; })();

/* ===== Auth ===== */
const isAuthed=()=> !!localStorage.getItem(LS.acc) && Date.now() < (+localStorage.getItem(LS.exp)||0)-5000;
function setStatus(){ $("status").textContent=isAuthed()?"æ¥ç¶šä¸­ï¼ˆOKï¼‰":"æœªæ¥ç¶š"; if(isAuthed() && _pending) resolveAndWrite(_pending); }
async function startAuth(){
  const CLIENT_ID = val("clientId").replace(zws,"").trim(); const REDIRECT_URI = val("redir").trim();
  if(!CLIENT_ID){ alert("CLIENT_ID ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"); return; }
  let v=""; const u8=new Uint8Array(64); crypto.getRandomValues(u8); for(let i=0;i<u8.length;i++) v+=String.fromCharCode(97+(u8[i]%26));
  localStorage.setItem(LS.ver,v);
  const h=new Uint8Array(await crypto.subtle.digest("SHA-256",new TextEncoder().encode(v)));
  let b=""; for(const x of h) b+=String.fromCharCode(x);
  const ch=btoa(b).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  const u=new URL("https://accounts.spotify.com/authorize");
  u.searchParams.set("response_type","code"); u.searchParams.set("client_id",CLIENT_ID);
  u.searchParams.set("redirect_uri",REDIRECT_URI); u.searchParams.set("code_challenge_method","S256");
  u.searchParams.set("code_challenge",ch); u.searchParams.set("scope",SCOPES);
  location.href=u.toString();
}
async function refreshTokenIfNeeded(){
  const exp=+(localStorage.getItem(LS.exp)||0);
  if(Date.now()<exp-5000) return;
  const CLIENT_ID = val("clientId").replace(zws,"").trim(); const rt=localStorage.getItem(LS.ref); if(!rt) return;
  const body=new URLSearchParams(); body.set("grant_type","refresh_token"); body.set("refresh_token",rt); body.set("client_id",CLIENT_ID);
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok){ log("âš ï¸ refreshå¤±æ•— "+r.status); return; }
  const j=await r.json(); localStorage.setItem(LS.acc,j.access_token); localStorage.setItem(LS.exp,String(Date.now()+j.expires_in*1000));
  if(j.refresh_token) localStorage.setItem(LS.ref,j.refresh_token);
}
async function spFetch(path,method="GET",body=null){
  await refreshTokenIfNeeded();
  const gap=+(val("gap","1000")||1000); await sleep(gap);
  for(let a=0;a<5;a++){
    const init={method,headers:{"Authorization":"Bearer "+localStorage.getItem(LS.acc),"Content-Type":"application/json"}};
    if(body) init.body=JSON.stringify(body);
    const r=await fetch("https://api.spotify.com"+path,init);
    if(r.status===401){ await refreshTokenIfNeeded(); continue; }
    if(r.status===429){ const ra=+(r.headers.get("Retry-After")||2); log("â³429â†’"+ra+"så¾…æ©Ÿ"); await sleep(ra*1000); continue; }
    if(!r.ok){
      const t=await r.text();
      if(r.status===403 && method==="GET"){ log(`âš ï¸ 403 GET ${path.slice(0,60)} â€¦ ç¶šè¡Œ`); return null; }
      throw new Error(`Spotify ${r.status}: ${(t||"").slice(0,200)} @ ${path}`);
    }
    if(r.status===204) return null;
    return await r.json();
  }
  throw new Error("Spotify API max retries");
}
let _me=null; async function getMe(){ if(_me) return _me; _me=await spFetch("/v1/me","GET"); return _me; }

/* ===== CSV ===== */
let csvRows=[];
function readCSV(file){return new Promise((res,rej)=>Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>res(r.data),error:rej}));}
const ISRC_RE=/^[A-Z]{2}-?[A-Z0-9]{3}-?\d{2}-?\d{5}$/i;
const extractTrackId=(raw)=>{const s=String(raw||"").trim(); if(!s) return ""; let m=s.match(/spotify:track:([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/open\.spotify\.com\/track\/([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/\/track\/([A-Za-z0-9]{22})(?:\?|$)/); if(m) return m[1]; m=s.match(/^([A-Za-z0-9]{22})$/); if(m) return m[1]; return ""; }
function columns(rows){const s={},out=[]; for(let i=0;i<Math.min(400,rows.length);i++){ for(const k of Object.keys(rows[i])) if(!s[k]){s[k]=1; out.push(k);} } return out;}
function pickByName(cols,pref){ const L=cols.map(c=>[c,c.toLowerCase()]); for(const p of pref){const n=p.toLowerCase(); const hit=L.find(([,m])=>m===n||m.includes(n)); if(hit) return hit[0];} return ""; }
function guessCsvColumns(rows){
  const cols=columns(rows);
  const scId=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<1500;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(/spotify:track:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/track\/[A-Za-z0-9]{22}/.test(v)||/^[A-Za-z0-9]{22}$/.test(v))m++;} return n?m/n:0;}
  const scIsrc=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<1500;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(ISRC_RE.test(v))m++;} return n?m/n:0;}
  let idCol=""; let best=-1; for(const c of cols){const sc=scId(c); if(sc>best){best=sc; idCol=c;}}
  const isrcCol=cols.reduce((a,c)=> (scIsrc(c)>(a.score||-1)?{c,score:scIsrc(c)}:a),{}).c || pickByName(cols,["isrc","isrc_code"]);
  const tCol=pickByName(cols,["title","track","name","æ›²å","ã‚¿ã‚¤ãƒˆãƒ«"])||cols[0];
  const vCol=pickByName(cols,["version","ãƒãƒ¼ã‚¸ãƒ§ãƒ³","mix","remix","edit"]);
  const aCol=pickByName(cols,["artist","artists","ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ"])||cols[0];
  return {idCol,isrcCol,tCol,vCol,aCol};
}

/* ===== Search/Resolve ===== */
const _isrcCache=new Map();
async function searchOnce(q,m,limit=10,offset=0){
  const r=await spFetch(`/v1/search?q=${encodeURIComponent(q)}&type=track&limit=${limit}&offset=${offset}&market=${m}`,"GET");
  return (r&&r.tracks&&r.tracks.items)?r.tracks.items:[];
}
async function searchMany(q,m,need=60){
  const out=[]; const step=50;
  for(let off=0; off<need; off+=step){
    const items=await searchOnce(q,m,Math.min(step,need-off),off);
    if(!items||!items.length) break;
    out.push(...items);
  }
  return out;
}
function isrcVariants(s){ s=String(s||"").trim(); if(!s) return []; const up=s.toUpperCase(); const no=up.replace(/-/g,""); const hy=up.indexOf("-")>=0?up:up.replace(/^(.{2})(.{3})(.{2})(.{5})$/,"$1-$2-$3-$4"); return uniq([up,no,hy]); }
function makeQueriesFromRow(row,cols){
  const id=cols.idCol?extractTrackId(row[cols.idCol]):"";
  const isrc=String(cols.isrcCol?row[cols.isrcCol]:"").trim();
  const title=(row[cols.tCol]||"").toString().trim();
  const version=(cols.vCol? (row[cols.vCol]||"") : "").toString().trim();
  const artist=(row[cols.aCol]||"").toString().trim();
  const q=[];
  if(id) q.push({type:"id",q:id});
  if(isrc && ISRC_RE.test(isrc)){ for(const v of isrcVariants(isrc)) q.push({type:"isrc",q:"isrc:"+v}); }
  if(title && artist){
    const base=title.split(/\s+-\s+/)[0];
    q.push({type:"field",q:`track:"${base}" artist:"${artist}"`});
    if(version) q.push({type:"field",q:`track:"${title}" artist:"${artist}"`});
    q.push({type:"free",q:`"${base}" ${artist}`});
  }else if(title){ q.push({type:"free",q:title}); }
  return {q,isrc,id};
}
async function resolveOne(row,cols,markets){
  const {q,isrc,id}=makeQueriesFromRow(row,cols);
  if(id) return "spotify:track:"+id;
  if(isrc){ for(const v of isrcVariants(isrc)){ if(_isrcCache.has(v)) return _isrcCache.get(v); } }
  for(const qq of q){
    for(const m of markets){
      try{
        const items=await searchOnce(qq.q,m,10,0);
        if(items && items.length){ const u="spotify:track:"+items[0].id; if(isrc) for(const v of isrcVariants(isrc)) _isrcCache.set(v,u); return u; }
      }catch(_){}
    }
  }
  return "";
}

/* ===== Details/Features ===== */
async function fetchTrackDetailsByUris(uris){
  const ids=[], map=new Map();
  for(const u of uris){ if(u) ids.push(u.replace("spotify:track:","")); }
  for(let i=0;i<ids.length;i+=50){
    const slice=ids.slice(i,i+50); if(!slice.length) continue;
    const r=await spFetch("/v1/tracks?ids="+slice.join(","),"GET");
    const arr=(r&&r.tracks)||[]; for(const t of arr){ if(t&&t.id) map.set("spotify:track:"+t.id,t); }
  }
  return map;
}
async function fetchAudioFeaturesByUris(uris){
  const ids=[], feats=new Map(); for(const u of uris){ if(u) ids.push(u.replace("spotify:track:","")); }
  for(let i=0;i<ids.length;i+=100){
    const slice=ids.slice(i,i+100);
    if(!slice.length) continue;
    const r=await spFetch("/v1/audio-features?ids="+slice.join(","),"GET");
    const arr=(r&&r.audio_features)||[]; for(const f of arr){ if(f&&f.id) feats.set("spotify:track:"+f.id,f); }
  }
  return feats;
}

/* ===== Ordering Cost ===== */
const camelot=(key,mode)=>({num:[8,3,10,5,0,7,2,9,4,11,6,1][(key||0)%12],isMinor:mode===0});
const keyDistance=(a,b)=>{ if(!a||!b||a.key==null||b.key==null) return 2; const A=camelot(a.key,a.mode), B=camelot(b.key,b.mode); let d=Math.abs(A.num-B.num); d=Math.min(d,12-d); let pen=d/6; if(A.isMinor!==B.isMinor) pen+=0.4; return pen; }
function nextCost(a,b,preset){
  const dTempo=(a&&b&&a.tempo&&b.tempo)?Math.min(1,Math.abs(a.tempo-b.tempo)/16):0.5;
  const dKey=keyDistance(a,b); const dEner=(a&&b)?Math.abs((a.energy||0)-(b.energy||0)):0.5;
  const dVal=(a&&b)?Math.abs((a.valence||0)-(b.valence||0)):0.5;
  if(preset==="dj")   return 0.45*dTempo+0.35*dKey+0.15*dEner+0.05*dVal;
  if(preset==="rise") return 0.35*dTempo+0.20*dKey+0.35*dEner+0.10*dVal;
  if(preset==="drop") return 0.35*dTempo+0.20*dKey+0.35*dEner+0.10*dVal;
  if(preset==="bp")   return 0.25*dTempo+0.25*dKey+0.45*dEner+0.05*dVal;
  return               0.40*dTempo+0.25*dKey+0.25*dEner+0.10*dVal;
}

/* ===== Intro (pinned) ===== */
async function fetchPlaylistTrackUris(pid){
  const out=[]; let off=0;
  while(true){
    const r=await spFetch(`/v1/playlists/${pid}/tracks?limit=100&offset=${off}`,"GET");
    if(!r||!r.items||!r.items.length) break;
    for(const it of r.items){ const t=it && it.track; if(t && t.id) out.push("spotify:track:"+t.id); }
    off+=r.items.length; if(r.items.length<100) break;
  }
  return Array.from(new Set(out));
}
async function getPinnedIntro(basePool){
  const want=Math.max(10, Math.min(20, +(val("introLen","15")||15)));
  const tpl=(val("introTpl","")||"").trim();
  const poolSet=new Set(basePool);
  if(!tpl) return basePool.slice(0,want);
  const pid=extractPlaylistId(tpl);
  if(!pid){ log("âš ï¸ ã‚¤ãƒ³ãƒˆãƒ­: ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆIDãŒè§£é‡ˆã§ãã¾ã›ã‚“"); return basePool.slice(0,want); }
  const tplUris=await fetchPlaylistTrackUris(pid);
  const pinned=tplUris.filter(u=>poolSet.has(u)).slice(0,want);
  if(pinned.length<want) log(`â„¹ï¸ ã‚¤ãƒ³ãƒˆãƒ­: ãƒ†ãƒ³ãƒ—ãƒ¬å¤–ã§ ${want-pinned.length} æ›²ã‚¹ã‚­ãƒƒãƒ—ï¼ˆæ¡ç”¨ ${pinned.length}/${want}ï¼‰`);
  else log(`ğŸ›ï¸ ã‚¤ãƒ³ãƒˆãƒ­å›ºå®š: ${pinned.length}æ›²`);
  return pinned.length?pinned:basePool.slice(0,want);
}

/* ===== Meta (remixer/artist) ===== */
let URI_META=new Map();
function normalizeRemixer(s){ s=String(s||"").trim(); if(!s) return ""; s=s.replace(/\b(original|radio|extended|club)\b.*$/i,"").trim(); return s.toLowerCase(); }
function parseRemixerFromName(name){
  name=String(name||"");
  const pats=[/\(([^)]+?)\s+(?:re-?mix|mix|edit|version)\)/i, /-\s*([^-\(\[]+?)\s+(?:re-?mix|mix|edit|version)\b/i];
  for(const re of pats){ const m=name.match(re); if(m){ const r=m[1].trim(); if(/original|radio|extended/i.test(r)) return ""; return r; } }
  return "";
}
function buildUriMeta(uriList, tracksMap, hintRows=null, cols=null){
  const meta=new Map();
  for(let i=0;i<uriList.length;i++){
    const u=uriList[i]; const t=tracksMap.get(u);
    if(!u||!t) continue;
    let rem = (hintRows&&cols&&cols.vCol)? String(hintRows[i]?.[cols.vCol]||"") : "";
    if(!rem) rem=parseRemixerFromName(t.name);
    rem=normalizeRemixer(rem);
    const artistId=(t.artists&&t.artists[0]&&t.artists[0].id)||"";
    meta.set(u,{remixer:rem, artistId});
  }
  return meta;
}

/* ===== RNG/helpers ===== */
function seedHash(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619)>>>0; } return h>>>0; }
function rng(seed){ let x=seedHash(String(seed))||1; return ()=>{ x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/4294967296; } }
function seededShuffle(arr, seed){ const r=rng(seed); const a=arr.slice(0); for(let i=a.length-1;i>0;i++){ const j=Math.floor(r()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function jitterSmall(id, seed){ const j=seedHash(id+":"+seed)%1000; return (j/1000-0.5)*0.06; }
function scoreRise(f){ const tempo=f?.tempo??120, ener=f?.energy??0.5; return 0.6*ener+0.4*(tempo/200); }
function scoreDrop(f){ const tempo=f?.tempo??120, ener=f?.energy??0.5; return 0.7*ener+0.3*(tempo/200); }

/* ===== Tail ordering ===== */
function buildTailByPreset(prev, tail, feats, preset, editionSeed){
  tail = Array.isArray(tail) ? tail : [];
  if(tail.length===0) return [];
  const id8=(u)=>(u||"").slice(-8);
  if(preset==="rise"||preset==="drop"||preset==="bp"){
    const scored = tail.map(u=>{
      const f=feats.get(u)||{};
      const base=(preset==="rise")?scoreRise(f):(preset==="drop")?scoreDrop(f):((f.energy??0.5)*0.75 + (f.tempo??120)/260*0.25);
      return {u,score:base + jitterSmall(id8(u),editionSeed)};
    });
    scored.sort((a,b)=> (preset==="rise")? (a.score-b.score) : (b.score-a.score));
    return scored.map(x=>x.u);
  }
  if(preset==="dj"){
    const seq=[]; const pool=tail.slice(0);
    let cur=prev||pool[0];
    while(pool.length){
      let bestI=0, best=1e9;
      for(let i=0;i<pool.length;i++){
        const a=feats.get(cur)||{}, b=feats.get(pool[i])||{};
        let cost=nextCost(a,b,"dj"); cost += (seedHash((pool[i]||"")+":dj")%80)/1000;
        if(cost<best){ best=cost; bestI=i; }
      }
      const pick=pool.splice(bestI,1)[0]; seq.push(pick); cur=pick;
    }
    return seq;
  }
  const withE = tail.map(u=>({u,e:(feats.get(u)||{}).energy ?? 0.5}));
  const low=withE.slice().sort((a,b)=>a.e-b.e), high=withE.slice().sort((a,b)=>b.e-a.e);
  const snake=[]; let i=0,j=0; while(i<low.length||j<high.length){ if(j<high.length) snake.push(high[j++].u); if(i<low.length) snake.push(low[i++].u); }
  return seededShuffle(snake, editionSeed);
}

/* ===== No adjacent remixer/artist ===== */
function deAdjacentByKeyFrom(seq, keyFn, startIdx){
  let swaps=0, prevKey = startIdx>0 ? keyFn(seq[startIdx-1]) : "";
  for(let i=startIdx;i<seq.length;i++){
    const k=keyFn(seq[i]);
    if(prevKey && k && k===prevKey){
      let j=i+1; while(j<seq.length && keyFn(seq[j])===k) j++;
      if(j<seq.length){ const tmp=seq[i]; seq[i]=seq[j]; seq[j]=tmp; swaps++; }
    }
    prevKey = keyFn(seq[i]);
  }
  return swaps;
}
function postProcessNoAdjacency(fullSeq, pinnedLen){
  const remKey=(u)=> (URI_META.get(u)?.remixer)||"";
  const artKey=(u)=> (URI_META.get(u)?.artistId)||"";
  const s1=deAdjacentByKeyFrom(fullSeq, remKey, pinnedLen);
  const s2=deAdjacentByKeyFrom(fullSeq, artKey, pinnedLen);
  return {remix_swaps:s1, artist_swaps:s2};
}

/* ===== Unique helpers ===== */
function enforceUniqueWithin(seq, pinnedLen, primaryPool, fallbackPool, label="", banSet=null){
  seq = Array.isArray(seq) ? seq : [];
  pinnedLen = Math.max(0, Math.min(Number.isFinite(pinnedLen)?pinnedLen:0, seq.length));
  const targetLen = seq.length;
  const fixed = seq.slice(0, pinnedLen);
  const tail  = seq.slice(pinnedLen);
  const seen = new Set(fixed);
  const uniqTail = [];
  let dupCount=0;

  for(const u of tail){
    if(u && !seen.has(u) && !(banSet && banSet.has(u))){ seen.add(u); uniqTail.push(u); }
    else dupCount++;
  }

  const want = Math.max(0, tail.length);
  function refill(fromPool){
    const src = Array.isArray(fromPool)?fromPool:[];
    for(const u of src){
      if(uniqTail.length>=want) break;
      if(!u) continue;
      if(seen.has(u)) continue;
      if(banSet && banSet.has(u)) continue;
      seen.add(u); uniqTail.push(u);
    }
  }
  refill(primaryPool); if(uniqTail.length<want) refill(fallbackPool);

  const result = fixed.concat(uniqTail).slice(0, Math.max(0,targetLen));
  if(dupCount>0) log(`ğŸš« å†…é‡è¤‡ä¿®æ­£ ${label||""}: -${dupCount}ä»¶ â†’ æœ€çµ‚${result.length}`);
  return result;
}

/* ===== Edition profiles & gating ===== */
function getDiverge(){ const v = (document.getElementById("diverge")?.value)||"high"; return (v==="high"||v==="medium"||v==="low")?v:"high"; }
const DIV_LEVELS = {
  high:   { gate:1.00, artistCap:2, remixerCap:1 },
  medium: { gate:0.70, artistCap:3, remixerCap:2 },
  low:    { gate:0.50, artistCap:4, remixerCap:2 }
};
const EDITION_PROFILES = {
  UK:     { tempo:[166,178], energy:[0.55,0.85], valence:[0.30,0.55], danceability:[0.45,0.85], speechiness:[0.00,0.06], instrumentalness:[0.40,1.00], mode:0 },
  US:     { tempo:[168,176], energy:[0.70,0.98], valence:[0.50,0.85], danceability:[0.55,1.00], speechiness:[0.03,0.18], instrumentalness:[0.00,0.70], mode:1 },
  EU:     { tempo:[170,180], energy:[0.75,1.00], valence:[0.15,0.45], danceability:[0.45,0.85], speechiness:[0.00,0.10], instrumentalness:[0.30,1.00], mode:0 },
  WORLD:  { tempo:[160,182], energy:[0.45,0.95], valence:[0.20,0.80], danceability:[0.35,0.95] }
};
function _inRange(x,[a,b],gate){ if(x==null) return false; const c=(a+b)/2, w=(b-a)/2; const W=w*(1/Math.max(gate,0.01)); return (x>=c-W)&&(x<=c+W); }
function fitsProfile(feat, prof, gate){
  if(!feat) return false;
  const okTempo = prof.tempo? _inRange(feat.tempo, prof.tempo, gate) : true;
  const okEner  = prof.energy? _inRange(feat.energy, prof.energy, gate) : true;
  const okVal   = prof.valence? _inRange(feat.valence, prof.valence, gate) : true;
  const okDance = prof.danceability? _inRange(feat.danceability, prof.danceability, gate) : true;
  const okSpeech= prof.speechiness? _inRange(feat.speechiness, prof.speechiness, gate) : true;
  const okInstr = prof.instrumentalness? _inRange(feat.instrumentalness, prof.instrumentalness, gate) : true;
  const okMode  = (typeof prof.mode==="number") ? (gate>=0.9 ? (feat.mode===prof.mode) : true) : true;
  return okTempo && okEner && okVal && okDance && okSpeech && okInstr && okMode;
}

/* ===== Edition weighting (tie-break) ===== */
function gauss(x,c,w){ if(x==null) return 0.3; const z=(x-c)/w; return Math.exp(-0.5*z*z); }
function marketScore(t, tags){ const mk=new Set((t?.available_markets)||[]); let sc=0; for(const [code,w] of tags){ if(mk.has(code)) sc+=w; } return Math.min(sc,1); }
function editionWeight(u, feats, tracksMap, edition){
  const f=feats.get(u)||{}, t=tracksMap.get(u)||{}; let feat=0, mkt=0;
  if(edition==="UK"){ feat=0.5*gauss(f.tempo,170,7)+0.3*gauss(f.energy,0.65,0.2)+0.2*gauss(f.valence,0.45,0.25); mkt=marketScore(t,[["GB",1]]); }
  else if(edition==="US"){ feat=0.5*gauss(f.tempo,170,6)+0.3*gauss(f.energy,0.7,0.2)+0.2*gauss(f.valence,0.6,0.25); mkt=marketScore(t,[["US",1]]); }
  else if(edition==="EU"){ feat=0.45*gauss(f.tempo,172,5)+0.4*gauss(f.energy,0.8,0.2)+0.15*gauss(f.valence,0.35,0.25)+(f.mode===0?0.08:0); mkt=marketScore(t,[["ES",0.7],["NL",0.3]]); }
  else { feat=0.5*gauss(f.tempo,170,8)+0.3*gauss(f.energy,0.7,0.25)+0.2*gauss(f.valence,0.5,0.3); mkt=marketScore(t,[["ES",0.25],["US",0.25],["GB",0.25],["NZ",0.25]]); }
  const noRemixBonus = (URI_META.get(u)?.remixer)?0:0.05;
  return 0.55*feat + 0.45*mkt + noRemixBonus;
}

/* ===== Deep divergence builder (V3) ===== */
function makeEditionPacksV3(baseUris, feats, pinned, tracksMap){
  const N = Math.max(0, Number(val("finalN","130"))||130);
  const withinDupAllowed=!!$("allowWithinDup")?.checked;
  const allowCrossDup =!!$("allowCrossDup")?.checked;
  const diverge = getDiverge(); const level=DIV_LEVELS[diverge]||DIV_LEVELS.high;

  const P = Math.max(0, Math.min(Number.isFinite(pinned.length)?pinned.length:0, N));
  const fixed = pinned.slice(0, P);
  const tailN = Math.max(0, N - P);

  const pinnedSet=new Set(fixed);
  let remainder=baseUris.filter(u=>!pinnedSet.has(u));
  if(!allowCrossDup) remainder=[...new Set(remainder)];

  const buckets=[[],[],[],[]];
  for(const u of remainder){ buckets[seedHash(u)%4].push(u); }
  const mapEd={UK:0,US:1,EU:2,WORLD:3}, sigSeeds={UK:101,US:202,EU:303,WORLD:404};
  const packs={}, usedGlobal=new Set();

  function pickByProfile(home,others,edition){
    const prof = EDITION_PROFILES[edition]||{};
    const gates = [level.gate, Math.max(0.01, level.gate*0.85), Math.max(0.01, level.gate*0.70), Math.max(0.01, level.gate*0.55), Math.max(0.01, level.gate*0.40), 0.30, 0.20];
    const orderPools=[home,others];
    const out=[], artistCount=new Map(), remCount=new Map();

    const pushIf=(u,strictCap=true)=>{
      if(!u) return false;
      if(out.length>=tailN) return false;
      if(!allowCrossDup && usedGlobal.has(u)) return false;
      if(out.includes(u)) return false;
      const meta=URI_META.get(u)||{}; const a=meta.artistId||""; const r=meta.remixer||"";
      if(strictCap){
        if(a && (artistCount.get(a)||0)>=level.artistCap) return false;
        if(r && (remCount.get(r)||0)>=level.remixerCap) return false;
      }
      out.push(u);
      if(!allowCrossDup) usedGlobal.add(u);
      if(a) artistCount.set(a,(artistCount.get(a)||0)+1);
      if(r) remCount.set(r,(remCount.get(r)||0)+1);
      return true;
    };

    for(const g of gates){
      for(const pool of orderPools){
        const cand = pool.filter(u=>fitsProfile(feats.get(u), prof, g));
        cand.sort((a,b)=> editionWeight(b,feats,tracksMap,edition)-editionWeight(a,feats,tracksMap,edition));
        for(const u of cand){ if(out.length>=tailN) break; pushIf(u,true); }
        if(out.length>=tailN) break;
      }
      if(out.length>=tailN) break;
    }
    if(out.length<tailN){
      const fb = home.concat(others).filter(u=>!out.includes(u));
      for(const u of fb){ if(out.length>=tailN) break; pushIf(u,true); }
    }
    if(out.length<tailN){
      const fb2 = home.concat(others).filter(u=>!out.includes(u));
      for(const u of fb2){ if(out.length>=tailN) break; pushIf(u,false); }
    }
    return out.slice(0,tailN);
  }

  function buildOne(edition){
    const idx=mapEd[edition], seed=sigSeeds[edition];
    const home=buckets[idx].slice(0);
    const others=remainder.filter(u=>!home.includes(u));
    home.sort((a,b)=>editionWeight(b,feats,tracksMap,edition)-editionWeight(a,feats,tracksMap,edition));
    others.sort((a,b)=>editionWeight(b,feats,tracksMap,edition)-editionWeight(a,feats,tracksMap,edition));

    const tail = pickByProfile(home,others,edition);
    const prev=fixed[fixed.length-1]||tail[0];
    const orderedTail=buildTailByPreset(prev, tail, feats, val("preset"+edition, edition==="US"?"rise":edition==="EU"?"drop":edition==="WORLD"?"dj":"waves"), seed);

    let seq=fixed.concat(orderedTail);
    if(!withinDupAllowed){
      const ban = allowCrossDup ? null : usedGlobal;
      const prefPool = home.concat(others);
      const seqUnique = enforceUniqueWithin(seq, P, prefPool, remainder, edition, ban);
      if(!allowCrossDup){ for(const u of seqUnique.slice(P)) usedGlobal.add(u); }
      seq = seqUnique;
    }
    const swaps=postProcessNoAdjacency(seq, P);
    log(`â†”ï¸ é€£ç¶šå›é¿ ${edition}: remixer=${swaps.remix_swaps}, artist=${swaps.artist_swaps}`);
    return seq;
  }

  packs.UK=buildOne("UK");
  packs.US=buildOne("US");
  packs.EU=buildOne("EU");
  packs.WORLD=buildOne("WORLD");

  function overlap(a,b){
    const la = Array.isArray(a)?a.length:0;
    const lb = Array.isArray(b)?b.length:0;
    if(la===0 || lb===0) return "0.0";
    const A=new Set(a),B=new Set(b); let x=0; for(const u of A) if(B.has(u)) x++;
    const denom = Math.max(1, Math.min(la,lb));
    return (100*x/denom).toFixed(1);
  }
  log(`ğŸª„ ç‰ˆé–“é‡ãªã‚Šç‡(%) UK/US=${overlap(packs.UK,packs.US)}, UK/EU=${overlap(packs.UK,packs.EU)}, UK/WORLD=${overlap(packs.UK,packs.WORLD)}`);
  log(`ğŸª„ ç‰ˆé–“é‡ãªã‚Šç‡(%) US/EU=${overlap(packs.US,packs.EU)}, US/WORLD=${overlap(packs.US,packs.WORLD)}, EU/WORLD=${overlap(packs.EU,packs.WORLD)}`);
  log(`ğŸ›ï¸ å·®åˆ¥åŒ–ãƒ¬ãƒ™ãƒ«: ${diverge} (gate=${level.gate}, artistCap=${level.artistCap}, remixerCap=${level.remixerCap})`);
  return packs;
}

/* ===== Beatport 150 ===== */
function buildBeatportFromConsensus(baseUris, feats, pinned, packs4, tracksMap){
  const N = Math.max(0, Number(val("finalN","130"))||130);
  const extra = Math.max(0, Number(val("bpExtra","20"))||20);
  const total = Math.max(0, N + extra);
  const P = Math.max(0, Math.min(pinned.length, total));
  const fixed=pinned.slice(0,P), tailN=Math.max(0,total-P);

  const freq=new Map();
  for(const name of ["UK","US","EU","WORLD"]){
    const arr=(packs4[name]||[]).slice(P);
    for(const u of arr){ freq.set(u,(freq.get(u)||0)+1); }
  }
  const scored=[...freq.entries()].map(([u,f])=>{
    const ft=feats.get(u)||{}; const t=tracksMap.get(u)||{};
    const mkt = marketScore(t,[["ES",0.25],["US",0.25],["GB",0.25],["NZ",0.25]]);
    const sc = f*10 + (ft.energy??0.5)*3 + (ft.tempo??120)/300 + mkt;
    return {u,sc};
  }).sort((a,b)=>b.sc-a.sc).map(x=>x.u);

  const consensus=scored.slice(0,Math.min(extra,tailN));
  const used=new Set([...fixed, ...consensus]);
  const remainder=baseUris.filter(u=>!used.has(u));
  const seed=505;
  const orderedRest = buildTailByPreset(consensus[consensus.length-1]||remainder[0], remainder, feats, (val("presetBP","bp")||"bp"), seed);

  const seq0 = fixed.concat(consensus.concat(orderedRest).slice(0, tailN));
  const seq = enforceUniqueWithin(seq0, P, consensus.concat(remainder), remainder, "BEATPORT", null);
  const swaps=postProcessNoAdjacency(seq, P);
  log(`â†”ï¸ é€£ç¶šå›é¿ BEATPORT: remixer=${swaps.remix_swaps}, artist=${swaps.artist_swaps}`);
  return seq;
}

/* ===== Write & Create ===== */
const extractPlaylistId=(s)=>{s=String(s||""); let m=s.match(/playlist\/([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/^([A-Za-z0-9]{22})$/); if(m) return m[1]; return ""; }
async function replacePlaylist(pid,uris){
  const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
  if(!chunks.length) chunks.push([]);
  await spFetch("/v1/playlists/"+pid+"/tracks","PUT",{uris:chunks[0]}); log("ğŸ§¹ ç½®æ›: "+chunks[0].length+"ä»¶");
  for(let k=1;k<chunks.length;k++){ await spFetch(`/v1/playlists/${pid}/tracks`,"POST",{uris:chunks[k]}); log("â• è¿½åŠ : "+chunks[k].length+"ä»¶"); }
}
async function createPlaylistAndFill(name,desc,isPublic,uris){
  const me=await getMe();
  const pl=await spFetch("/v1/users/"+encodeURIComponent(me.id)+"/playlists","POST",{name,description:desc,public:!!isPublic});
  const pid=(pl&&pl.id)?pl.id:""; await replacePlaylist(pid,uris); return pid;
}
async function ensureWrite(which, uris){
  const inputId = (which==="BEATPORT")? "plBP" : ("pl"+which);
  const inputVal = val(inputId,"").trim();
  const pid = extractPlaylistId(inputVal);
  const base = val("baseName","TDCS Editions").trim() || "TDCS Editions";
  const descNote = val("descNote",""); const isPub = val("pub","0")==="1";
  if(pid){ await replacePlaylist(pid,uris); return pid; }
  const name = `${base} [${which}]`; const desc = `${descNote} (${new Date().toISOString().slice(0,10)})`;
  log(`ğŸ“„ æ–°è¦ä½œæˆ: ${name}`); return await createPlaylistAndFill(name,desc,isPub,uris);
}

/* ===== Pref pool ===== */
function buildBasePool(list, preferred){
  const used=new Set(), seq=[];
  const push=(u)=>{ if(u && !used.has(u)){ used.add(u); seq.push(u); } };
  for(const u of preferred) push(u);
  for(const u of list)      push(u);
  return seq;
}

/* ===== Main ===== */
let _pending=null;
function getMarkets(){ const raw=(val("markets","")||"").toUpperCase(); const arr=raw.split(",").map(s=>s.trim()).filter(Boolean); return arr.length?uniq(arr):["ES","US","GB","NZ"]; }

/* CSV */
async function runCsvOnly(){
  progress(8,"CSVæ¤œå‡ºâ€¦");
  const cols=guessCsvColumns(csvRows);
  log("ğŸ” åˆ—: id="+cols.idCol+", isrc="+cols.isrcCol+", title="+cols.tCol+", version="+cols.vCol+", artist="+cols.aCol);

  progress(20,"URIè§£æ±ºï¼ˆCSVã®ã¿ï¼‰â€¦");
  const mkts=getMarkets(); const uris=[]; let ok=0;
  for(let i=0;i<csvRows.length;i++){
    const u=await resolveOne(csvRows[i],cols,mkts); uris.push(u); if(u) ok++;
    if(((i+1)%20===0)||i+1===csvRows.length) subProgress(i+1,csvRows.length,20,48,"URIè§£æ±º");
  }
  log(`ğŸ”— URIè§£æ±º: ${ok}/${csvRows.length}`);
  const list=uris.filter(Boolean); if(list.length===0){ throw new Error("CSVã‹ã‚‰è§£æ±ºã§ãã‚‹URIãŒã‚ã‚Šã¾ã›ã‚“"); }

  progress(55,"æ›²è©³ç´°â†’å¸‚å ´å„ªå…ˆâ€¦");
  const tracksMap=await fetchTrackDetailsByUris(list);
  const strict=$("strictMarket")?.checked; const mk=getMarkets();
  let preferred=list;
  if(strict){
    preferred=list.filter(u=>{
      const t=tracksMap.get(u); if(!t || !Array.isArray(t.available_markets)) return false;
      return mk.some(m=>t.available_markets.includes(m));
    });
    log(`ğŸŒ å¸‚å ´ä¸€è‡´(å„ªå…ˆæ¡ç”¨): ${preferred.length}/${list.length}ï¼ˆä¸è¶³åˆ†ã¯å€™è£œã§è£œå®Œï¼‰`);
  }
  const basePool=buildBasePool(list, preferred);

  progress(66,"Audio Features å–å¾—â€¦");
  let feats=new Map(); try{ feats=await fetchAudioFeaturesByUris(basePool); } catch(e){ log("âš ï¸ audio-features å–å¾—ã‚¹ã‚­ãƒƒãƒ—: "+(e.message||e)); }

  URI_META=buildUriMeta(list, tracksMap, csvRows, cols);

  progress(76,"ã‚¤ãƒ³ãƒˆãƒ­å–å¾—â€¦");
  const pinned = await getPinnedIntro(basePool);

  progress(78,"ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³åˆ†é…ï¼ˆDeep Divergenceï¼‰â€¦");
  const packs4=makeEditionPacksV3(basePool, feats, pinned, tracksMap);

  progress(82,"Beatportç‰ˆï¼ˆ+20ï¼‰ã‚’æ§‹æˆâ€¦");
  const packBP=buildBeatportFromConsensus(basePool, feats, pinned, packs4, tracksMap);

  progress(90,"æ›¸è¾¼ã¿/ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæº–å‚™â€¦");
  await exportPrepAndWrite({...packs4, BEATPORT:packBP},feats);
}

/* Auto */
async function runAutoOnly(){
  progress(10,"æ¤œç´¢ã‚¯ã‚¨ãƒªåé›†â€¦");
  const mkts=getMarkets();
  const queries=(val("autoQueries","")||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const perQ=Math.max(1, +(val("autoLimit","60")||60));
  const cap =Math.max(1, +(val("autoCap","300")||300));
  const doDedup = val("autoDedup","1")==="1";

  log(`ğŸ” ã‚¯ã‚¨ãƒª=${queries.length} / å„${perQ}ä»¶ / ä¸Šé™${cap} / dedup=${doDedup}`);
  const pool=[];
  for(const q of queries){
    let got=0; for(const m of mkts){
      if(got>=perQ) break;
      const need=Math.min(perQ-got, 100);
      const items=await searchMany(q,m,need);
      for(const it of items) pool.push("spotify:track:"+it.id);
      got+=items.length; if((pool.length%60)===0) subProgress(pool.length,cap,10,40,"å€™è£œå–å¾—");
      if(pool.length>=cap) break;
    }
    if(pool.length>=cap) break;
  }
  let list = doDedup? Array.from(new Set(pool)) : pool;
  if(list.length===0){ throw new Error("Autoãƒ¢ãƒ¼ãƒ‰ï¼šæ¤œç´¢ã§å€™è£œãŒå¾—ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸ"); }
  if(list.length>cap) list = list.slice(0,cap);
  log(`ğŸ“¦ å€™è£œ: ${list.length} ä»¶`);

  progress(55,"æ›²è©³ç´°â†’å¸‚å ´å„ªå…ˆâ€¦");
  const tracksMap=await fetchTrackDetailsByUris(list);
  const strict=$("strictMarket")?.checked; const mk=getMarkets();
  let preferred=list;
  if(strict){
    preferred=list.filter(u=>{
      const t=tracksMap.get(u); if(!t || !Array.isArray(t.available_markets)) return false;
      return mk.some(m=>t.available_markets.includes(m));
    });
    log(`ğŸŒ å¸‚å ´ä¸€è‡´(å„ªå…ˆæ¡ç”¨): ${preferred.length}/${list.length}ï¼ˆä¸è¶³åˆ†ã¯å€™è£œã§è£œå®Œï¼‰`);
  }
  const basePool=buildBasePool(list, preferred);

  progress(66,"Audio Features å–å¾—â€¦");
  let feats=new Map(); try{ feats=await fetchAudioFeaturesByUris(basePool); } catch(e){ log("âš ï¸ audio-features å–å¾—ã‚¹ã‚­ãƒƒãƒ—: "+(e.message||e)); }

  URI_META=buildUriMeta(list, tracksMap, null, null);

  progress(76,"ã‚¤ãƒ³ãƒˆãƒ­å–å¾—â€¦");
  const pinned = await getPinnedIntro(basePool);

  progress(78,"ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³åˆ†é…ï¼ˆDeep Divergenceï¼‰â€¦");
  const packs4=makeEditionPacksV3(basePool, feats, pinned, tracksMap);

  progress(82,"Beatportç‰ˆï¼ˆ+20ï¼‰ã‚’æ§‹æˆâ€¦");
  const packBP=buildBeatportFromConsensus(basePool, feats, pinned, packs4, tracksMap);

  progress(90,"æ›¸è¾¼ã¿/ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæº–å‚™â€¦");
  await exportPrepAndWrite({...packs4, BEATPORT:packBP},feats);
}

/* Export & Write */
let _exportData=null; const enableExportButtons=(on)=>{ $("btnExportXlsx").disabled=!on; $("btnExportCsv").disabled=!on; }
async function exportPrepAndWrite(packs,feats){
  function packRows(arr,ed){ const out=[]; for(let i=0;i<arr.length;i++){ const f=feats.get(arr[i])||{}; out.push({position:i+1,edition:ed,spotify_uri:arr[i],tempo:round4(f.tempo),energy:round4(f.energy),valence:round4(f.valence),key:(f.key==null?"":f.key),mode:(f.mode==null?"":f.mode),danceability:round4(f.danceability),speechiness:round4(f.speechiness),instrumentalness:round4(f.instrumentalness)}); } return out; }
  _exportData={ uk:packRows(packs.UK,"UK"), us:packRows(packs.US,"US"), eu:packRows(packs.EU,"EU"), wo:packRows(packs.WORLD,"WORLD"), bp:packRows(packs.BEATPORT,"BEATPORT") };
  enableExportButtons(true);

  if(isAuthed()){
    progress(92,"æ›¸è¾¼ã¿â€¦"); await ensureWrite("UK",packs.UK);
    progress(94,"æ›¸è¾¼ã¿â€¦"); await ensureWrite("US",packs.US);
    progress(96,"æ›¸è¾¼ã¿â€¦"); await ensureWrite("EU",packs.EU);
    progress(97,"æ›¸è¾¼ã¿â€¦"); await ensureWrite("WORLD",packs.WORLD);
    progress(99,"æ›¸è¾¼ã¿â€¦"); await ensureWrite("BEATPORT",packs.BEATPORT);
    log("âœ… æ›¸è¾¼ã¿å®Œäº†ï¼ˆUK/US/EU/WORLD=å„"+val("finalN","130")+"æ›²ãƒ»BEATPORT="+(+(val("finalN","130"))+ +(val("bpExtra","20")))+"æ›²ï¼‰");
  }else{
    _pending=packs; log("ğŸ”‘ æ¥ç¶šå¾…ã¡ï¼šã€Spotifyã«ã‚µã‚¤ãƒ³ã‚¤ãƒ³ã€â†’ã€æ¥ç¶šãƒã‚§ãƒƒã‚¯ã€");
  }
  progress(100,"å®Œäº†");
  log("âœ… å®Œäº†ï¼ˆ15å…±é€šï¼Deep Divergenceãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ï¼ç‰ˆå†…ãƒ¦ãƒ‹ãƒ¼ã‚¯ï¼ãƒªãƒŸã‚­ã‚µãƒ¼é€£ç¶šå›é¿ï¼BP=å…±é€šä¸Šä½+20ã®150æ›²ï¼‰");
}

/* Resume */
async function resolveAndWrite(packs){
  try{
    progress(90,"æ›¸è¾¼ã¿å†é–‹â€¦");
    await ensureWrite("UK",packs.UK); progress(92,"æ›¸è¾¼ã¿å†é–‹â€¦");
    await ensureWrite("US",packs.US); progress(94,"æ›¸è¾¼ã¿å†é–‹â€¦");
    await ensureWrite("EU",packs.EU); progress(96,"æ›¸è¾¼ã¿å†é–‹â€¦");
    await ensureWrite("WORLD",packs.WORLD); progress(98,"æ›¸è¾¼ã¿å†é–‹â€¦");
    await ensureWrite("BEATPORT",packs.BEATPORT); log("âœ… æ›¸è¾¼ã¿å®Œäº†"); _pending=null;
  }catch(e){ log("ğŸ’¥ ERROR(resolveAndWrite): "+(e.message||e)); }
}

/* UI events */
$("modeCsv").onchange=()=>{ setHidden("boxCsv",!$("modeCsv").checked); setHidden("boxAuto",$("modeCsv").checked); };
$("modeAuto").onchange=$("modeCsv").onchange; $("modeCsv").onchange();

$("btnConnect").onclick=startAuth;
$("btnReset").onclick=()=>{ for(const k in LS) localStorage.removeItem(LS[k]); _me=null; setStatus(); log("ğŸ§½ ãƒ­ãƒ¼ã‚«ãƒ«ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤"); };
$("btnCheck").onclick=async()=>{ try{ await refreshTokenIfNeeded(); const me=await spFetch("/v1/me","GET"); if(me) {$("status").textContent="æ¥ç¶šä¸­ï¼ˆ"+(me.display_name||me.id)+")"; log("âœ… APIç¢ºèª OK"); if(_pending) await resolveAndWrite(_pending);} else {$("status").textContent="æ¥ç¶šä¸­ï¼ˆOKï¼‰";} }catch(e){ log("âš ï¸ æ¥ç¶šã‚¨ãƒ©ãƒ¼: "+(e.message||e)); } };

/* CSVé¸æŠã§è‡ªå‹•å®Ÿè¡Œ */
$("fileCSV").addEventListener("change", async () => {
  if(!$("modeCsv").checked) return; // Autoæ™‚ã¯ç„¡è¦–
  $("log").textContent="";
  progress(3,"CSVèª­ã¿è¾¼ã¿â€¦");
  if(!$("fileCSV").files.length){ log("âš ï¸ CSVæœªé¸æŠ"); return; }
  csvRows = await readCSV($("fileCSV").files[0]);
  log("âœ… CSV: "+csvRows.length+" è¡Œ");
  progress(6,"åˆ†æé–‹å§‹â€¦");
  await runCsvOnly();            // â† è‡ªå‹•ã§èµ°ã‚‰ã›ã‚‹
});

/* å®Ÿè¡Œãƒœã‚¿ãƒ³ */
$("btnRun").onclick=async()=>{
  try{
    $("log").textContent=""; progress(1,"é–‹å§‹â€¦");
    if($("modeCsv").checked){
      if(!$("fileCSV").files.length){ throw new Error("CSVãƒ¢ãƒ¼ãƒ‰ã§ã™ãŒCSVãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“"); }
      await runCsvOnly();
    }else{
      await runAutoOnly();
    }
  }catch(e){
    progress(100,"ã‚¨ãƒ©ãƒ¼"); log("ğŸ’¥ ERROR: "+(e.message||e));
  }
};

/* Export buttons */
$("btnExportXlsx").onclick=()=>{
  if(!_exportData){log("â„¹ï¸ ãƒ‡ãƒ¼ã‚¿ãªã—");return;}
  const wb=XLSX.utils.book_new();
  const add=(name,key)=>{ const ws=XLSX.utils.json_to_sheet(_exportData[key],{header:["position","edition","spotify_uri","tempo","energy","valence","key","mode","danceability","speechiness","instrumentalness"]}); XLSX.utils.book_append_sheet(wb,ws,name); }
  add("UK","uk"); add("US","us"); add("EU","eu"); add("WORLD","wo"); add("BEATPORT","bp");
  XLSX.writeFile(wb,"editions_"+new Date().toISOString().slice(0,10)+".xlsx");
};
$("btnExportCsv").onclick=()=>{
  if(!_exportData){log("â„¹ï¸ ãƒ‡ãƒ¼ã‚¿ãªã—");return;}
  const all=[].concat(_exportData.uk,_exportData.us,_exportData.eu,_exportData.wo,_exportData.bp);
  const H=["position","edition","spotify_uri","tempo","energy","valence","key","mode","danceability","speechiness","instrumentalness"];
  const esc=(v)=>'"'+String(v==null?"":v).replace(/"/g,'""')+'"';
  const rows=[H.join(",")]; for(const r of all){ rows.push(H.map(h=>esc(r[h])).join(",")); }
  const blob=new Blob([rows.join("\r\n")],{type:"text/csv;charset=utf-8"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="editions_"+new Date().toISOString().slice(0,10)+".csv"; document.body.appendChild(a); a.click(); a.remove();
};

setStatus();
log("Ready. Deep Divergence: ç‰ˆåˆ¥ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã§å³æ ¼ã‚²ãƒ¼ãƒˆâ†’ä¸è¶³æ™‚ã«æ®µéšç·©å’Œã€‚ä¸Šé™/ãƒ¦ãƒ‹ãƒ¼ã‚¯/é€£ç¶šå›é¿/Beatport150 å®Œå‚™ã€‚");
</script>
</body></html>
