<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
<meta http-equiv="Pragma" content="no-cache">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Editions Builder â€“ Breaks Remix Only 2010+ (UK / US / EU / World)</title>
<style>
  :root{--w:980px}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:var(--w);margin:34px auto;padding:0 12px}
  h1{margin:0 0 12px}
  fieldset{border:1px solid #ddd;border-radius:10px;padding:12px;margin:12px 0}
  label{display:block;margin:8px 0 4px}
  input,select{width:100%;box-sizing:border-box;padding:8px;border:1px solid #bbb;border-radius:8px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
  .row>*{flex:1 1 240px}
  button,a.btn{display:inline-block;padding:9px 12px;border:1px solid #bbb;border-radius:8px;background:#f6f6f6;text-decoration:none;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  #status{color:#2d7a2d;margin-top:6px}
  #warn{color:#a53;margin-top:4px}
  #log{white-space:pre-wrap;background:#0b1220;color:#cfe3ff;padding:12px;border-radius:8px;max-height:420px;overflow:auto}
  .muted{opacity:.75}
  .note{font-size:12px;color:#555}
  .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
  .grid label{margin-top:0}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #bbb;border-radius:999px;font-size:12px;margin-left:6px}
  .progress{display:flex;align-items:center;gap:10px;margin:6px 0}
  progress{width:260px;height:16px}
  .tight{margin-top:4px}
</style>
</head>
<body>
<h1>Editions Builderï¼ˆBreaksé™å®šãƒ»2010+ãƒ»Remixã®ã¿ï¼‰<span class="pill">v2025-08-23 FINAL</span></h1>

<!-- ã‚µã‚¤ãƒ³ã‚¤ãƒ³ -->
<fieldset>
  <legend>ã‚µã‚¤ãƒ³ã‚¤ãƒ³</legend>
  <div class="row">
    <div>
      <a class="btn" href="./auth.html">Sign in with Spotify</a>
      <button id="btnMe">/v1/me</button>
      <button id="btnSignOut">ã‚µã‚¤ãƒ³ã‚¢ã‚¦ãƒˆ</button>
      <div class="progress">
        <progress id="prog" value="0" max="100"></progress>
        <span id="progTxt" class="muted">æº–å‚™OK</span>
      </div>
      <div id="status" class="muted">æœªã‚µã‚¤ãƒ³ã‚¤ãƒ³ï¼ˆãƒœã‚¿ãƒ³ã‹ã‚‰é–‹å§‹ï¼‰</div>
      <div id="warn" class="note"></div>
    </div>
  </div>
</fieldset>

<!-- ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ï¼ˆ4ã¤ã ã‘ï¼‰ -->
<fieldset>
  <legend>ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³é¸æŠï¼ˆUK / US / EU / Worldï¼‰</legend>
  <div class="row">
    <div>
      <label class="tight"><input type="checkbox" class="ed" value="UK" checked> UK</label>
      <label class="tight"><input type="checkbox" class="ed" value="US" checked> US</label>
      <label class="tight"><input type="checkbox" class="ed" value="EU" checked> EU</label>
      <label class="tight"><input type="checkbox" class="ed" value="WORLD" checked> World</label>
      <div class="note">å„ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã¯è‡ªåœ°åŸŸã§å†ç”Ÿå¯ï¼ˆavailable_marketsï¼‰ãªæ›²ã§100æ›²ã«ä»•ä¸Šã’ã¾ã™ã€‚è¶³ã‚Šãªã„å ´åˆã¯ç·©å’Œã—ã¦å¿…ãšç€åœ°ã€‚</div>
    </div>
    <div>
      <label>ãƒ™ãƒ¼ã‚¹åï¼ˆæœ«å°¾ã« [UK Edition] ç­‰ã‚’è‡ªå‹•ä»˜ä¸ï¼‰</label>
      <input id="baseName" value="TDCS â€“ Breaks Remix Only 100 (2010+)" />
    </div>
    <div>
      <label>èª¬æ˜æ–‡ï¼ˆå…±é€šï¼‰</label>
      <input id="baseDesc" value="Breaks/Breakbeaté™å®šãƒ»2010+ãƒ»Remixã®ã¿ãƒ»Pinså›ºå®šãƒ»ãƒãƒ©ãƒ³ã‚¹é…ç½®" />
    </div>
    <div>
      <label>å…¬é–‹è¨­å®š</label>
      <select id="isPublic">
        <option value="false" selected>éå…¬é–‹ï¼ˆæ¨å¥¨ï¼‰</option>
        <option value="true">å…¬é–‹</option>
      </select>
    </div>
  </div>
</fieldset>

<!-- åé›†ãƒãƒªã‚·ãƒ¼ -->
<fieldset>
  <legend>åé›†ãƒãƒªã‚·ãƒ¼ï¼ˆä¸€èˆ¬çš„ãªæ—¢å®šï¼‰</legend>
  <div class="row">
    <div>
      <label>ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDï¼ˆTDCS æ—¢å®šï¼‰</label>
      <input id="artistId" value="55fvQ5I2IZUfcFT2DV02T3" />
      <div class="note">The Darrow Chem Syndicateï¼ˆå¤‰æ›´å¯ï¼‰</div>
    </div>
    <div>
      <label>æœ€æ–°ã‹ã‚‰å–ã‚‹ã‚¢ãƒ«ãƒãƒ æšæ•°</label>
      <input id="albumRecent" type="number" min="8" max="80" value="30" />
      <div class="note">â€œå…¨æ›²ã‚¹ã‚­ãƒ£ãƒ³â€ãªã®ã§ 20â€“40 ãŒç›®å®‰ã€‚</div>
    </div>
    <div>
      <label>æ—§ä½œã‚µãƒ³ãƒ—ãƒ«æ¯”ç‡ï¼ˆ0.00â€“0.80ï¼‰</label>
      <input id="oldAlbumRatio" type="number" step="0.05" min="0" max="0.8" value="0.25" />
      <div class="note">éå»ã®äººæ°—æ›²ã‚’æ··ãœã‚‹ã€‚ä½“æ„Ÿ 0.20â€“0.30ã€‚</div>
    </div>
    <div>
      <label>Era Mixï¼šå¤ã‚æ›²ã®æ··åˆç‡ï¼ˆ0.00â€“0.80ï¼‰</label>
      <input id="ratioOld" type="number" step="0.05" min="0" max="0.8" value="0.30" />
      <div class="note">ä¸¦ã³ä½œã‚Šã§å¤ã„å¹´ä»£ã®æ··ãœæ–¹ã€‚</div>
    </div>
  </div>

  <div class="row">
    <div>
      <label>äººæ°—ã®é‡ã¿ï¼ˆ0â€“1ï¼‰</label>
      <input id="wPopularity" type="number" step="0.05" min="0" max="1" value="0.6" />
    </div>
    <div>
      <label>æ–°ã—ã•ã®é‡ã¿ï¼ˆ0â€“1ï¼‰</label>
      <input id="wRecent" type="number" step="0.05" min="0" max="1" value="0.4" />
    </div>
    <div>
      <label>æœ€çµ‚æ›²æ•°</label>
      <input id="finalSize" type="number" min="80" max="100" value="100" />
    </div>
  </div>

  <div class="row">
    <div>
      <label>å¯¾è±¡ãƒªãƒªãƒ¼ã‚¹ç¨®åˆ¥</label>
      <div class="tight">
        <label><input type="checkbox" class="rtype" value="ALBUM" checked> Album</label>
        <label><input type="checkbox" class="rtype" value="SINGLE" checked> Single</label>
        <label><input type="checkbox" class="rtype" value="EP" checked> EP</label>
        <label><input type="checkbox" class="rtype" value="COMPILATION" checked> Compilation</label>
      </div>
      <div class="note">EPã¯ã€Œalbum_type: single ã‹ã¤æ›²æ•°â‰¥3ã€ã¾ãŸã¯ã‚¿ã‚¤ãƒˆãƒ«ã«â€œEPâ€ã€‚</div>
    </div>
    <div>
      <label>ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå€™è£œæ•°ï¼ˆTrimä¸Šé™ï¼‰</label>
      <input id="targetPool" type="number" min="120" max="220" value="150" />
    </div>
  </div>

  <div class="grid">
    <div><label>#1 ãƒ”ãƒ³</label><input id="pin1"  value="0ueNjvhtXGDFkJQ5WBQ4mE"></div>
    <div><label>#5 ãƒ”ãƒ³</label><input id="pin5"  value="63dYSEftdSYwMAFBNfQYsA"></div>
    <div><label>#40 ãƒ”ãƒ³</label><input id="pin40" value="3NQuIFfQPhTICaXGYe5dAt"></div>
    <div><label>#60 ãƒ”ãƒ³</label><input id="pin60" value="7ltcrdlVsXyU5HU9VCAj6P"></div>
  </div>

  <div class="row">
    <div>
      <button id="btnFast">â‘  åé›†ï¼ˆFAST Buildï¼‰</button>
      <button id="btnTrim" disabled>â‘¡ Trimï¼ˆ120â€“130ï¼‰</button>
      <button id="btnBalance" disabled>â‘¢ Balanced 100</button>
    </div>
  </div>
</fieldset>

<!-- ã¾ã¨ã‚ã¦ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ä½œæˆ -->
<fieldset>
  <legend>â‘£ ã¾ã¨ã‚ã¦ä½œæˆï¼ˆUK / US / EU / Worldï¼‰</legend>
  <div class="row">
    <div><button id="btnBuildEditions" disabled>UK/US/EU/World ã‚’ä½œæˆ</button></div>
  </div>
</fieldset>

<!-- å˜ç™ºä½œæˆ -->
<fieldset>
  <legend>ï¼ˆä»»æ„ï¼‰å˜ç™ºã§ä½œæˆ/æ›´æ–°</legend>
  <div class="row">
    <div>
      <label>ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆå</label>
      <input id="plName" placeholder="TDCS â€“ Breaks Remix Only 100 (2010+)" />
    </div>
    <div>
      <label>èª¬æ˜æ–‡</label>
      <input id="plDesc" placeholder="Breaks/Breakbeaté™å®šãƒ»2010+ãƒ»Remixã®ã¿ãƒ»Pinså›ºå®šãƒ»ãƒãƒ©ãƒ³ã‚¹é…ç½®" />
    </div>
    <div>
      <label>å…¬é–‹è¨­å®š</label>
      <select id="plPublic">
        <option value="false" selected>éå…¬é–‹</option>
        <option value="true">å…¬é–‹</option>
      </select>
    </div>
  </div>
  <div class="row">
    <div>
      <label>æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆIDï¼ˆç©ºï¼æ–°è¦ï¼‰</label>
      <input id="existingId" placeholder="ä¾‹ï¼‰37i9dQZF1DX..." />
    </div>
    <div>
      <label>APIæœ€å°é–“éš”ms</label>
      <input id="gap" type="number" value="1000" />
    </div>
    <div>
      <label>æœ€å¤§ãƒªãƒˆãƒ©ã‚¤</label>
      <input id="maxRetry" type="number" value="5" />
    </div>
  </div>
  <div class="row">
    <div><button id="btnCommit" disabled>â‘¤ ä½œæˆ/æ›´æ–°ã™ã‚‹</button></div>
  </div>
</fieldset>

<h2>ãƒ­ã‚°</h2>
<pre id="log"></pre>

<script>
"use strict";

/* ====== å›ºå®š ====== */
const CLIENT_ID="1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI="https://npr2025.github.io/spotify-auth/callback.html";
const K={access:"sp_access_token",type:"sp_token_type",expAt:"sp_expires_at",refresh:"sp_refresh_token",scope:"sp_scope"};

/* ====== UI / ãƒ­ã‚° ====== */
const el=id=>document.getElementById(id);
const log=m=>{const d=new Date().toLocaleTimeString(); el("log").textContent+=`[${d}] ${m}\n`; el("log").scrollTop=el("log").scrollHeight;};
const setProg=(v,label)=>{ el("prog").value=v; el("progTxt").textContent=label||""; };
const warn=m=>{el("warn").textContent=m||"";};
function renderStatus(){
  try{
    const a=sessionStorage.getItem(K.access);
    const e=parseInt(sessionStorage.getItem(K.expAt)||"0",10);
    if(!a){ el("status").textContent="æœªã‚µã‚¤ãƒ³ã‚¤ãƒ³ï¼ˆãƒœã‚¿ãƒ³ã‹ã‚‰é–‹å§‹ï¼‰"; return; }
    const left=e-Date.now();
    if(left>60000) el("status").textContent="Signed in â€“ æœ‰åŠ¹æœŸé™ã¾ã§ç´„ "+Math.floor(left/1000)+" ç§’";
    else if(left>0) el("status").textContent="Signed in â€“ ã¾ã‚‚ãªãæœŸé™åˆ‡ã‚Œ";
    else el("status").textContent="ãƒˆãƒ¼ã‚¯ãƒ³æœŸé™åˆ‡ã‚Œï¼ˆå†ã‚µã‚¤ãƒ³ã‚¤ãƒ³ã—ã¦ãã ã•ã„ï¼‰";
  }catch(err){ el("status").textContent="çŠ¶æ…‹è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: "+(err.message||err); }
}
renderStatus();
window.addEventListener("error", e => log("SCRIPT ERROR: "+e.message));
window.addEventListener("unhandledrejection", e => log("UNHANDLED: "+(e?.reason?.message||e?.reason||"(no reason)")));

/* ====== ãƒ¬ãƒ¼ãƒˆ/ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥/HTTP ====== */
let MIN_API_GAP_MS=1000, lastApiTs=0;
async function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
let refreshInflight=null;
async function ensureFreshToken(){
  const access=sessionStorage.getItem(K.access), expAt=parseInt(sessionStorage.getItem(K.expAt)||"0",10), refresh=sessionStorage.getItem(K.refresh);
  if(access && Date.now()<(expAt-5000)) return access;
  if(!refresh) return null;
  if(!refreshInflight){
    refreshInflight=(async()=>{
      let attempt=0;
      while(true){
        attempt++;
        const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:refresh,redirect_uri:REDIRECT_URI})});
        if(res.status===429){const ra=parseInt(res.headers.get("Retry-After")||"1",10);await sleep((isNaN(ra)?1:Math.min(60,ra))*1000+200);continue;}
        if(res.status>=500 && attempt<=3){await sleep(Math.min(4000,500*Math.pow(2,attempt-1)));continue;}
        const txt=await res.text(); let data=null; try{data=JSON.parse(txt);}catch(_){}
        if(!res.ok) throw new Error("refresh failed: "+res.status+" "+txt);
        const expAt=Date.now()+data.expires_in*1000;
        sessionStorage.setItem(K.access,data.access_token);
        sessionStorage.setItem(K.type,data.token_type||"Bearer");
        sessionStorage.setItem(K.expAt,String(expAt));
        if(data.refresh_token) sessionStorage.setItem(K.refresh,data.refresh_token);
        if(data.scope) sessionStorage.setItem(K.scope,data.scope);
        renderStatus(); return data.access_token;
      }
    })().finally(()=>{refreshInflight=null;});
  }
  return refreshInflight;
}
function parse403Message(txt){ try{const j=JSON.parse(txt); return j?.error?.message||"";}catch(_){return "";} }
async function callSpotifyJSON(url,opts={}, {maxRetry=5,expectJSON=true,tag=""}={}){
  const wait=Math.max(0,MIN_API_GAP_MS-(Date.now()-lastApiTs)); if(wait) await sleep(wait);
  let token=await ensureFreshToken(); if(!token) throw new Error("No valid token. Sign in again.");
  let attempt=0;
  while(true){
    attempt++;
    const headers=new Headers(opts.headers||{}); headers.set("Authorization","Bearer "+token); headers.set("Accept","application/json");
    if(opts.body && !(opts.body instanceof FormData) && !headers.has("Content-Type")) headers.set("Content-Type","application/json");
    const res=await fetch(url,{...opts,headers}); lastApiTs=Date.now();

    if(res.status===429 && attempt<=maxRetry){
      const ra=parseInt(res.headers.get("Retry-After")||"1",10); await sleep((isNaN(ra)?1:Math.min(60,ra))*1000+200); continue;
    }
    if(res.status===401 && attempt===1){ token=await ensureFreshToken(); if(!token) throw new Error("Unauthorized and cannot refresh."); continue; }
    if(res.status===403){ const txt=await res.text(); const msg=parse403Message(txt); throw new Error(`${tag||"HTTP"} 403${msg?(": "+msg):""} ::RAW:: ${txt}`); }
    if(res.status>=500 && attempt<=maxRetry){ await sleep(Math.min(8000,700*Math.pow(2,attempt-1))); continue; }
    if(!res.ok){ const txt=await res.text(); throw new Error(`${tag||"HTTP"} ${res.status}: ${txt}`); }

    if(!expectJSON) return null;
    const txt=await res.text(); if(!txt) return {}; try{return JSON.parse(txt);}catch(_){return {};}
  }
}

/* ====== åˆ¤å®šç³» ====== */
function tokenize(name){ return (name||"").toLowerCase().replace(/[()[\]{}\-]/g," ").replace(/\s+/g," ").trim().split(" ").filter(Boolean); }
function isRemixOnlyTitle(name){
  const t=tokenize(name);
  const hasRemix=t.includes("remix")||t.includes("remixed")||t.includes("rmx");
  const hasMix = t.includes("mix") || (t.includes("dj")&&t.includes("mix")) || (t.includes("original")&&t.includes("mix")) || (t.includes("club")&&t.includes("mix")) || (t.includes("extended")&&t.includes("mix")) || (t.includes("continuous")&&t.includes("mix"));
  return hasRemix && !hasMix;
}
const breaksWordRe=/\b(breaks?|break[-\s]?beat|nu[-\s]?breaks?|big\s*beat|funky[-\s]*breaks?|electro[-\s]*breaks?|progressive\s*breaks?|psy[-\s]*breaks?|acid\s*breaks?)\b/i;
const genreOk=g=>/breakbeat|breaks?|big beat|nu skool breaks|electro breaks?|progressive breaks?|funky breaks?|psybreaks?|acid breaks?/i.test(g||"");
function yearFromDate(s){ if(!s) return 0; const y=parseInt(String(s).slice(0,4),10); return isNaN(y)?0:y; }

/* ====== ãƒ­ãƒƒã‚¯ ====== */
const BUILD_LOCK_KEY="sp_build_lock_v1";
const TAB_ID=Math.random().toString(36).slice(2), LOCK_TTL=120000;
let lockHeartbeat=null;
const now=()=>Date.now();
const readLock=k=>{try{return JSON.parse(localStorage.getItem(k)||"null");}catch(_){return null;}};
const writeLock=(k,o)=>localStorage.setItem(k,JSON.stringify(o));
function acquireLock(k){const cur=readLock(k),t=now(); if(!cur||(t-cur.ts)>LOCK_TTL){writeLock(k,{owner:TAB_ID,ts:t});return true;} return cur.owner===TAB_ID;}
function startHB(k){stopHB(); lockHeartbeat=setInterval(()=>{const cur=readLock(k); if(cur&&cur.owner===TAB_ID){cur.ts=now(); writeLock(k,cur);}},5000);}
function stopHB(){if(lockHeartbeat){clearInterval(lockHeartbeat); lockHeartbeat=null;}}
function releaseLock(k){const cur=readLock(k); if(cur&&cur.owner===TAB_ID){localStorage.removeItem(k);} stopHB();}

/* ====== å¯ç”¨æ€§ãƒ¡ãƒ¢ ====== */
const trackSeenBy=new Map(); // id -> Set(markets)
function markSeen(id,market){ let s=trackSeenBy.get(id); if(!s){s=new Set(); trackSeenBy.set(id,s);} s.add(market); }

/* ====== Editionå®šç¾©ï¼ˆJPé™¤å¤–ï¼‰ ====== */
const EDITIONS={
  UK:    { markets:["GB","IE"], anyOf:["GB"], suffix:" [UK Edition]" },
  US:    { markets:["US","CA"], anyOf:["US"], suffix:" [US Edition]" },
  EU:    { markets:["DE","FR","NL","ES","IT","SE","DK","FI","BE","AT","IE","PL","PT","CZ"], needCount:4, suffix:" [EU Edition]" },
  WORLD: { markets:["US","GB","DE","FR","NL","ES","IT","SE","AU","CA","BR"], needPct:0.6, suffix:" [World Edition]" }
};
const CORE_SCAN_MARKETS = ["GB","IE","US","DE","FR","NL","ES","IT","SE","CA","AU","BR"]; // åé›†æ™‚ã®ãƒ™ãƒ¼ã‚¹

/* ====== ãƒªãƒªãƒ¼ã‚¹ç¨®åˆ¥ ====== */
function needTypes(){
  const s=new Set([...document.querySelectorAll(".rtype:checked")].map(x=>x.value));
  return {wantAlbum:s.has("ALBUM"), wantSingle:s.has("SINGLE"), wantEP:s.has("EP"), wantComp:s.has("COMPILATION")};
}
function isEP(album){
  const type=(album.album_type||"").toLowerCase(); const tracks=album.total_tracks||0; const name=(album.name||"").toLowerCase();
  return (type==="single" && tracks>=3) || /\bep\b/.test(name);
}
function matchReleaseType(album, types){
  const t=(album.album_type||"").toLowerCase();
  if(t==="album" && types.wantAlbum) return true;
  if(t==="compilation" && types.wantComp) return true;
  if(t==="single"){
    if(types.wantEP && isEP(album)) return true;
    if(types.wantSingle && !isEP(album)) return true;
  }
  return false;
}

/* ====== APIãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ====== */
const chunkArr=(a,n)=>{const out=[]; for(let i=0;i<a.length;i+=n) out.push(a.slice(i,i+n)); return out;};
async function fetchTracksBatched(ids){
  const uniq=[...new Set(ids)]; const results=[];
  async function fetchChunk(list,tagBase){
    try{
      const data=await callSpotifyJSON(`https://api.spotify.com/v1/tracks?ids=${list.join(",")}`,{}, {tag:`${tagBase}[${list.length}]`});
      (data.tracks||[]).forEach(t=>{ if(t) results.push(t); });
    }catch(e){
      if(String(e.message||"").includes(" 403") && list.length>1){
        const mid=Math.floor(list.length/2); await fetchChunk(list.slice(0,mid),tagBase+"a"); await fetchChunk(list.slice(mid),tagBase+"b");
      }else if(String(e.message||"").includes(" 403") && list.length===1){ log(`   Ã— 403 skip track ${list[0]}`); }
      else throw e;
    }
  }
  const chunks=chunkArr(uniq,50);
  for(let i=0;i<chunks.length;i++){ setProg(44+Math.round((i/chunks.length)*8),`track details ${i+1}/${chunks.length}`); await fetchChunk(chunks[i],`tracks#${i+1}`); }
  return results;
}

/* ====== ç‰¹å¾´é‡å–å¾—ï¼ˆ403ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰ ====== */
async function fetchFeaturesBatched(ids){
  const uniq=[...new Set(ids)];
  const feats=new Map();
  const stats={batchOK:0,batchNull:0,singleOK:0,singleNG:0,analysisOK:0,analysisNG:0,neutral:0};
  const neutral = id => ({ id, energy:0.58, valence:0.45, danceability:0.60, tempo:132, __fallback:"neutral" });

  async function tryBatch(list, tagBase){
    const data = await callSpotifyJSON(`https://api.spotify.com/v1/audio-features?ids=${list.join(",")}`, {}, { tag:`${tagBase}[${list.length}]` });
    (data.audio_features||[]).forEach((f,i)=>{ const id=list[i]; if(f&&f.id){feats.set(f.id,f);stats.batchOK++;} else {feats.set(id,null);stats.batchNull++;} });
  }
  async function trySingle(id){
    let attempt=0; while(attempt<3){ attempt++;
      try{ const f=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features/${id}`, {}, {tag:`feature:${id}`});
        if(f&&f.id){ feats.set(id,f); stats.singleOK++; return; }
      }catch(e){ if(String(e.message||"").includes(" 403")){ await sleep(300*attempt); continue; } break; }
    }
    feats.set(id,null); stats.singleNG++;
  }
  async function tryAnalysis(id){
    let attempt=0; while(attempt<2){ attempt++;
      try{ const a=await callSpotifyJSON(`https://api.spotify.com/v1/audio-analysis/${id}`, {}, {tag:`analysis:${id}`});
        const tempo=a?.track?.tempo||132; feats.set(id,{id,energy:0.58,valence:0.45,danceability:0.60,tempo,__fallback:"analysis"}); stats.analysisOK++; return;
      }catch(e){ if(String(e.message||"").includes(" 403")){ await sleep(400*attempt); continue; } break; }
    }
    feats.set(id, neutral(id)); stats.analysisNG++; stats.neutral++;
  }

  // ãƒãƒƒãƒ
  const chunks=chunkArr(uniq,100);
  for(let i=0;i<chunks.length;i++){ setProg(54+Math.round((i/chunks.length)*6), `features ${i+1}/${chunks.length}`); try{ await tryBatch(chunks[i], `features#${i+1}`);}catch{ chunks[i].forEach(id=>feats.set(id,null)); } }
  // å˜ç™º
  const needSingle=uniq.filter(id=>!feats.has(id) || feats.get(id)===null);
  for(const id of needSingle) await trySingle(id);
  // åˆ†æâ†’ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«
  const needAna=uniq.filter(id=>!feats.has(id) || feats.get(id)===null);
  for(const id of needAna) await tryAnalysis(id);

  log(`features fallback: batchOK=${stats.batchOK} / batchNull=${stats.batchNull} / singleOK=${stats.singleOK} / singleNG=${stats.singleNG} / analysisOK=${stats.analysisOK} / analysisNG=${stats.analysisNG} / neutral=${stats.neutral}`);
  return feats;
}

/* ====== ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆã‚¸ãƒ£ãƒ³ãƒ«ä¸€æ‹¬ ====== */
async function fetchArtistsGenresMapBatched(ids){
  const uniq=[...new Set(ids)]; const map=new Map();
  async function fetchChunk(list,tagBase){
    try{
      const data=await callSpotifyJSON(`https://api.spotify.com/v1/artists?ids=${list.join(",")}`,{}, {tag:`${tagBase}[${list.length}]`});
      (data.artists||[]).forEach(a=>{ if(a) map.set(a.id,a.genres||[]); });
    }catch(e){
      if(String(e.message||"").includes(" 403") && list.length>1){
        const mid=Math.floor(list.length/2); await fetchChunk(list.slice(0,mid),tagBase+"a"); await fetchChunk(list.slice(mid),tagBase+"b");
      }else if(String(e.message||"").includes(" 403") && list.length===1){ log(`   Ã— 403 skip artist ${list[0]}`); }
      else throw e;
    }
  }
  const chunks=chunkArr(uniq,50);
  for(let i=0;i<chunks.length;i++){ setProg(62+Math.round((i/chunks.length)*8),`artists ${i+1}/${chunks.length}`); await fetchChunk(chunks[i],`artists#${i+1}`); }
  return map;
}

/* ====== ã‚¢ãƒ«ãƒãƒ /ãƒˆãƒ©ãƒƒã‚¯ ====== */
const albumCache=new Map(); // market -> albums[]
async function scanArtistAlbums(artistId, market, groupsCsv, scanMax){
  let items=[]; let url=`https://api.spotify.com/v1/artists/${artistId}/albums?market=${encodeURIComponent(market)}&include_groups=${encodeURIComponent(groupsCsv)}&limit=50&offset=0`;
  let page=0;
  while(url && items.length<scanMax){
    page++; setProg(4,`albums ${market} p${page}`);
    const data=await callSpotifyJSON(url,{}, {tag:`albums(${market})#${page}`});
    items.push(...(data.items||[]));
    url=data.next||null;
  }
  items.sort((a,b)=> new Date(b.release_date)-new Date(a.release_date));
  return items;
}
async function fetchAlbumTracks(albumId, albumName, albumDate, market, idx, total){
  setProg(10+Math.round((idx/Math.max(1,total))*20),`tracks ${market}: ${idx}/${total}`);
  let items=[]; let url=`https://api.spotify.com/v1/albums/${albumId}/tracks?market=${encodeURIComponent(market)}&limit=50&offset=0`;
  while(url){
    const data=await callSpotifyJSON(url,{}, {tag:`album:${market}:${idx}/${total}`});
    (data.items||[]).forEach(t=>{ if(t?.id) markSeen(t.id,market); });
    items.push(...(data.items||[]));
    url=data.next||null;
  }
  return items.map(t=>({ ...t, __albumDate: albumDate, __albumName: albumName }));
}

/* ====== æ¤œç´¢ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ ====== */
async function searchRemixesByArtist(artistId, markets, minYear){
  const outIds=new Set(); let artistName=null;
  try{
    const ai=await callSpotifyJSON(`https://api.spotify.com/v1/artists/${artistId}`,{}, {tag:"artistName"});
    artistName=ai?.name||"";
  }catch(e){ log("artist name å–å¾—å¤±æ•—: "+(e.message||e)); return []; }

  const years=`${minYear}-2030`;
  for(const mkt of markets){
    for(let offset=0; offset<1000; offset+=50){
      try{
        setProg(32, `search ${mkt} off ${offset}`);
        const q=encodeURIComponent(`artist:"${artistName}" remix year:${years}`);
        const data=await callSpotifyJSON(`https://api.spotify.com/v1/search?type=track&limit=50&offset=${offset}&q=${q}&market=${mkt}`,{}, {tag:`search:${mkt}:${offset}`});
        const tracks=(data.tracks&&data.tracks.items)||[];
        if(!tracks.length) break;
        for(const t of tracks){
          if(!t?.id) continue;
          const hasSeed=(t.artists||[]).some(a=>a?.id===artistId);
          if(!hasSeed) continue;
          if(!isRemixOnlyTitle(t.name)) continue;
          const yOk=yearFromDate(t.album?.release_date)>=minYear;
          if(!yOk) continue;
          outIds.add(t.id); markSeen(t.id, mkt);
        }
      }catch(e){
        log(`search ${mkt} off ${offset} å¤±æ•—: ${e.message||e}`); break;
      }
    }
  }
  log(`search fallback åç©«: ${outIds.size}æ›²`);
  return [...outIds];
}

/* ====== ä¸¦ã³/ã‚¹ã‚³ã‚¢ ====== */
function dedupeById(arr){ const seen=new Set(); const out=[]; for(const t of arr){ if(!seen.has(t.id)){ seen.add(t.id); out.push(t);} } return out; }
function computeScores(tracks,wPop,wRec){
  let minD=Infinity,maxD=-Infinity;
  for(const t of tracks){ const ms=new Date(t.album?.release_date||t.__albumDate||0).getTime()||0; t._dateMs=ms; if(ms){ if(ms<minD)minD=ms; if(ms>maxD)maxD=ms; } }
  for(const t of tracks){ const recent=t._dateMs?((t._dateMs-minD)/Math.max(1,(maxD-minD))):0.5; const pop=(t.popularity||0)/100; t._score=wPop*pop+wRec*recent; }
  tracks.sort((a,b)=>b._score-a._score);
}
function artistsSet(t){ return new Set((t.artists||[]).map(a=>a.id)); }
function shareArtist(a,b){ const A=artistsSet(a),B=artistsSet(b); for(const x of A){ if(B.has(x)) return true; } return false; }
function eraBlendCands(tracks,ratioOld,poolFactor){
  const arr=[...tracks]; arr.sort((a,b)=> (a._dateMs||0)-(b._dateMs||0));
  const N=Math.max(80, Math.floor((parseInt(el("finalSize").value||"100",10))*(poolFactor||1.6)));
  const kOld=Math.max(0, Math.min(arr.length, Math.floor(N*ratioOld)));
  const kNew=Math.max(0, Math.min(arr.length-kOld, N-kOld));
  const olds=arr.slice(0, Math.min(kOld, Math.floor(arr.length/2)));
  const news=arr.slice(-Math.min(kNew, Math.ceil(arr.length/2)));
  const set=new Map(); [...news,...olds].forEach(t=>set.set(t.id,t)); return [...set.values()];
}
function materializePins(){ return {1:(el("pin1").value||"").trim(),5:(el("pin5").value||"").trim(),40:(el("pin40").value||"").trim(),60:(el("pin60").value||"").trim()}; }
function balancedOrder(cands,pins,finalSize,opt){
  const posPins=new Map(Object.entries(pins).map(([k,v])=>[parseInt(k,10),v]).filter(([,v])=>v));
  const pinIds=new Set([...posPins.values()]);
  let rest=cands.filter(t=>!pinIds.has(t.id));

  const energies=rest.map(t=>t.features.energy||0.5).sort((a,b)=>a-b);
  const q1=energies[Math.floor(energies.length*0.25)]||0.25, q2=energies[Math.floor(energies.length*0.50)]||0.5, q3=energies[Math.floor(energies.length*0.75)]||0.75;
  const bucket=t=>(t.features.energy<=q1)?0:(t.features.energy<=q2)?1:(t.features.energy<=q3)?2:3;
  const bins=[[],[],[],[]]; rest.forEach(t=>bins[bucket(t)].push(t)); bins.forEach(b=>b.sort((a,b)=>b._score-a._score));

  const seq=new Array(finalSize).fill(null);
  for(const [pos,id] of posPins){ const t=cands.find(x=>x.id===id); if(t) seq[pos-1]=t; }
  let cycIdx=0; const wantHead5=true;
  function pickFromBin(bi,prev){
    const arr=bins[bi];
    for(let i=0;i<arr.length;i++){
      const t=arr[i];
      if(opt.noAdjacent!==false && prev && shareArtist(prev,t)) continue;
      arr.splice(i,1); return t;
    }
    return null;
  }
  function pickAny(prev){
    for(let r=0;r<4;r++){ const t=pickFromBin((cycIdx+r)%4,prev); if(t){cycIdx=(cycIdx+r+1)%4; return t;} }
    for(let bi=0;bi<4;bi++){ if(bins[bi].length){ return bins[bi].shift(); } }
    return null;
  }
  for(let i=0;i<finalSize;i++){
    if(seq[i]) continue;
    const prev=i>0?seq[i-1]:null; let chosen=null;
    if(wantHead5 && i>=1 && i<=3){
      const top=[...bins[3],...bins[2]].slice(0,20);
      for(const t of top){ if(opt.noAdjacent===false || !prev || !shareArtist(prev,t)){ chosen=t; break; } }
      if(chosen){ const bi=bucket(chosen); const idx=bins[bi].findIndex(x=>x.id===chosen.id); if(idx>=0) bins[bi].splice(idx,1); }
    }
    if(!chosen) chosen=pickAny(prev);
    seq[i]=chosen;
  }
  return seq.filter(Boolean);
}

/* ====== Breaks åˆ¤å®š ====== */
function classifyBreaks(t, genresMap, seedArtistId){
  for(const a of (t.artists||[])){
    const gs=genresMap.get(a.id)||[];
    if(gs.some(g=>genreOk(g))) return {ok:true, reason:"genres"};
  }
  if(breaksWordRe.test(t.name||"")) return {ok:true, reason:"title"};
  if(breaksWordRe.test(t.album?.name||"")) return {ok:true, reason:"album"};
  const label=(t.album && t.album.label)?t.album.label:"";
  if(breaksWordRe.test(label||"")) return {ok:true, reason:"label"};
  if(seedArtistId && (t.artists||[]).some(a=>a?.id===seedArtistId)){ return {ok:true, reason:"seed"}; }
  return {ok:false, reason:"none"};
}

/* ====== ã‚°ãƒ­ãƒ¼ãƒãƒ« ====== */
let trimmed=[], final100=[];
const trackMeta=new Map();

/* ====== åé›†ï¼ˆå…¨æ›²ã‚¹ã‚­ãƒ£ãƒ³ + searchãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ + ã‚¨ã‚¹ã‚«ãƒ¬ï¼‰ ====== */
async function doFastBuild(marketsOverride=null){
  if(!acquireLock(BUILD_LOCK_KEY)){ warn("ã»ã‹ã®ã‚¿ãƒ–ã§å®Ÿè¡Œä¸­ã€‚ã—ã°ã‚‰ãã—ã¦å†å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚"); return; }
  startHB(BUILD_LOCK_KEY);
  trimmed=[]; final100=[]; trackSeenBy.clear(); warn("");

  const checked=[...document.querySelectorAll(".ed:checked")].map(x=>x.value);
  if(checked.length===0){ alert("ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚"); releaseLock(BUILD_LOCK_KEY); return; }

  const needMkts=new Set();
  checked.forEach(k=> (EDITIONS[k].markets||[]).forEach(m=>needMkts.add(m)));
  CORE_SCAN_MARKETS.forEach(m=>needMkts.add(m));
  if(marketsOverride){ marketsOverride.forEach(m=>needMkts.add(m)); }
  let markets=[...needMkts];

  const artistId=el("artistId").value.trim();
  let recentN=Math.max(8, Math.min(80, parseInt(el("albumRecent").value||"30",10)));
  let oldRatio=Math.max(0, Math.min(0.8, parseFloat(el("oldAlbumRatio").value||"0.25")));
  const minYear=2010;
  const wPop=parseFloat(el("wPopularity").value||"0.6");
  const wRec=parseFloat(el("wRecent").value||"0.4");
  let targetPool=Math.max(120, Math.min(220, parseInt(el("targetPool").value||"150",10)));
  const SCAN_MAX=140;
  const types=needTypes();
  const groupsCsv = "album,single,compilation,appears_on";

  const collectIds=new Set();

  try{
    log(`=== FAST Build start editions=[${checked.join(",")}] markets=[${markets.join(",")}] recentN=${recentN} oldN=${Math.round(recentN*oldRatio)} ===`);

    // 1) ã‚¢ãƒ«ãƒãƒ åé›†
    const pickedAlbums=[];
    for(const m of markets){
      let all=albumCache.get(m);
      if(!all){ all=await scanArtistAlbums(artistId, m, groupsCsv, SCAN_MAX); albumCache.set(m, all); }
      const filteredAlbums = all.filter(a=>matchReleaseType(a, types));
      const rec = filteredAlbums.slice(0, recentN);
      const old = oldRatio ? filteredAlbums.slice(-Math.round(recentN*oldRatio)) : [];
      log(`å¸‚å ´ ${m}: albums(all=${all.length}, afterType=${filteredAlbums.length}) â†’ recent=${rec.length}, old=${old.length}`);
      rec.forEach(a=>pickedAlbums.push({market:m, album:a}));
      old.forEach(a=>pickedAlbums.push({market:m, album:a}));
    }

    // 2) å„ã‚¢ãƒ«ãƒãƒ ã®å…¨æ›²ã‹ã‚‰æŠ½å‡ºï¼ˆRemixã®ã¿/Mixé™¤å¤–/2010+ï¼‰
    for(let i=0;i<pickedAlbums.length;i++){
      const {market:m, album:a}=pickedAlbums[i];
      const tracks=await fetchAlbumTracks(a.id, a.name, a.release_date, m, i+1, pickedAlbums.length);
      for(const t of tracks){
        if(!t?.id) continue;
        const seedOK=(t.artists||[]).some(x=>x?.id===artistId);
        if(!seedOK) continue;
        if(!isRemixOnlyTitle(t.name)) continue;
        const yOk=yearFromDate(a.release_date)>=minYear;
        if(!yOk) continue;
        collectIds.add(t.id);
      }
      if(collectIds.size>=targetPool*3) break;
    }

    log(`ã‚¢ãƒ«ãƒãƒ å…¨æ›²ã‚¹ã‚­ãƒ£ãƒ³å¾Œ: ${collectIds.size}æ›²`);

    // 3) searchãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆè–„ã„å ´åˆï¼‰
    if(collectIds.size < targetPool){
      const extra = await searchRemixesByArtist(artistId, markets, minYear);
      extra.forEach(id=>collectIds.add(id));
      log(`search ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¾Œ: ${collectIds.size}æ›²`);
    }

    const uniq=[...collectIds];
    if(!uniq.length){ warn("å€™è£œ0ã€‚æ¡ä»¶ã‚’è¦‹ç›´ã—ã¦ãã ã•ã„ã€‚"); releaseLock(BUILD_LOCK_KEY); return; }

    log(`å€™è£œï¼ˆä¸‹ã”ã—ã‚‰ãˆå‰ï¼‰: ${uniq.length}æ›² â†’ è©³ç´°/ç‰¹å¾´é‡/ã‚¸ãƒ£ãƒ³ãƒ«å–å¾—â€¦`);

    // 4) è©³ç´°/ç‰¹å¾´é‡/ã‚¸ãƒ£ãƒ³ãƒ«
    const trackObjs=await fetchTracksBatched(uniq);
    const featsMap=await fetchFeaturesBatched(trackObjs.map(t=>t.id));
    const artistIds=new Set(); trackObjs.forEach(t=> (t.artists||[]).forEach(a=>a?.id&&artistIds.add(a.id)));
    const genresMap=await fetchArtistsGenresMapBatched([...artistIds]);

    // 5) ãƒ•ã‚£ãƒ«ã‚¿ï¼ˆ2010+ / RemixOnly / Breaks or seedOKï¼‰
    let filtered=trackObjs.map(t=>{ const f=featsMap.get(t.id)||{}; return {
      id:t.id, name:t.name, artists:t.artists||[], popularity:t.popularity||0, duration_ms:t.duration_ms||0,
      album:t.album||{}, features:{energy:f.energy??0.58,valence:f.valence??0.45,tempo:f.tempo??132,danceability:f.danceability??0.60}
    }; });

    const counts={year:0, remix:0, breaks:0}; const accept={genres:0,title:0,album:0,label:0,seed:0};
    filtered=filtered.filter(t=>{
      const yOk=yearFromDate(t.album?.release_date)>=minYear; if(!yOk){counts.year++;return false;}
      const rOk=isRemixOnlyTitle(t.name); if(!rOk){counts.remix++;return false;}
      const cls=classifyBreaks(t,genresMap,artistId); if(!cls.ok){counts.breaks++;return false;}
      accept[cls.reason]=(accept[cls.reason]||0)+1; return true;
    });

    filtered = dedupeById(filtered);
    computeScores(filtered, wPop, wRec);

    // 6) ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã¾ã å°‘ãªã‘ã‚Œã°å¸‚å ´è¿½åŠ ï¼‰
    if(filtered.length < 120){
      log("ãƒ—ãƒ¼ãƒ«ãŒè–„ã„ â†’ è¿½åŠ å¸‚å ´(MX/AR/NZ/NO/CH/HK/SG)ã§searchå¢—å¼·");
      const extraMkts = ["MX","AR","NZ","NO","CH","HK","SG"];
      const more = await searchRemixesByArtist(artistId, extraMkts, minYear);
      const moreSet=new Set(more);
      const moreTracks=await fetchTracksBatched([...moreSet]);
      moreTracks.forEach(t=>{
        const f=featsMap.get(t.id)||{};
        filtered.push({id:t.id, name:t.name, artists:t.artists||[], popularity:t.popularity||0, duration_ms:t.duration_ms||0, album:t.album||{}, features:{energy:f.energy??0.58,valence:f.valence??0.45,tempo:f.tempo??132,danceability:f.danceability??0.60}});
      });
      filtered = dedupeById(filtered);
      computeScores(filtered, wPop, wRec);
    }

    const upper=Math.max(120, Math.min(130, filtered.length));
    trimmed=filtered.slice(0, upper);

    log(`Breaksæ¡ç”¨å†…è¨³: genres=${accept.genres||0} / title=${accept.title||0} / album=${accept.album||0} / label=${accept.label||0} / seed=${accept.seed||0}`);
    log(`ãƒ•ã‚£ãƒ«ã‚¿å¾Œ: ${filtered.length}æ›²ï¼ˆé™¤å¤–: å¹´<${minYear}:${counts.year} / Remixè¦å‰‡:${counts.remix} / Breakséè©²å½“:${counts.breaks}ï¼‰`);
    if(trimmed.length>=120){
      el("btnTrim").disabled=false;
      el("btnBalance").disabled=false;
      el("btnBuildEditions").disabled=false;
      log(`FAST Build å®Œäº†ï¼š${trimmed.length}æ›²`);
    }else{
      warn("å€™è£œãŒ120æœªæº€ã€‚EP/Single/Compilationã®ONã‚„ albumRecentâ†‘ ã‚’æ¤œè¨ã€‚");
    }
  }catch(e){
    log("ã‚¨ãƒ©ãƒ¼: "+(e.message||e));
  }finally{
    releaseLock(BUILD_LOCK_KEY);
  }
}

/* ====== Trim / Balance ====== */
async function doTrim(){ trimmed=trimmed.slice(0, Math.max(120, Math.min(130, trimmed.length))); log(`Trim å®Œäº†ï¼š${trimmed.length}æ›²`); }
async function doBalance(){
  const finalSize=Math.max(80, Math.min(100, parseInt(el("finalSize").value||"100",10)));
  const pins=materializePins();
  const ratioOld=Math.max(0, Math.min(0.8, parseFloat(el("ratioOld").value||"0.30")));
  const cand=eraBlendCands(trimmed, ratioOld, 1.6);
  final100=balancedOrder(cand, pins, finalSize, {noAdjacent:true, head5:true});
  log(`Balanced ç”Ÿæˆï¼š${final100.length}æ›²ï¼ˆEraMix=${ratioOld} / Remix Only / 2010+ï¼‰`);
  el("btnCommit").disabled=final100.length===0;
}

/* ====== ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆåæ˜  ====== */
async function putPlaylist(name, desc, isPublic, uris, existingId=null){
  const maxRetry=Math.max(1, parseInt(el("maxRetry").value||"5",10));
  MIN_API_GAP_MS=Math.max(300, parseInt(el("gap").value||"1000",10));
  const me=await callSpotifyJSON("https://api.spotify.com/v1/me",{}, {tag:"/me",maxRetry}); const uid=me.id;
  let playlistId=existingId||null;
  if(playlistId){
    await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}`,{method:"PUT",body:JSON.stringify({name,description:desc,public:isPublic})},{tag:"PUT playlist",maxRetry,expectJSON:false});
  }else{
    const created=await callSpotifyJSON(`https://api.spotify.com/v1/users/${uid}/playlists`,{method:"POST",body:JSON.stringify({name,description:desc,public:isPublic})},{tag:"POST playlist",maxRetry});
    playlistId=created.id;
  }
  const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
  await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`,{method:"PUT",body:JSON.stringify({uris:chunks[0]||[]})},{tag:"PUT tracks",maxRetry,expectJSON:false});
  for(let i=1;i<chunks.length;i++){
    await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`,{method:"POST",body:JSON.stringify({uris:chunks[i]})},{tag:`POST tracks #${i+1}`,maxRetry});
  }
  log(`å®Œæˆ: https://open.spotify.com/playlist/${playlistId}`);
}

/* ====== Edition Builder ====== */
function selectedEditions(){ return [...document.querySelectorAll(".ed:checked")].map(x=>x.value); }
function coverageOk(trackId, ed, relaxStep=0){
  const seen=trackSeenBy.get(trackId)||new Set();
  if(ed.anyOf){ return ed.anyOf.some(m=>seen.has(m)); }
  if(ed.needCount){ const c=ed.markets.reduce((n,m)=>n+(seen.has(m)?1:0),0); const need=Math.max(1, ed.needCount-relaxStep); return c>=need; }
  if(ed.needPct){ const total=ed.markets.length; const c=ed.markets.reduce((n,m)=>n+(seen.has(m)?1:0),0); const need=Math.max(1, Math.ceil(total*(ed.needPct-relaxStep*0.1))); return c>=need; }
  return true;
}
async function buildEditions(){
  const eds=selectedEditions(); if(!eds.length){ alert("ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚"); return; }
  await doFastBuild(); if(!trimmed.length){ alert("å€™è£œãŒä¸è¶³ã—ã¦ã„ã¾ã™ã€‚"); return; }

  const finalSize=Math.max(80, Math.min(100, parseInt(el("finalSize").value||"100",10)));
  const pins=materializePins();
  const ratioOld=Math.max(0, Math.min(0.8, parseFloat(el("ratioOld").value||"0.30")));
  const base=(el("baseName").value||"TDCS â€“ Breaks Remix Only 100 (2010+)").trim();
  const desc=(el("baseDesc").value||"Breaks/Breakbeaté™å®šãƒ»2010+ãƒ»Remixã®ã¿ãƒ»Pinså›ºå®šãƒ»ãƒãƒ©ãƒ³ã‚¹é…ç½®").trim();
  const isPublic=el("isPublic").value==="true";

  for(const key of eds){
    const ed=EDITIONS[key];
    let keep=trimmed.filter(t=>coverageOk(t.id,ed,0));
    if(keep.length<finalSize) keep=trimmed.filter(t=>coverageOk(t.id,ed,1));
    if(keep.length<finalSize) keep=trimmed.filter(t=>coverageOk(t.id,ed,2));
    if(keep.length<finalSize) keep=trimmed;

    const cand=eraBlendCands(keep, ratioOld, 1.6);
    const seq =balancedOrder(cand, pins, finalSize, {noAdjacent:true, head5:true});
    const uris=seq.map(t=>`spotify:track:${t.id}`);
    const name=`${base}${ed.suffix}`;
    log(`Edition ${key}: å¯ç”¨æ€§ ${keep.length}æ›² â†’ æœ€çµ‚ ${seq.length}æ›²`);
    await putPlaylist(name, `${desc} ${ed.suffix}`, isPublic, uris, null);
  }
  alert("UK/US/EU/World ã®ä½œæˆãŒå®Œäº†ã—ã¾ã—ãŸã€‚");
}

/* ====== ã‚¯ãƒªãƒƒã‚¯å§”ä»» + ç·Šæ€¥ãƒªã‚»ãƒƒãƒˆï¼ˆãƒœã‚¿ãƒ³ãŒç„¡åå¿œã§ã‚‚æ‹¾ã†ï¼‰ ====== */
document.addEventListener('click', async (e)=>{
  const btn = e.target.closest('button, a.btn'); if (!btn) return;
  const id = btn.id || btn.getAttribute('href') || '(no-id)'; log(`â–¶ click: ${id}`);
  if (btn.tagName === 'A') return; // Sign inãƒªãƒ³ã‚¯ã¯é€šå¸¸é·ç§»
  e.preventDefault();
  try{
    switch (btn.id) {
      case 'btnMe': {
        try { const me = await callSpotifyJSON('https://api.spotify.com/v1/me', {}, {tag:'/me'}); log(`/me OK: ${me.display_name||'(no name)'} / ${me.id}`); }
        catch(err){ alert('ã‚µã‚¤ãƒ³ã‚¤ãƒ³ãŒå¿…è¦ã§ã™'); log('ã‚¨ãƒ©ãƒ¼: '+(err.message||err)); }
        break;
      }
      case 'btnSignOut': {
        try { Object.values(K).forEach(k=>sessionStorage.removeItem(k)); log('ä¿å­˜ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚'); renderStatus(); }
        catch(err){ log('ã‚¨ãƒ©ãƒ¼: '+(err.message||err)); }
        break;
      }
      case 'btnFast':       await doFastBuild(); break;
      case 'btnTrim':       await doTrim();      break;
      case 'btnBalance':    await doBalance();   break;
      case 'btnBuildEditions': await buildEditions(); break;
      case 'btnCommit': {
        if (!window.final100 || !final100.length) { alert('â‘¢Balanced ã‚’å…ˆã«å®Ÿè¡Œã—ã¦ãã ã•ã„'); return; }
        const name=(el('plName').value||'TDCS â€“ Breaks Remix Only 100 (2010+)').trim();
        const desc=(el('plDesc').value||'Breaks/Breakbeaté™å®šãƒ»2010+ãƒ»Remixã®ã¿ãƒ»Pinså›ºå®šãƒ»ãƒãƒ©ãƒ³ã‚¹é…ç½®').trim();
        const isPublic=el('plPublic').value==='true';
        const existing=el('existingId').value.trim()||null;
        await putPlaylist(name, desc, isPublic, final100.map(t=>`spotify:track:${t.id}`), existing);
        break;
      }
      case 'btnRepair': {
        localStorage.removeItem('sp_build_lock_v1');
        [K.access,K.expAt,K.refresh,K.scope].forEach(k=>sessionStorage.removeItem(k));
        renderStatus(); log('ğŸ”§ ãƒªã‚»ãƒƒãƒˆå®Œäº†ã€‚å¿…è¦ãªã‚‰å†ã‚µã‚¤ãƒ³ã‚¤ãƒ³ã‚’ã€‚');
        break;
      }
    }
  }catch(err){ log('ã‚¨ãƒ©ãƒ¼: '+(err.message||err)); }
});

/* ====== èµ·å‹•ãƒ­ã‚° & ç·Šæ€¥ãƒœã‚¿ãƒ³è‡ªå‹•è¿½åŠ  ====== */
(function boot(){
  log("âœ… index loaded: "+location.href);
  renderStatus();
  // ç”»é¢ã«ç·Šæ€¥ãƒœã‚¿ãƒ³ã‚’è¿½åŠ ï¼ˆè¦‹å¤±ã£ã¦ã‚‚è‡ªå‹•ã§ç”Ÿãˆã‚‹ï¼‰
  if (!document.getElementById('btnRepair')) {
    const holder = document.querySelector('.progress') || document.body;
    const b = document.createElement('button');
    b.id = 'btnRepair'; b.textContent = 'ğŸ”§ ç·Šæ€¥ãƒªã‚»ãƒƒãƒˆ';
    b.style.marginLeft = '8px';
    holder.appendChild(b);
  }
  // ãƒ­ãƒƒã‚¯ãŒå¤ã‘ã‚Œã°è‡ªå‹•è§£æ”¾ï¼ˆ120ç§’â†’30ç§’ã«çŸ­ç¸®ï¼‰
  try{
    const raw = localStorage.getItem('sp_build_lock_v1');
    if (raw) {
      const obj = JSON.parse(raw);
      const tooOld = !obj || (Date.now() - (obj.ts||0) > 30*1000);
      if (tooOld) localStorage.removeItem('sp_build_lock_v1');
    }
  }catch(_){}
})();
</script>
</body>
</html>
