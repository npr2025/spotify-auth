<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TDCS Editions Builder â€” 4Ã—130 / è¢«ã‚ŠOKæº€æ•°åŒ–ï¼ˆfrom_tokenç„¡/403è€æ€§/TDCSé™å®šï¼‰</title>
<style>
:root{--bg:#0b1220;--fg:#cfe3ff}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:1180px;margin:32px auto;padding:0 12px}
h1{margin:0 0 8px}
fieldset{border:1px solid #ddd;border-radius:10px;padding:14px;margin:14px 0}
label{display:block;margin:6px 0}
input[type="text"],input[type="number"],select{width:100%;max-width:760px;padding:6px 8px;border:1px solid #ccc;border-radius:6px}
input[type="file"]{margin:4px 0}
button{padding:9px 12px;border:1px solid #bbb;border-radius:8px;background:#fff;cursor:pointer;margin:6px 8px 0 0}
button:disabled{opacity:.5;cursor:not-allowed}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
small.hint{color:#666}
#log{white-space:pre-wrap;background:var(--bg);color:var(--fg);padding:12px;border-radius:8px;min-height:280px;max-height:540px;overflow:auto}
#progWrap{position:relative;height:12px;background:#e6eaf2;border-radius:6px;overflow:hidden;margin:6px 0}
#progBar{height:100%;width:0%;background:#4a90e2;transition:width .2s ease}
#progLine{font-variant-numeric:tabular-nums;margin:4px 0 0 0;color:#333}
.hidden{display:none}
</style>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<h1>TDCS Editions Builder â€” è‡ªå‹•è£œå……ã§ 4Ã—130ï¼ˆè¢«ã‚ŠOKï¼ãƒãƒ©ãƒ³ã‚¹åˆ†é…ï¼‰</h1>
<p id="status">æœªæ¥ç¶š</p>
<div>
  <button id="btnConnect">Spotifyã«ã‚µã‚¤ãƒ³ã‚¤ãƒ³</button>
  <button id="btnReset">åˆæœŸåŒ–ï¼ˆä¿å­˜ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤ï¼‰</button>
  <button id="btnCheck">æ¥ç¶šãƒã‚§ãƒƒã‚¯</button>
</div>

<fieldset>
  <legend>å›ºå®š</legend>
  <div class="grid2">
    <label>CLIENT_ID <input type="text" value="1fd6350fcf4945a0b3ddffa2d5730d4e" disabled></label>
    <label>REDIRECT_URI <input type="text" value="https://npr2025.github.io/spotify-auth/callback.html" disabled></label>
  </div>
</fieldset>

<fieldset>
  <legend>è¨­å®šï¼ˆ4ãƒªã‚¹ãƒˆï¼‰</legend>
  <div class="grid2">
    <label>UK <input id="plUK" type="text" value="https://open.spotify.com/playlist/6wrsoYUr3IagrMW7zlwaIS"></label>
    <label>US <input id="plUS" type="text" value="https://open.spotify.com/playlist/6pv3J4odtKELYRIwoiZHhe"></label>
    <label>EU <input id="plEU" type="text" value="https://open.spotify.com/playlist/4VadrmkpMeXK813mkhWGwV"></label>
    <label>WORLD <input id="plWORLD" type="text" value="https://open.spotify.com/playlist/5y1UWtrBjYjHpReuAsnFMR"></label>
  </div>
  <div class="grid3">
    <label>APIé–“éš”(ms) <input id="gap" type="number" value="1200"></label>
    <label>å„ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³å‡ºåŠ›æ•° <input id="finalN" type="number" value="130"></label>
    <label>äººæ°—ã®é‡ã¿ï¼ˆSaveRateå´ï¼‰<input id="wPopularity" type="number" step="0.01" value="0.55"></label>
  </div>
  <div class="grid3">
    <label>UKãƒ—ãƒªã‚»ãƒƒãƒˆ
      <select id="presetUK"><option>waves</option><option selected>rise</option><option>drop</option><option>dj</option></select>
    </label>
    <label>USãƒ—ãƒªã‚»ãƒƒãƒˆ
      <select id="presetUS"><option selected>rise</option><option>waves</option><option>drop</option><option>dj</option></select>
    </label>
    <label>EUãƒ—ãƒªã‚»ãƒƒãƒˆ
      <select id="presetEU"><option selected>waves</option><option>rise</option><option>drop</option><option>dj</option></select>
    </label>
  </div>

  <label>ä¸»è¦ãƒãƒ¼ã‚±ãƒƒãƒˆï¼ˆå„ªå…ˆé †ãƒ»ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šï¼‰
    <input id="markets" type="text" value="AU,NZ,US,GB,ES,NL">
  </label>
  <small class="hint">ä¾‹: AU,NZ,US,GB,ES,NLï¼ˆå·¦ã»ã©å„ªå…ˆï¼‰ã€‚æœªå…¥åŠ›æ™‚ã®æ—¢å®šã‚‚ã“ã‚Œã€‚</small>

  <div class="grid3">
    <label>åŒãƒªãƒŸã‚­ã‚µãƒ¼æœ€å°é–“éš”ï¼ˆæ›²ï¼‰<input id="gapRemixer" type="number" value="3"></label>
    <label>åŒã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆæœ€å°é–“éš”ï¼ˆæ›²ï¼‰<input id="gapArtist" type="number" value="4"></label>
    <label><input id="appendDate" type="checkbox" checked> æ–°è¦åã«æ—¥ä»˜ï¼ˆYYYY-MM-DDï¼‰</label>
  </div>

  <div>
    <label><input id="fastMode" type="checkbox" checked> é«˜é€Ÿãƒ¢ãƒ¼ãƒ‰ï¼ˆæ¤œç´¢ãƒãƒ¼ã‚±ãƒƒãƒˆæœ€å°åŒ–ï¼æ—©æœŸçµ‚äº†ï¼‰</label>
  </div>

  <div>
    <label><input id="allowCrossDupes" type="checkbox" checked> ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³é–“ã®ç›¸äº’éé‡è¤‡ã‚’ã‚ªãƒ•ï¼ˆï¼å„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§è¢«ã‚ŠOKï¼‰</label>
    <label><input id="allowRepeatFill"  type="checkbox" checked> ä¸è¶³æ™‚ã¯ç‰ˆå†…ãƒªãƒ”ãƒ¼ãƒˆã§æº€æ•°åŒ–ï¼ˆç›´å‰æ›²ã¯é¿ã‘ã‚‹ï¼‰</label>
  </div>

  <div>
    <label><input id="doUpdate" type="checkbox" checked> æ—¢å­˜4ãƒªã‚¹ãƒˆã‚’ä¸Šæ›¸ã</label>
    <label><input id="doCreate" type="checkbox" checked> åŒå†…å®¹ã§æ–°è¦4ãƒªã‚¹ãƒˆã‚‚ä½œæˆï¼ˆå…¬é–‹ï¼‰</label>
    <label>æ–°è¦ãƒªã‚¹ãƒˆåã®æ¥é ­è¾ <input id="newPrefix" type="text" value="TDCS Editions"></label>
  </div>
  <small class="hint">â€»åŒã˜éŒ²éŸ³ï¼ˆURI/ISRC/ãƒ™ãƒ¼ã‚¹æ›²åï¼‹å…ˆé ­ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDï¼‰ã¯å€™è£œãƒ—ãƒ¼ãƒ«å†…ã§ã¯ãƒ¦ãƒ‹ãƒ¼ã‚¯åŒ–ã€‚ãŸã ã—**ç‰ˆå†…ãƒªãƒ”ãƒ¼ãƒˆ**ã¯æº€æ•°åŒ–ã®ãŸã‚ã«è¨±å¯ï¼ˆç›´å‰åŒä¸€ã¯å›é¿ï¼‰ã€‚TDCSï¼ˆThe Darrow Chem Syndicateï¼‰ä»¥å¤–ã¯é™¤å¤–ã€‚</small>
</fieldset>

<fieldset>
  <legend>ãƒ•ã‚¡ã‚¤ãƒ«</legend>
  <label>ã‚½ãƒ¼ã‚¹CSVï¼ˆä»»æ„ï¼‰<input id="fileSource" type="file" accept=".csv"></label>
  <label>åˆ†æï¼ˆExcel .xlsx / CSVï¼‰<input id="fileAnalytics" type="file" accept=".xlsx,.csv"></label>
  <small class="hint">åˆ—ã¯è‡ªå‹•æ¤œå‡ºã€‚Exactâ†’Fuzzyâ†’Spotifyæ¤œç´¢â†’ï¼ˆTDCSã®ï¼‰Top/æ–°è­œ/ãƒ‡ã‚£ã‚¹ã‚³ã‚°å…¨ä»¶ã§è‡ªå‹•è£œå……ã€‚</small>
</fieldset>

<fieldset>
  <legend>é€²æ—</legend>
  <div id="progWrap" class="hidden"><div id="progBar"></div></div>
  <div id="progLine">0% â€” å¾…æ©Ÿä¸­</div>
</fieldset>

<fieldset>
  <legend>ãƒ­ã‚°</legend>
  <pre id="log">Bootingâ€¦</pre>
</fieldset>

<div>
  <button id="btnExportXlsx" disabled>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆXLSXï¼‰</button>
  <button id="btnExportCsv"  disabled>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆCSVï¼‰</button>
</div>

<script>
/* ====== ä¾‹å¤– ====== */
window.onerror=(m,src,lin,col,err)=>{ const el=document.getElementById("log"); el.textContent+=(el.textContent?"\n":"")+"ğŸ’¥ ScriptError: "+m+" @"+lin+":"+col; console.error(err||m); };
window.addEventListener("unhandledrejection",(e)=>{ const el=document.getElementById("log"); el.textContent+=(el.textContent?"\n":"")+"ğŸ’¥ PromiseRejection: "+(e.reason&&e.reason.message?e.reason.message:String(e.reason)); console.error(e.reason); });

/* ====== å›ºå®š ====== */
const FORCED_ARTIST_IDS=["55fvQ5I2IZUfcFT2DV02T3"]; // The Darrow Chem Syndicate
const zws=/[\u200B-\u200D\uFEFF]/g;
const CLIENT_ID="1fd6350fcf4945a0b3ddffa2d5730d4e".replace(zws,"").trim();
const REDIRECT_URI="https://npr2025.github.io/spotify-auth/callback.html".replace(zws,"").trim();
const SCOPES="playlist-modify-public playlist-modify-private ugc-image-upload";
const LS={acc:"sp_access_token",ref:"sp_refresh_token",exp:"sp_token_exp",ver:"sp_code_verifier"};

/* ====== DOM/UTIL ====== */
const $=(id)=>document.getElementById(id);
const log=(s)=>{const el=$("log"); el.textContent+=(el.textContent?"\n":"")+s; el.scrollTop=el.scrollHeight;}
const progress=(p,msg)=>{ $("progWrap").classList.remove("hidden"); $("progBar").style.width=Math.max(0,Math.min(100,p))+"%"; if(msg) $("progLine").textContent=Math.round(p)+"% â€” "+msg; }
const subProgress=(i,t,s,e,l)=>{ const f=t?i/t:0; progress(s+(e-s)*f,`${l} (${i}/${t})`); }
const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
const num=(x)=>{const s=String(x==null?0:x).replace(/[ %,ï¼Œ]/g,""); const v=parseFloat(s); return isFinite(v)?v:0;}
const round4=(x)=> (typeof x==="number"&&isFinite(x))?Math.round(x*10000)/10000:"";

/* ====== Auth ====== */
const isAuthed=()=> !!localStorage.getItem(LS.acc) && Date.now() < (+localStorage.getItem(LS.exp)||0)-5000;
function setStatus(){ $("status").textContent=isAuthed()?"æ¥ç¶šä¸­ï¼ˆOKï¼‰":"æœªæ¥ç¶š"; if(isAuthed() && _pending) resolveAndWrite(_pending); }
async function startAuth(){
  // PKCE
  let v=""; const u8=new Uint8Array(64); crypto.getRandomValues(u8); for(let i=0;i<u8.length;i++) v+=String.fromCharCode(97+(u8[i]%26));
  localStorage.setItem(LS.ver,v);
  const h=new Uint8Array(await crypto.subtle.digest("SHA-256",new TextEncoder().encode(v)));
  let b=""; for(const x of h) b+=String.fromCharCode(x);
  const ch=btoa(b).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  const u=new URL("https://accounts.spotify.com/authorize");
  u.searchParams.set("response_type","code"); u.searchParams.set("client_id",CLIENT_ID);
  u.searchParams.set("redirect_uri",REDIRECT_URI);
  u.searchParams.set("code_challenge_method","S256"); u.searchParams.set("code_challenge",ch);
  u.searchParams.set("scope",SCOPES);
  location.href=u.toString();
}
async function refreshTokenIfNeeded(){
  const exp=+(localStorage.getItem(LS.exp)||0);
  if(Date.now()<exp-5000) return;
  const rt=localStorage.getItem(LS.ref); if(!rt) return;
  const body=new URLSearchParams(); body.set("grant_type","refresh_token"); body.set("refresh_token",rt); body.set("client_id",CLIENT_ID);
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok){ log("âš ï¸ refreshå¤±æ•— "+r.status); return; }
  const j=await r.json();
  localStorage.setItem(LS.acc,j.access_token); localStorage.setItem(LS.exp,String(Date.now()+j.expires_in*1000));
  if(j.refresh_token) localStorage.setItem(LS.ref,j.refresh_token);
}
async function spFetch(path,method="GET",body=null){
  await refreshTokenIfNeeded();
  const gap=+($("gap").value||1200); await sleep(gap);
  for(let a=0;a<5;a++){
    const init={method,headers:{"Authorization":"Bearer "+localStorage.getItem(LS.acc),"Content-Type":"application/json"}};
    if(body) init.body=JSON.stringify(body);
    const r=await fetch("https://api.spotify.com"+path,init);
    if(r.status===401){ await refreshTokenIfNeeded(); continue; }
    if(r.status===429){ const ra=+(r.headers.get("Retry-After")||2); log("â³429â†’"+ra+"så¾…æ©Ÿ"); await sleep(ra*1000); continue; }
    if(!r.ok){
      const t=await r.text();
      if(r.status===403 && method==="GET"){ log(`âš ï¸ 403 GET ${path.slice(0,60)} â€¦ ç¶šè¡Œ`); return null; }
      throw new Error(`Spotify ${r.status}: ${(t||"").slice(0,200)} @ ${path}`);
    }
    if(r.status===204) return null;
    return await r.json();
  }
  throw new Error("Spotify API max retries");
}
let _me=null; async function getMe(){ if(_me) return _me; _me=await spFetch("/v1/me","GET"); return _me; }

/* ====== ãƒãƒ¼ã‚±ãƒƒãƒˆ ====== */
function getMarkets(){
  const raw=($("markets")?.value||"").toUpperCase();
  const arr=raw.split(",").map(s=>s.trim()).filter(Boolean);
  const out=arr.length?arr:["AU","NZ","US","GB","ES","NL"];
  return Array.from(new Set(out));
}

/* ====== ãƒ•ã‚¡ã‚¤ãƒ« ====== */
let sourceRows=[], analyticsRows=[];
function readCSV(file){return new Promise((res,rej)=>Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>res(r.data),error:rej}));}
async function readXLSX_allSheets(file){
  const buf=await file.arrayBuffer(); const wb=XLSX.read(buf,{type:"array"}); let rows=[],details=[];
  for(const n of wb.SheetNames){ const js=XLSX.utils.sheet_to_json(wb.Sheets[n],{defval:""}); for(const r of js) r.__sheet=n; rows=rows.concat(js); details.push(n+":"+js.length); }
  return {rows,details};
}
async function loadFiles(){
  $("log").textContent=""; progress(3,"ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿â€¦");
  if($("fileSource").files.length){ sourceRows=await readCSV($("fileSource").files[0]); log("âœ… ã‚½ãƒ¼ã‚¹: "+sourceRows.length+" è¡Œ"); }
  const f=$("fileAnalytics").files[0];
  if((f.name||"").toLowerCase().endsWith(".xlsx")){ const r=await readXLSX_allSheets(f); analyticsRows=r.rows; log("âœ… åˆ†æ: XLSX åˆè¨ˆ "+analyticsRows.length+" è¡Œ ["+r.details.join(", ")+"]"); }
  else{ analyticsRows=await readCSV(f); log("âœ… åˆ†æ: CSV "+analyticsRows.length+" è¡Œ"); }
  progress(8,"èª­ã¿è¾¼ã¿å®Œäº†"); await runAnalysis();
}

/* ====== æ­£è¦åŒ–ãƒ»åˆ—æ¨å®š ====== */
const ISRC_RE=/^[A-Z]{2}-?[A-Z0-9]{3}-?\d{2}-?\d{5}$/i;
const NFKC=(s)=>String(s||"").normalize("NFKC");
const rmMarks=(s)=>NFKC(s).normalize("NFD").replace(/[\u0300-\u036f]/g,"");
const norm=(s)=>rmMarks(s).toLowerCase().replace(/[â€-â€’â€“â€”âˆ’]/g,"-").replace(/[â€˜â€™â€šâ€›â€œâ€â€â€Ÿ"]/g," ").replace(/[()ï¼»ï¼½\[\]{}ã€ã€‘]/g," ").replace(/&/g," and ").replace(/\s+/g," ").trim();
const tokensTitle=(s)=>{s=norm(s).replace(/ - /g," ").replace(/\((.*?)\)/g," $1 ").replace(/\[(.*?)\]/g," $1 "); const arr=s.split(" "); const stop=new Set(["feat","featuring","ft","vs","and","&","the","a","an","mix","remix","edit","version","vip","dub","club","radio","extended","original","instrumental","clean","dirty"]); const set={},out=[]; for(const w of arr){ if(w && !stop.has(w)){ if(!set[w]){set[w]=1;out.push(w);} } } return out; }
function setJaccard(A,B){let inter=0,sa={},sb={}; A.forEach(x=>sa[x]=1); B.forEach(x=>sb[x]=1); for(const x in sa){ if(sb[x]) inter++; } const ua=Object.keys(sa).length+Object.keys(sb).length-inter; return ua?inter/ua:0; }
function canonVersion(s){
  s=norm(s); const pairs=[["original mix","original"],["orig mix","original"],["radio edit","radio"],["extended mix","extended"],["club mix","club"]];
  pairs.forEach(([a,b])=>s=s.replace(a,b));
  const kinds=[],seen={}; const add=k=>{if(k&&!seen[k]){kinds.push(k);seen[k]=1;}}
  if(/original/.test(s))add("original"); if(/radio/.test(s))add("radio"); if(/extended/.test(s))add("extended");
  if(/instrumental/.test(s))add("instrumental"); if(/acoustic/.test(s))add("acoustic"); if(/vip/.test(s))add("vip");
  if(/dub/.test(s))add("dub"); if(/club/.test(s))add("club"); if(/remix|rmx/.test(s))add("remix");
  const rem=s.replace(/\b(original|radio|extended|instrumental|acoustic|vip|dub|club|remix|mix|edit)\b/g," ").trim();
  return {kinds, remTok:tokensTitle(rem)};
}
const extractTrackId=(raw)=>{const s=String(raw||"").trim(); if(!s) return ""; let m=s.match(/spotify:track:([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/open\.spotify\.com\/track\/([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/\/track\/([A-Za-z0-9]{22})(?:\?|$)/); if(m) return m[1]; m=s.match(/^([A-Za-z0-9]{22})$/); if(m) return m[1]; return ""; }
function extractArtistIds(raw){
  if(raw==null) return []; const s=String(raw); const parts=s.split(/[,;\/|]+|\s{2,}/g); const ids=[],has={};
  const push=(id)=>{ if(id && !has[id]){ids.push(id);has[id]=1;} }
  for(const p0 of parts){
    const p=(p0||"").trim(); if(!p) continue;
    let m=p.match(/spotify:artist:([A-Za-z0-9]{22})/); if(m){push(m[1]); continue;}
    m=p.match(/open\.spotify\.com\/artist\/([A-Za-z0-9]{22})/); if(m){push(m[1]); continue;}
    m=p.match(/\b([A-Za-z0-9]{22})\b/); if(m){push(m[1]); continue;}
  }
  return ids;
}
function columns(rows){const s={},out=[]; for(let i=0;i<Math.min(400,rows.length);i++){ for(const k of Object.keys(rows[i])) if(!s[k]){s[k]=1; out.push(k);} } return out;}
function pickByName(cols,pref){ const L=cols.map(c=>[c,norm(c)]); for(const p of pref){const n=norm(p); const hit=L.find(([,m])=>m===n||m.includes(n)); if(hit) return hit[0];} return ""; }
function bestColOrEmpty(cols,scorer,min=0.15){let best=null,bs=-1; for(const c of cols){const sc=scorer(c); if(sc>bs){bs=sc; best=c;}} return (bs>=min)?best:"";}
function pickSourceColumns(rows){
  const cols=columns(rows);
  const scId=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<1200;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(/spotify:track:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/track\/[A-Za-z0-9]{22}/.test(v)||/^[A-Za-z0-9]{22}$/.test(v))m++;} return n?m/n:0;}
  const scIsrc=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<2000;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(ISRC_RE.test(v))m++;} return n?m/n:0;}
  const scAid=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<1500;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(/spotify:artist:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/artist\/[A-Za-z0-9]{22}/.test(v)||/\b([A-Za-z0-9]{22})\b/.test(v))m++;} return n?m/n:0;}
  return {
    idCol:bestColOrEmpty(cols,scId,0.20),
    isrcCol:bestColOrEmpty(cols,scIsrc,0.20),
    artistIdCol:bestColOrEmpty(cols,scAid,0.20),
    nameCol:pickByName(cols,["track title","track_name","title","æ›²å","ã‚¿ã‚¤ãƒˆãƒ«"])||cols[0]||"",
    verCol: pickByName(cols,["track version","version","ãƒãƒ¼ã‚¸ãƒ§ãƒ³"]),
    artistCol:pickByName(cols,["track primary artists","primary artists","artists","artist","ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ"])||cols[0]||"",
    remixCol: pickByName(cols,["remixer","remixers","ãƒªãƒŸã‚­ã‚µãƒ¼"])
  };
}
function pickAnalyticColumns(rows){
  const cols=columns(rows);
  const scId=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<1200;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(/spotify:track:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/track\/[A-Za-z0-9]{22}/.test(v)||/^[A-Za-z0-9]{22}$/.test(v))m++;} return n?m/n:0;}
  const scIsrc=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<2000;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(ISRC_RE.test(v))m++;} return n?m/n:0;}
  const idCol=bestColOrEmpty(cols,scId,0.20)||pickByName(cols,["spotify_uri","track_uri","uri","url"]);
  const isrcCol=bestColOrEmpty(cols,scIsrc,0.20)||pickByName(cols,["isrc","isrc_code"]);
  function pickText(pref){const cand=cols.filter(c=>/title|name|æ›²å|artist|ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ/i.test(c)); return cand[0]||pickByName(cols,pref)||cols[0]||"";}
  return { idCol,isrcCol,nameCol:pickText(["title","track_name","æ›²å"]),artistCol:pickText(["artist","artists","ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ"]),
    p24:pickByName(cols,["plays_24h","p24","streams24","24h"]), p7:pickByName(cols,["plays_7d","p7","streams7","7d"]), p28:pickByName(cols,["plays_28d","p28","streams28","28d"]),
    s24:pickByName(cols,["save_rate_24h","sr24","save24"]), s7:pickByName(cols,["save_rate_7d","sr7","save7"]), s28:pickByName(cols,["save_rate_28d","sr28","save28"]),
    uk:pickByName(cols,["uk","available_uk","è‹±å›½"]), us:pickByName(cols,["us","available_us","ç±³å›½","ã‚¢ãƒ¡ãƒªã‚«"]), eu:pickByName(cols,["eu","available_eu","æ¬§å·","ãƒ¨ãƒ¼ãƒ­ãƒƒãƒ‘"]), wo:pickByName(cols,["world","available_world","global","å…¨ä¸–ç•Œ"]) };
}

/* ====== TDCSåˆ¤å®š ====== */
function _hasTDCSOnArtists(arr){
  if(!Array.isArray(arr)) return false;
  return arr.some(a=>{
    const n=(a&&a.name)||"";
    return (a&&FORCED_ARTIST_IDS.includes(a.id))
        || /darrow\s*chem\s*syndicate/i.test(n)
        || /\bTDCS\b/i.test(n);
  });
}
function hasTDCSTrackObj(t){
  if(!t) return false;
  return _hasTDCSOnArtists(t.artists)
      || _hasTDCSOnArtists(t.album && t.album.artists)
      || /darrow\s*chem\s*syndicate|\bTDCS\b/i.test(t.name||"");
}

/* ====== çªåˆãƒ»ã‚¹ã‚³ã‚¢ ====== */
function buildSourceIndex(cfg){
  if(!sourceRows.length) return {idxExact:new Map(),blob:[]};
  const idxExact=new Map(), blob=[]; let hasAid=0;
  for(const r of sourceRows){
    const id=cfg.idCol?extractTrackId(r[cfg.idCol]):"";
    const isrc=cfg.isrcCol?String(r[cfg.isrcCol]||"").trim().toUpperCase():"";
    const t=String(cfg.nameCol? r[cfg.nameCol] : "").trim(), v=String(cfg.verCol? r[cfg.verCol] : "").trim();
    const disp=(!v||/original\s*mix/i.test(v))?t:(t+" - "+v);
    const ttok=tokensTitle(disp);
    const vinfo=canonVersion(v+" "+String(cfg.remixCol? r[cfg.remixCol] : "" ));
    const aids=cfg.artistIdCol?extractArtistIds(r[cfg.artistIdCol]):[];
    if(aids.length) hasAid++;
    if(id) idxExact.set("ID:"+id,r);
    if(isrc) idxExact.set("ISRC:"+isrc,r);
    if(disp) idxExact.set("NM:"+norm(disp),r);
    blob.push({r,disp,ttok,vinfo,artistIds:aids});
  }
  log("ğŸ¯ ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆIDä»˜ãè¡Œ: "+hasAid+" / "+sourceRows.length);
  return {idxExact, blob};
}
function parseAnalysisTitle(a,anCfg){
  const name=String(a[anCfg.nameCol]||""); const art=String(anCfg.artistCol? (a[anCfg.artistCol]||"") : "");
  return {disp:name+" "+art, ttok:tokensTitle(name+" "+art), vinfo:canonVersion(name)};
}
function fuzzyBest(sourceBlob,an){
  let best=null, tw=an.vinfo.kinds.length?0.75:0.85, vw=1-tw;
  for(const s of sourceBlob){
    const ts=setJaccard(an.ttok,s.ttok);
    const vk=setJaccard(an.vinfo.kinds,s.vinfo.kinds);
    const vr=setJaccard(an.vinfo.remTok,s.vinfo.remTok);
    const ver=0.6*vk+0.4*vr;
    const sc=tw*ts+vw*ver;
    if(!best || sc>best.sc) best={s:s,sc:sc};
  }
  return best;
}
function autoMatch(srcIdx,anCfg,onTick){
  const idA=anCfg.idCol, isrcA=anCfg.isrcCol;
  let thr=0.86, rows=[], diag=null, total=analyticsRows.length;
  for(;thr>=0.72;thr-=0.02){
    rows=[]; diag={exact:0,fuzzy:0,none:0};
    for(let j=0;j<analyticsRows.length;j++){
      const a=analyticsRows[j]; if(onTick&&((j+1)%20===0||j+1===total)) onTick(j+1,total);
      const id=idA?extractTrackId(a[idA]):"";
      const isc=isrcA?String(a[anCfg.isrcCol]||"").trim().toUpperCase():"";
      const an=parseAnalysisTitle(a,anCfg);
      let pick=null, mode="exact", score=1;
      if(id && srcIdx.idxExact.has("ID:"+id)) pick=srcIdx.idxExact.get("ID:"+id);
      else if(isc && srcIdx.idxExact.has("ISRC:"+isc)) pick=srcIdx.idxExact.get("ISRC:"+isc);
      else if(srcIdx.idxExact.has("NM:"+norm(an.disp))) pick=srcIdx.idxExact.get("NM:"+norm(an.disp));
      if(!pick){
        const b=fuzzyBest(srcIdx.blob,an);
        if(b && b.sc>=thr){ pick=b.s.r; mode="fuzzy"; score=b.sc; }
      }
      if(pick) rows.push({a,s:pick,_mode:mode,_score:score}); else diag.none++;
      if(pick && mode==="exact") diag.exact++; else if(pick) diag.fuzzy++;
    }
    if(rows.length/Math.max(1,total)>=0.5) break;
  }
  return {rows,thr,diag};
}
function computeScores(rows,anCfg){
  const p24=anCfg.p24,p7=anCfg.p7,p28=anCfg.p28,s24=anCfg.s24,s7=anCfg.s7,s28=anCfg.s28;
  let max24=0,max7=0,max28=0; rows.forEach(r=>{max24=Math.max(max24,num(r.a[p24])); max7=Math.max(max7,num(r.a[p7])); max28=Math.max(max28,num(r.a[p28]));});
  rows.forEach(r=>{
    const sr24=num(r.a[s24])/100, sr7=num(r.a[s7])/100, sr28=num(r.a[s28])/100;
    const pl24=max24?num(r.a[p24])/max24:0, pl7=max7?num(r.a[p7])/max7:0, pl28=max28?num(r.a[p28])/max28:0;
    const w=[0.5,0.3,0.2], wp=+($("wPopularity").value||0.55);
    r.score = wp*(w[0]*sr24+w[1]*sr7+w[2]*sr28) + (1-wp)*(w[0]*pl24+w[1]*pl7+w[2]*pl28);
  });
  rows.sort((a,b)=>(b.score||0)-(a.score||0)); return rows;
}
function buildItemFromMatch(m,srcCols,anCols){
  const t=String(srcCols.nameCol? m.s[srcCols.nameCol] : "").trim() || String(m.a[anCols.nameCol]||"").trim();
  const v=String(srcCols.verCol?  m.s[srcCols.verCol]  : "").trim();
  return {
    id: srcCols.idCol?extractTrackId(m.s[srcCols.idCol]):"",
    isrc: srcCols.isrcCol?String(m.s[srcCols.isrcCol]||"").toUpperCase():"",
    name: (!v||/original\s*mix/i.test(v))?t:(t+" - "+v),
    artist: String(srcCols.artistCol? m.s[srcCols.artistCol] : (m.a[anCols.artistCol]||"")),
    remixer: String(srcCols.remixCol? m.s[srcCols.remixCol] : ""),
    artistIds: FORCED_ARTIST_IDS.slice(0),
    flags:{ uk:anCols.uk?!!m.a[anCols.uk]:false, us:anCols.us?!!m.a[anCols.us]:false, eu:anCols.eu?!!m.a[anCols.eu]:false, wo:anCols.wo?!!m.a[anCols.wo]:false },
    score:m.score, _mode:m._mode, _score:m._score, a:m.a, s:m.s
  };
}
function buildItemsFromAnalyticsOnly(anCols){
  const out=[];
  for(const a of analyticsRows){
    const name=String(a[anCols.nameCol]||"").trim(); if(!name) continue;
    out.push({ id:extractTrackId(a[anCols.idCol]), isrc:String(a[anCols.isrcCol]||"").toUpperCase(),
      name, artist:String(a[anCols.artistCol]||"").trim(), remixer:"", artistIds:FORCED_ARTIST_IDS.slice(0),
      flags:{wo:true,uk:false,us:false,eu:false}, score:0.0001, _mode:"fallback", _score:1, a, s:null});
  }
  return out;
}

/* ====== åé›†ï¼ˆTDCSã®ã¿ï¼‰ ====== */
const keyOf=(it)=>{ const title=String(it.name||""); const artist=String(it.artist||""); const v=canonVersion(title); const base=(title.split(/\s+-\s+/)[0]||title); return norm(base+"|"+v.kinds.sort().join("+")+"|"+artist); }
function dedupeByMeta(list){
  const seen={}, seenId={}, seenIsrc={}, out=[]; let dropU=0,dropI=0,dropK=0;
  for(const it of list){
    if(it.id && seenId[it.id]){dropU++;continue;}
    if(it.isrc && seenIsrc[it.isrc]){dropI++;continue;}
    const k=keyOf(it); if(seen[k]){dropK++;continue;}
    out.push(it); if(it.id)seenId[it.id]=1; if(it.isrc)seenIsrc[it.isrc]=1; seen[k]=1;
  }
  log(`ğŸ§¹ é‡è¤‡é™¤å»ï¼ˆå€™è£œï¼‰: å…¥${list.length}â†’æ®‹${out.length} [ID:${dropU},ISRC:${dropI},Key:${dropK}]`);
  return out;
}
async function gatherArtistIds(){ return FORCED_ARTIST_IDS.slice(0); }
async function fetchTopTracksByArtist(aid,market){ const r=await spFetch("/v1/artists/"+aid+"/top-tracks?market="+market,"GET"); return (r&&r.tracks)||[]; }
async function fetchAllArtistAlbums(aid, market){
  let out=[], seen=new Set(), groups="album,single,appears_on,compilation"; let offset=0, limit=50;
  while(true){
    const r=await spFetch(`/v1/artists/${aid}/albums?include_groups=${groups}&limit=${limit}&offset=${offset}&market=${market}`,"GET");
    const arr=(r&&r.items)||[]; for(const al of arr){ if(!seen.has(al.id)){ seen.add(al.id); out.push(al);} }
    if(!arr || arr.length<limit) break; offset+=limit;
  }
  return out;
}
async function fetchAllAlbumTracks(albumId, market){
  let out=[], offset=0, limit=50;
  while(true){
    const r=await spFetch(`/v1/albums/${albumId}/tracks?limit=${limit}&offset=${offset}&market=${market}`,"GET");
    const arr=(r&&r.items)||[]; out=out.concat(arr||[]);
    if(!arr || arr.length<limit) break; offset+=limit;
  }
  return out;
}
const itemFromTrackObj=(t,aid)=>({ id:t.id||"", isrc:"", name:t.name||"", artist:(t.artists&&t.artists[0]&&t.artists[0].name)||"", remixer:"", artistIds:aid?[aid]:[], flags:{wo:true}, score:0.0001, _mode:"seed" });

async function buildExtraFromArtists(artistIds,label){
  const mkts=getMarkets(); let out=[], done=0, total=artistIds.length*mkts.length;
  for(const aid of artistIds){
    for(const m of mkts){
      try{
        log(`â€¦top/new åé›†ä¸­: ${m} (${++done}/${total})`);
        const ts=await fetchTopTracksByArtist(aid,m); (ts||[]).forEach(t=>out.push(itemFromTrackObj(t,aid)));
        const al=await spFetch(`/v1/artists/${aid}/albums?include_groups=single,album&limit=20&market=${m}`,"GET");
        const albums=(al&&al.items)||[]; log(`â€¦ã‚¢ãƒ«ãƒãƒ ${albums.length}ä»¶: ${m}`);
        for(const a of albums.slice(0,6)){ const tr=await fetchAllAlbumTracks(a.id,m); (tr||[]).slice(0,6).forEach(t=>out.push(itemFromTrackObj(t,aid))); }
      }catch(e){ log(`âš ï¸ top/new ${m}: ${(e.message||e).toString().slice(0,120)}`); }
    }
  }
  log(`â• è£œå……(${label}): +${out.length}`); return out;
}
const _artistNameCache=new Map();
async function getArtistName(aid){ if(_artistNameCache.has(aid)) return _artistNameCache.get(aid); const r=await spFetch("/v1/artists/"+aid,"GET"); const n=(r&&r.name)||""; _artistNameCache.set(aid,n); return n; }
async function buildExtraFromSearchArtist(artistIds,label,targetCount,currentCount){
  const fast = $("fastMode") && $("fastMode").checked;
  const base = getMarkets();
  const mkts = fast ? base : Array.from(new Set(base.concat(["DE","FR","IT","PT","IE"])));
  const MAX_PAGES = fast ? 4 : 12;
  let out=[];
  for(const aid of artistIds){
    const name=await getArtistName(aid);
    for(const m of mkts){
      try{
        for(let p=0;p<MAX_PAGES; p++){
          const q = `artist:"${name}"`;
          const r = await spFetch(`/v1/search?q=${encodeURIComponent(q)}&type=track&limit=50&offset=${p*50}&market=${m}`,"GET");
          const items=(r&&r.tracks&&r.tracks.items)||[];
          for(const t of items){ if(t && hasTDCSTrackObj(t)) out.push(itemFromTrackObj(t,aid)); }
          if(currentCount + out.length >= targetCount) break;
          if(!items || items.length<50) break;
        }
      }catch(e){ log(`âš ï¸ search ${m}: ${(e.message||e).toString().slice(0,120)}`); }
      if(currentCount + out.length >= targetCount) break;
    }
    if(currentCount + out.length >= targetCount) break;
  }
  log(`â• è£œå……(search): +${out.length}`); return out;
}
async function buildExtraFromArtistsDeep(artistIds,label,targetCount,currentCount){
  const fast = $("fastMode") && $("fastMode").checked;
  const base = getMarkets();
  const mkts = fast ? base : Array.from(new Set(base.concat(["DE","FR","IT","PT","IE"])));
  const MAX_ALBUMS = fast ? 30 : 120;
  const MAX_TRACKS_PER_ALBUM = fast ? 3 : 10;
  let out=[];
  outer: for(const aid of artistIds){
    for(const m of mkts){
      log(`â€¦discog åé›†ä¸­: ${m} (ç´¯è¨ˆ${out.length})`);
      try{
        const albums = await fetchAllArtistAlbums(aid,m);
        for(let i=0;i<Math.min(MAX_ALBUMS, albums.length); i++){
          const tr = await fetchAllAlbumTracks(albums[i].id,m);
          for(const t of tr.slice(0, MAX_TRACKS_PER_ALBUM)){ if(hasTDCSTrackObj(t)) out.push(itemFromTrackObj(t,aid)); }
          if(currentCount + out.length >= targetCount) break outer;
        }
      }catch(e){ log(`âš ï¸ discog ${m}: ${(e.message||e).toString().slice(0,120)}`); }
    }
  }
  log(`â• è£œå……(${label}): +${out.length}`); return out;
}
async function buildCandidatePool(primaryItems,anCols,finalN){
  let pool = dedupeByMeta(primaryItems);
  const needHard=finalN*4, targetSoft=needHard+80;
  log(`ğŸ“¦ å€™è£œãƒ—ãƒ¼ãƒ«é–‹å§‹: ${pool.length} / ç›®æ¨™ ${targetSoft}`);
  if(pool.length < targetSoft){
    const extraA = buildItemsFromAnalyticsOnly(anCols).sort((a,b)=>(b.score||0)-(a.score||0));
    pool = dedupeByMeta(pool.concat(extraA));
    log(`â• è£œå……(analytics only): ${pool.length}`);
  }
  if(pool.length < targetSoft){
    const artistIds = await gatherArtistIds();
    log("ğŸ§² åé›†ArtistID: "+artistIds.length);
    const extraB = await buildExtraFromArtists(artistIds,"top+new");
    pool = dedupeByMeta(pool.concat(extraB));
    log(`â• è£œå……(top/new): ${pool.length}`);
  }
  if(pool.length < needHard){
    const artistIds = await gatherArtistIds();
    const extraS = await buildExtraFromSearchArtist(artistIds,"search", needHard, pool.length);
    pool = dedupeByMeta(pool.concat(extraS));
    log(`â• è£œå……(search merged): ${pool.length}`);
  }
  if(pool.length < needHard){
    const artistIds = await gatherArtistIds();
    const extraC = await buildExtraFromArtistsDeep(artistIds,"discog", needHard, pool.length);
    pool = dedupeByMeta(pool.concat(extraC));
    log(`â• è£œå……(discog): ${pool.length}`);
  }
  return pool.slice(0, Math.max(targetSoft, needHard));
}

/* ====== URIè§£æ±ºï¼ˆTDCSé™å®šï¼‰ ====== */
const _isrcCache=new Map(); const _nameCache=new Map();
const isrcVariants=(s)=>{ s=String(s||"").trim(); if(!s) return []; const up=s.toUpperCase(); const no=up.replace(/-/g,""); const hy=up.indexOf("-")>=0?up:up.replace(/^(.{2})(.{3})(.{2})(.{5})$/,"$1-$2-$3-$4"); const set={},arr=[]; [up,no,hy].forEach(v=>{if(!set[v]){set[v]=1;arr.push(v);}}); return arr; }
const topArtistName=(a)=>{const s=String(a||""); const m=s.split(/,|;|&| with | feat\.? | featuring | ft\.? /i); return (m[0]||"").trim();}
function makeQueries(it){
  const q=[], full=String(it.name||"").trim(), base=(full.split(/\s+-\s+/)[0]||full), art=topArtistName(it.artist||"");
  if(it.isrc){ for(const v of isrcVariants(it.isrc)) q.push({q:"isrc:"+v,type:"isrc"}); }
  if(art){ q.push({q:`track:"${base}" artist:"${art}"`,type:"field"}); if(full!==base) q.push({q:`track:"${full}" artist:"${art}"`,type:"field"}); }
  q.push({q:`"${base}" ${art||""}`,type:"free"});
  q.push({q:base,type:"free"}); if(full!==base) q.push({q:full,type:"free"});
  return q;
}
async function searchOnce(q,m){ const r=await spFetch(`/v1/search?q=${encodeURIComponent(q)}&type=track&limit=10&market=${m}`,"GET"); return (r&&r.tracks&&r.tracks.items)?r.tracks.items:[]; }
function scoreCandidate(item,cand){
  const ct=cand.name+(cand.version?(" - "+cand.version):"");
  const t1=setJaccard(tokensTitle(item.name),tokensTitle(ct));
  const t2=setJaccard(tokensTitle((item.name.split(/\s+-\s+/)[0]||item.name)),tokensTitle(ct));
  const title=Math.max(t1,t2);
  const vi=canonVersion(item.name), vc=canonVersion(ct);
  const ver=0.6*setJaccard(vi.kinds,vc.kinds)+0.4*setJaccard(vi.remTok,vc.remTok);
  return 0.80*title+0.20*ver;
}
async function resolveUriOneStrict(it){
  if(it.id && it.id.length===22) return "spotify:track:"+it.id;
  if(it.isrc){ for(const v of isrcVariants(it.isrc)){ if(_isrcCache.has(v)) return _isrcCache.get(v); } }
  const full=String(it.name||"").trim();
  const baseTitle=(full.split(/\s+-\s+/)[0]||full);
  const art=topArtistName(it.artist||"");
  const keyNM=(baseTitle+"|"+art).toLowerCase();
  if(_nameCache.has(keyNM)) return _nameCache.get(keyNM);

  const fast = $("fastMode") && $("fastMode").checked;
  const base = getMarkets(); 
  const mkts = fast ? base : Array.from(new Set(base.concat(["DE","FR","IT","PT","IE"])));
  const qs   = makeQueries(it);
  const MAX_QUERIES = fast ? 6 : 10;

  let best=null;
  outer:
  for(const q of qs.slice(0,MAX_QUERIES)){
    for(const m of mkts){
      let items=[]; try{ items=await searchOnce(q.q,m) }catch(_){}
      for(const t of items){
        if(!hasTDCSTrackObj(t)) continue; // TDCSä»¥å¤–ã¯å€™è£œã«ã—ãªã„
        const sc = scoreCandidate(it,t) + 0.18; // TDCSãƒœãƒ¼ãƒŠã‚¹
        if(!best || sc>best.sc) best={sc,cand:t};
        if(sc>=0.88) break outer;
      }
    }
  }
  if(best && best.cand && best.cand.id){
    const uri="spotify:track:"+best.cand.id;
    if(it.isrc) for(const v of isrcVariants(it.isrc)) _isrcCache.set(v,uri);
    _nameCache.set(keyNM,uri);
    return uri;
  }
  return "";
}
async function toUrisResolved(items,onTick){
  const aligned=new Array(items.length); let ok=0, total=items.length;
  for(let i=0;i<items.length;i++){
    const u=await resolveUriOneStrict(items[i]); if(u){aligned[i]=u; ok++;}
    if(onTick && (((i+1)%25)===0 || i+1===total)) onTick(i+1,total,ok);
  }
  log("ğŸ”— URIè§£æ±º: "+ok+"/"+total);
  return {aligned};
}

/* ====== è©³ç´°ãƒ»éŒ²éŸ³ãƒ¦ãƒ‹ãƒ¼ã‚¯ ====== */
async function fetchTrackDetailsByUris(uris){
  const ids=[], map=new Map();
  for(const u of uris){ if(u) ids.push(u.replace("spotify:track:","")); }
  for(let i=0;i<ids.length;i+=50){
    const slice=ids.slice(i,i+50); if(!slice.length) continue;
    const r=await spFetch("/v1/tracks?ids="+slice.join(","),"GET");
    const arr=(r&&r.tracks)||[]; for(const t of arr){ if(t&&t.id) map.set("spotify:track:"+t.id,t); }
  }
  return map;
}
const baseTitle=(s)=>{s=String(s||""); const m=s.split(/\s+-\s+/); return (m[0]||"").trim();}
function dedupeByRecording(items,alignedUris,tracksMap,strictMarket){
  const seenUri={}, seenIsrc={}, seenBase={}, outItems=[], outUris=[];
  let dropU=0,dropI=0,dropB=0, dropNotTDCS=0, dropNoMarket=0;
  const mkts = getMarkets();
  for(let i=0;i<alignedUris.length;i++){
    const u=alignedUris[i]; if(!u) continue;
    const tr=tracksMap.get(u);
    const okTDCS = hasTDCSTrackObj(tr);
    if(!okTDCS){ dropNotTDCS++; continue; }
    let okMarket=true;
    if(tr && Array.isArray(tr.available_markets) && mkts.length){
      okMarket = mkts.some(m=>tr.available_markets.includes(m));
    }
    if(strictMarket && !okMarket){ dropNoMarket++; continue; }
    if(seenUri[u]){dropU++; continue;}
    const isrc=(tr&&tr.external_ids&&tr.external_ids.isrc)?String(tr.external_ids.isrc).toUpperCase():"";
    if(isrc && seenIsrc[isrc]){dropI++; continue;}
    const base = tr ? (norm(baseTitle(tr.name))+"ï½œ"+((tr.artists&&tr.artists[0]&&tr.artists[0].id)||""))
                    : (norm(baseTitle(items[i]&&items[i].name))+"ï½œ"+(items[i]&&items[i].artist||""));
    if(seenBase[base]){dropB++; continue;}
    seenUri[u]=1; if(isrc) seenIsrc[isrc]=1; seenBase[base]=1;
    outItems.push(items[i]); outUris.push(u);
  }
  log(`ğŸ§½ ãƒ¬ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é‡è¤‡é™¤å»: -URI:${dropU} -ISRC:${dropI} -Base:${dropB} -éTDCS:${dropNotTDCS} -ä¸å¯åœ°åŸŸ:${dropNoMarket}`);
  return {items:outItems, uris:outUris};
}

/* ====== ç‰¹å¾´é‡ãƒ»é †åº ====== */
async function fetchAudioFeaturesByUris(uris){
  const ids=[], feats=new Map(); for(const u of uris){ if(u) ids.push(u.replace("spotify:track:","")); }
  for(let i=0;i<ids.length;i+=100){
    const slice=ids.slice(i,i+100); if(!slice.length) continue;
    const r=await spFetch("/v1/audio-features?ids="+slice.join(","),"GET");
    const arr=(r&&r.audio_features)||[]; for(const f of arr){ if(f&&f.id) feats.set("spotify:track:"+f.id,f); }
  }
  return feats;
}
const camelot=(key,mode)=>({num:[8,3,10,5,0,7,2,9,4,11,6,1][(key||0)%12],isMinor:mode===0});
const keyDistance=(a,b)=>{ if(!a||!b||a.key==null||b.key==null) return 2; const A=camelot(a.key,a.mode), B=camelot(b.key,b.mode); let d=Math.abs(A.num-B.num); d=Math.min(d,12-d); let pen=d/6; if(A.isMinor!==B.isMinor) pen+=0.4; return pen; }
function nextCost(a,b,preset){
  const dTempo=(a&&b&&a.tempo&&b.tempo)?Math.min(1,Math.abs(a.tempo-b.tempo)/16):0.5;
  const dKey=keyDistance(a,b); const dEner=(a&&b)?Math.abs((a.energy||0)-(b.energy||0)):0.5;
  const dVal=(a&&b)?Math.abs((a.valence||0)-(b.valence||0)):0.5;
  if(preset==="dj")   return 0.45*dTempo+0.35*dKey+0.15*dEner+0.05*dVal;
  if(preset==="rise") return 0.35*dTempo+0.20*dKey+0.35*dEner+0.10*dVal;
  if(preset==="drop") return 0.35*dTempo+0.20*dKey+0.35*dEner+0.10*dVal;
  return               0.40*dTempo+0.25*dKey+0.25*dEner+0.10*dVal;
}
function orderFlow(items,featMap,preset,gapA,gapR,seed){
  function lcg(s){let x=0;for(let i=0;i<s.length;i++)x=(x*131+s.charCodeAt(i))>>>0; return ()=>{x=(1103515245*x+12345)>>>0; return (x/0xFFFFFFFF);} }
  const rnd=lcg(seed||"ed");
  let pool=items.slice(0).sort((a,b)=>(b.score||0)-(a.score||0));
  const skip=Math.min(3,Math.floor(rnd()*5)); if(pool.length>skip) pool=pool.slice(skip).concat(pool.slice(0,skip));
  if(pool.length===0) return [];
  const seq=[pool.shift()]; const lastSeen={remixer:{},artist:{}};
  const mark=(it,i)=>{ lastSeen.remixer[String(it.remixer||"").toLowerCase()]=i; lastSeen.artist[String(it.artist||"").toLowerCase()]=i; }
  mark(seq[0],0);
  while(pool.length){
    const prev=seq[seq.length-1]; let bestIdx=0, best=1e9;
    for(let i=0;i<Math.min(50,pool.length);i++){
      const cand=pool[i], fa=featMap.get(cand.uri)||{}, fb=featMap.get(prev.uri)||{};
      let cost=nextCost(fb,fa,preset);
      const rm=String(cand.remixer||"").toLowerCase(), ar=String(cand.artist||"").toLowerCase();
      const iR=(lastSeen.remixer[rm]!=null?lastSeen.remixer[rm]:-999), iA=(lastSeen.artist[ar]!=null?lastSeen.artist[ar]:-999);
      const idx=seq.length;
      if(idx-iR < (gapR||3)) cost+=0.8;
      if(idx-iA < (gapA||4)) cost+=0.6;
      cost*=1+(i*0.002);
      if(cost<best){best=cost; bestIdx=i;}
    }
    const pick=pool.splice(bestIdx,1)[0]; seq.push(pick); mark(pick,seq.length-1);
  }
  return seq;
}

/* ====== åˆ†é…ï¼ˆç›¸äº’éé‡è¤‡ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ ====== */
const edCfg=()=>[
  {name:"UK",    pref:"uk", fallback:["wo","us","eu"], preset:($("presetUK").value||"waves"), gapA:+($("gapArtist").value||4), gapR:+($("gapRemixer").value||3), seed:"UK"},
  {name:"US",    pref:"us", fallback:["wo","uk","eu"], preset:($("presetUS").value||"rise"),  gapA:+($("gapArtist").value||4), gapR:+($("gapRemixer").value||3), seed:"US"},
  {name:"EU",    pref:"eu", fallback:["wo","uk","us"], preset:($("presetEU").value||"waves"), gapA:+($("gapArtist").value||4), gapR:+($("gapRemixer").value||3), seed:"EU"},
  {name:"WORLD", pref:"wo", fallback:["uk","us","eu"], preset:"dj",                             gapA:+($("gapArtist").value||4), gapR:+($("gapRemixer").value||3), seed:"WORLD"}
];
function edScoreBias(item,feat,edName){
  const base=item.score||0, e=(feat&&feat.energy)||0, v=(feat&&feat.valence)||0;
  if(edName==="US")   return base + 0.10*e + 0.03*v;
  if(edName==="UK")   return base + 0.06*e + 0.05*v;
  if(edName==="EU")   return base + 0.02*e + 0.08*(1-Math.abs(v-0.5));
  if(edName==="WORLD")return base + 0.05*(1-Math.abs(e-0.6));
  return base;
}
function buildEditionSetsRoundRobin(candidates, feats, finalN){
  const allowCrossDupes = $("allowCrossDupes").checked;
  const usedGlobal=new Set(), packs={UK:[],US:[],EU:[],WORLD:[]};
  const cfgs=edCfg();
  const poolFor=(ed)=>{
    const pref=candidates.filter(x=> (allowCrossDupes || !usedGlobal.has(x.uri)) && x.flags && x.flags[ed.pref]);
    const fb=candidates.filter(x=> (allowCrossDupes || !usedGlobal.has(x.uri)) && x.flags && ed.fallback.some(k=>x.flags[k]));
    const rest=candidates.filter(x=> (allowCrossDupes || !usedGlobal.has(x.uri)) && (!x.flags || (!x.flags.uk&&!x.flags.us&&!x.flags.eu&&!x.flags.wo)));
    const pool=pref.concat(fb).concat(rest);
    pool.sort((a,b)=> (edScoreBias(b,feats.get(b.uri)||{},ed.name))-(edScoreBias(a,feats.get(a.uri)||{},ed.name)));
    return pool;
  }
  const queues={}; cfgs.forEach(ed=>queues[ed.name]=poolFor(ed));
  const filled={UK:0,US:0,EU:0,WORLD:0}; let done=0, guard=0;
  while(done<4 && guard<20000){
    guard++;
    for(const ed of cfgs){
      if(filled[ed.name] >= finalN) continue;
      let q=queues[ed.name], pick=null;
      for(let i=0;i<q.length;i++){ const x=q[i]; if(allowCrossDupes || !usedGlobal.has(x.uri)){ pick=q.splice(i,1)[0]; break; } }
      if(!pick){ queues[ed.name]=poolFor(ed); q=queues[ed.name];
        for(let i=0;i<q.length;i++){ const x=q[i]; if(allowCrossDupes || !usedGlobal.has(x.uri)){ pick=q.splice(i,1)[0]; break; } }
      }
      if(pick){ packs[ed.name].push(pick); if(!allowCrossDupes) usedGlobal.add(pick.uri); filled[ed.name]++; }
    }
    done = (filled.UK>=finalN) + (filled.US>=finalN) + (filled.EU>=finalN) + (filled.WORLD>=finalN);
    if(Object.values(filled).reduce((a,b)=>a+b,0) >= finalN*4) break;
    if(queues.UK.length+queues.US.length+queues.EU.length+queues.WORLD.length===0) break;
  }
  log("âš–ï¸ åˆ†é…(åˆæœŸ): UK="+packs.UK.length+", US="+packs.US.length+", EU="+packs.EU.length+", WORLD="+packs.WORLD.length);
  return packs;
}

/* ====== ä¸è¶³ç©´åŸ‹ã‚ï¼ˆç‰ˆå†…ãƒªãƒ”ãƒ¼ãƒˆå¯ï¼‰ ====== */
function topUpWithRepeats(packs, candidates, feats, finalN){
  const allowRepeatFill = $("allowRepeatFill").checked;
  if(!allowRepeatFill) return packs;

  const eds=["UK","US","EU","WORLD"];
  for(const ed of eds){
    const need = finalN - packs[ed].length;
    if(need<=0) continue;

    // è£œå……ãƒ—ãƒ¼ãƒ«ï¼šã¾ãšãã®ç‰ˆã«å…¥ã£ãŸæ›²ã€æ¬¡ã«å…¨å€™è£œï¼ˆé †åºãƒã‚¤ã‚¢ã‚¹é©ç”¨ï¼‰
    const biasSort=(arr)=>arr.slice(0).sort((a,b)=>
      (edScoreBias(b,feats.get(b.uri)||{},ed))-(edScoreBias(a,feats.get(a.uri)||{},ed)));
    const seeds = packs[ed].length ? biasSort(packs[ed]) : biasSort(candidates.filter(x=>!!x.uri));

    if(seeds.length===0){ log(`âš ï¸ ${ed}: ã‚·ãƒ¼ãƒ‰0 â†’ è£œå……ä¸èƒ½`); continue; }

    // ç›´å‰åŒä¸€URIå›é¿ã—ã¤ã¤å›è»¢
    let k=0;
    while(packs[ed].length < finalN){
      const cand = seeds[k % seeds.length];
      const last = packs[ed][packs[ed].length-1];
      if(!last || last.uri !== cand.uri){
        packs[ed].push(cand);
      }else{
        // ç›´å‰ã¨åŒä¸€ãªã‚‰æ¬¡å€™è£œ
        k++;
        continue;
      }
      k++;
      if(k>100000){ log(`âš ï¸ ${ed}: è£œå……ãƒ«ãƒ¼ãƒ—ã‚¬ãƒ¼ãƒ‰`); break; }
    }
    log(`â• è£œå¡«(ãƒªãƒ”ãƒ¼ãƒˆ): ${ed} â†’ ${packs[ed].length}/${finalN}`);
  }
  return packs;
}

/* ====== æ›¸ãè¾¼ã¿ & ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ ====== */
const extractPlaylistId=(s)=>{s=String(s||""); let m=s.match(/playlist\/([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/^([A-Za-z0-9]{22})$/); if(m) return m[1]; return ""; }
async function replacePlaylist(pid,uris){
  const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
  if(!chunks.length) chunks.push([]);
  await spFetch("/v1/playlists/"+pid+"/tracks","PUT",{uris:chunks[0]}); log("ğŸ§¹ ç½®æ›: "+chunks[0].length+"ä»¶");
  for(let k=1;k<chunks.length;k++){ await spFetch(`/v1/playlists/${pid}/tracks`,"POST",{uris:chunks[k]}); log("â• è¿½åŠ : "+chunks[k].length+"ä»¶"); }
}
async function createPlaylistAndFill(name,desc,isPublic,uris){
  const me=await getMe();
  const pl=await spFetch("/v1/users/"+encodeURIComponent(me.id)+"/playlists","POST",{name,description:desc,public:true});
  const pid=(pl&&pl.id)?pl.id:""; await replacePlaylist(pid,uris); return pid;
}
let _exportData=null; const enableExportButtons=(on)=>{ $("btnExportXlsx").disabled=!on; $("btnExportCsv").disabled=!on; }
function exportXlsx(){
  if(!_exportData){log("â„¹ï¸ ãƒ‡ãƒ¼ã‚¿ãªã—");return;}
  const wb=XLSX.utils.book_new();
  const add=(name,key)=>{ const ws=XLSX.utils.json_to_sheet(_exportData[key],{header:["position","edition","title","artist","remixer","isrc","source_id","source_sheet","match_mode","match_score","spotify_uri","score","tempo","energy","valence","key","mode"]}); XLSX.utils.book_append_sheet(wb,ws,name); }
  add("UK","uk"); add("US","us"); add("EU","eu"); add("WORLD","wo");
  XLSX.writeFile(wb,"editions_"+new Date().toISOString().slice(0,10)+".xlsx");
}
function exportCsv(){
  if(!_exportData){log("â„¹ï¸ ãƒ‡ãƒ¼ã‚¿ãªã—");return;}
  const all=[].concat(_exportData.uk,_exportData.us,_exportData.eu,_exportData.wo);
  const H=["position","edition","title","artist","remixer","isrc","source_id","source_sheet","match_mode","match_score","spotify_uri","score","tempo","energy","valence","key","mode"];
  const esc=(v)=>'"'+String(v==null?"":v).replace(/"/g,'""')+'"';
  const rows=[H.join(",")]; for(const r of all){ rows.push(H.map(h=>esc(r[h])).join(",")); }
  const blob=new Blob([rows.join("\r\n")],{type:"text/csv;charset=utf-8"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="editions_"+new Date().toISOString().slice(0,10)+".csv"; document.body.appendChild(a); a.click(); a.remove();
}

/* ====== ãƒ¡ã‚¤ãƒ³ ====== */
let _pending=null;
async function runAnalysis(){
  try{
    progress(10,"åˆ—æ¤œå‡ºâ€¦");
    const srcCols=sourceRows.length?pickSourceColumns(sourceRows):{idCol:"",isrcCol:"",artistIdCol:"",nameCol:"",verCol:"",artistCol:"",remixCol:""};
    const srcIdx=buildSourceIndex(srcCols);
    const anCols=pickAnalyticColumns(analyticsRows);

    progress(28,"çªåˆï¼ˆExactâ†’Fuzzyï¼‰â€¦");
    const match=autoMatch(srcIdx,anCols,(i,t)=>subProgress(i,t,28,50,"çªåˆä¸­"));
    log(`ğŸ” è¨ºæ–­: exact=${match.diag.exact}, fuzzy=${match.diag.fuzzy}, æœªä¸€è‡´=${match.diag.none}, æ¡ç”¨=${match.rows.length}/${analyticsRows.length}, ã—ãã„å€¤=${match.thr.toFixed(2)}`);

    progress(51,"å€™è£œæ•´å½¢â†’ã‚¹ã‚³ã‚¢â€¦");
    let items=[];
    if(match.rows.length){
      const scored=computeScores(match.rows,anCols);
      items=scored.map(m=>buildItemFromMatch(m,srcCols,anCols));
    }else{
      items=buildItemsFromAnalyticsOnly(anCols).sort((a,b)=>(b.score||0)-(a.score||0));
    }

    progress(56,"å€™è£œãƒ—ãƒ¼ãƒ«æ‹¡å¼µï¼ˆTDCSã®ã¿ï¼‰â€¦");
    const finalN=+($("finalN").value||130);
    const pool=await buildCandidatePool(items,anCols,finalN);

    progress(64,"URIè§£æ±ºï¼ˆTDCSé™å®šãƒ»å›æ•°åˆ¶é™ï¼‰â€¦");
    const res=await toUrisResolved(pool,(i,t,ok)=>progress(64+(8*(i/t)),"URIè§£æ±º ("+i+"/"+t+")"));

    progress(72,"æ›²è©³ç´°â†’éŒ²éŸ³ãƒ¦ãƒ‹ãƒ¼ã‚¯ï¼ˆå¸‚å ´ã‚†ã‚‹ã‚ï¼‰â€¦");
    const trackMap=await fetchTrackDetailsByUris(res.aligned.filter(Boolean));
    const usable=pool.map((it,idx)=>Object.assign({},it,{uri:res.aligned[idx]})).filter(x=>x.uri);
    let dedRec=dedupeByRecording(usable, usable.map(x=>x.uri), trackMap, /*strictMarket*/ false);

    // å¿…è¦æ•°ã¾ã§è‡ªå‹•è¿½åŠ 
    const needTotal = finalN*4;
    if (dedRec.uris.length < needTotal) {
      log(`ğŸ” è¿½åŠ è£œå……: ${needTotal}ã¾ã§ã‚ã¨ ${needTotal - dedRec.uris.length} æ›² â€” searchâ†’discog ã®é †`);
      const artistIds = await gatherArtistIds();

      progress(73,"è¿½åŠ : search");
      const extraS = await buildExtraFromSearchArtist(artistIds, "search+", needTotal, dedRec.uris.length);
      const extraPool1 = dedupeByMeta(extraS);
      const res1 = await toUrisResolved(extraPool1, (i,t)=>progress(73+(2*(i/t)),"è¿½åŠ : search URIè§£æ±º ("+i+"/"+t+")"));
      const map1 = await fetchTrackDetailsByUris(res1.aligned.filter(Boolean));
      const usable1 = extraPool1.map((it,i)=>Object.assign({},it,{uri:res1.aligned[i]})).filter(x=>x.uri);
      let merged = dedupeByRecording({items:dedRec.items.concat(usable1), uris:dedRec.uris.concat(usable1.map(x=>x.uri))}.items, {items:dedRec.items.concat(usable1), uris:dedRec.uris.concat(usable1.map(x=>x.uri))}.uris, map1, /*strictMarket*/ false);

      if (merged.uris.length < needTotal) {
        progress(74,"è¿½åŠ : discog");
        const extraD = await buildExtraFromArtistsDeep(artistIds, "discog+", needTotal, merged.uris.length);
        const extraPool2 = dedupeByMeta(extraD);
        const res2 = await toUrisResolved(extraPool2, (i,t)=>progress(74+(2*(i/t)),"è¿½åŠ : discog URIè§£æ±º ("+i+"/"+t+")"));
        const mapAll = await fetchTrackDetailsByUris(res2.aligned.filter(Boolean));
        const usable2 = extraPool2.map((it,i)=>Object.assign({},it,{uri:res2.aligned[i]})).filter(x=>x.uri);
        const joined2 = { items: merged.items.concat(usable2), uris: merged.uris.concat(usable2.map(x=>x.uri)) };
        dedRec = dedupeByRecording(joined2.items, joined2.uris, mapAll, /*strictMarket*/ false);
      } else {
        dedRec = merged;
      }
      log(`ğŸ“ˆ è¿½åŠ å¾Œãƒ¦ãƒ‹ãƒ¼ã‚¯: ${dedRec.uris.length} æ›²`);
    }

    // ååˆ†é›†ã¾ã£ã¦ã„ã‚Œã°æœ€çµ‚æ®µã§å¸‚å ´å³å¯†åŒ–
    const strictTry = dedupeByRecording(dedRec.items, dedRec.uris, trackMap, /*strictMarket*/ true);
    if (strictTry.uris.length >= needTotal) {
      dedRec = strictTry;
      log(`ğŸŒ å¸‚å ´ä¸€è‡´å¾Œãƒ¦ãƒ‹ãƒ¼ã‚¯: ${dedRec.uris.length} æ›²ï¼ˆstricté©ç”¨ï¼‰`);
    } else {
      log(`ğŸŒ å¸‚å ´ä¸€è‡´ã¯ä¿ç•™: ã¾ãšã¯æ›²æ•°å„ªå…ˆï¼ˆ${strictTry.uris.length}/${needTotal}ï¼‰`);
    }

    progress(78,"Audio Features å–å¾—â€¦");
    let feats; try{ feats=await fetchAudioFeaturesByUris(dedRec.uris); }catch(e){ log("âš ï¸ audio-features å–å¾—ã‚¹ã‚­ãƒƒãƒ—: "+(e.message||e)); feats=new Map(); }

    progress(84,"ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³åˆ†é…ï¼ˆåˆæœŸï¼‰â€¦");
    let packs=buildEditionSetsRoundRobin(dedRec.items.map((it,i)=>Object.assign({},it,{uri:dedRec.uris[i]})), feats, finalN);

    // ä¸è¶³ã¯å¿…ãšåŸ‹ã‚ã‚‹ï¼ˆç‰ˆå†…ãƒªãƒ”ãƒ¼ãƒˆå¯ï¼‰
    packs = topUpWithRepeats(packs, dedRec.items.map((it,i)=>Object.assign({},it,{uri:dedRec.uris[i]})), feats, finalN);

    progress(88,"æ›²é †æœ€é©åŒ–â€¦");
    const seqUK=orderFlow(packs.UK,feats,($("presetUK").value||"waves"),+($("gapArtist").value||4),+($("gapRemixer").value||3),"UK|"+new Date().toISOString().slice(0,10));
    const seqUS=orderFlow(packs.US,feats,($("presetUS").value||"rise"), +($("gapArtist").value||4),+($("gapRemixer").value||3),"US|"+new Date().toISOString().slice(0,10));
    const seqEU=orderFlow(packs.EU,feats,($("presetEU").value||"waves"),+($("gapArtist").value||4),+($("gapRemixer").value||3),"EU|"+new Date().toISOString().slice(0,10));
    const seqWO=orderFlow(packs.WORLD,feats,"dj",+($("gapArtist").value||4),+($("gapRemixer").value||3),"WORLD|"+new Date().toISOString().slice(0,10));

    function pack(items,edName){
      const out=[]; for(let i=0;i<items.length;i++){ const it=items[i], f=feats.get(it.uri)||{};
        out.push({position:i+1,edition:edName,title:it.name||"",artist:it.artist||"",remixer:it.remixer||"",isrc:it.isrc||"",source_id:it.id||"",source_sheet:(it.a&&it.a.__sheet)||"",match_mode:it._mode||"",match_score:round4(it._score||1),spotify_uri:it.uri,score:round4(it.score),tempo:round4(f.tempo),energy:round4(f.energy),valence:round4(f.valence),key:(f.key==null?"":f.key),mode:(f.mode==null?"":f.mode)});
      } return out;
    }
    _exportData={uk:pack(seqUK,"UK"),us:pack(seqUS,"US"),eu:pack(seqEU,"EU"),wo:pack(seqWO,"WORLD")};
    enableExportButtons(true);

    if(isAuthed()) await resolveAndWrite({UK:seqUK,US:seqUS,EU:seqEU,WORLD:seqWO});
    else { _pending={UK:seqUK,US:seqUS,EU:seqEU,WORLD:seqWO}; log("ğŸ”‘ æ¥ç¶šå¾…ã¡ï¼šã€Spotifyã«ã‚µã‚¤ãƒ³ã‚¤ãƒ³ã€â†’ã€æ¥ç¶šãƒã‚§ãƒƒã‚¯ã€"); }
  }catch(e){
    log("âš ï¸ runAnalysis ç¶šè¡Œå¯èƒ½ã‚¨ãƒ©ãƒ¼: "+(e.message||e));
    try{ if(_pending) await resolveAndWrite(_pending) }catch(_){}
    progress(100,"å®Œäº†(ä¸€éƒ¨ã‚¹ã‚­ãƒƒãƒ—)");
  }
}

async function resolveAndWrite(packs){
  try{
    if(!packs) packs=_pending; if(!packs){log("â„¹ï¸ ç¶šè¡Œãƒ‡ãƒ¼ã‚¿ãªã—");return;}
    const toUris=(list)=>list.map(x=>x.uri);

    // ç›¸äº’é‡è¤‡ã®è¨ˆæ¸¬ï¼ˆè¨±å®¹æ™‚ã¯æƒ…å ±ã®ã¿ï¼‰
    const allowCrossDupes = $("allowCrossDupes").checked;
    const all=[].concat(packs.UK,packs.US,packs.EU,packs.WORLD), uniq=new Set(); let dup=0;
    for(const x of all){ if(uniq.has(x.uri)) dup++; else uniq.add(x.uri); }
    log(`ğŸ”’ ç›¸äº’é‡è¤‡: ${dup} ä»¶ï¼ˆ${allowCrossDupes?"è¨±å®¹":"0ãŒæ­£å¸¸"}ï¼‰`);

    const pidUK=extractPlaylistId($("plUK").value), pidUS=extractPlaylistId($("plUS").value), pidEU=extractPlaylistId($("plEU").value), pidWO=extractPlaylistId($("plWORLD").value);

    if($("doUpdate").checked){
      progress(90,"ä¸Šæ›¸ã: UKâ€¦"); await replacePlaylist(pidUK,toUris(packs.UK));
      progress(93,"ä¸Šæ›¸ã: USâ€¦"); await replacePlaylist(pidUS,toUris(packs.US));
      progress(95,"ä¸Šæ›¸ã: EUâ€¦"); await replacePlaylist(pidEU,toUris(packs.EU));
      progress(97,"ä¸Šæ›¸ã: WORLDâ€¦"); await replacePlaylist(pidWO,toUris(packs.WORLD));
      log("âœ… æ—¢å­˜4ãƒªã‚¹ãƒˆ ä¸Šæ›¸ãå®Œäº†");
    }
    if($("doCreate").checked){
      progress(98,"æ–°è¦ä½œæˆâ€¦");
      const pre=($("newPrefix").value||"TDCS Editions").trim();
      const ds=$("appendDate").checked?(" "+new Date().toISOString().slice(0,10)):"";
      const pU=await createPlaylistAndFill(pre+" â€” UK"+ds,"Auto-created by TDCS Editions Builder",true,toUris(packs.UK));
      const pS=await createPlaylistAndFill(pre+" â€” US"+ds,"Auto-created by TDCS Editions Builder",true,toUris(packs.US));
      const pE=await createPlaylistAndFill(pre+" â€” EU"+ds,"Auto-created by TDCS Editions Builder",true,toUris(packs.EU));
      const pW=await createPlaylistAndFill(pre+" â€” WORLD"+ds,"Auto-created by TDCS Editions Builder",true,toUris(packs.WORLD));
      log("ğŸ†• æ–°è¦:\n  UK   â†’ https://open.spotify.com/playlist/"+pU+"\n  US   â†’ https://open.spotify.com/playlist/"+pS+"\n  EU   â†’ https://open.spotify.com/playlist/"+pE+"\n  WORLDâ†’ https://open.spotify.com/playlist/"+pW);
    }

    progress(100,"å®Œäº†"); log("âœ… å®Œäº†ï¼ˆTDCSé™å®šï¼è¢«ã‚ŠOKæº€æ•°åŒ–ï¼AU-NZ-US-GB-ES-NLå„ªå…ˆï¼4Ã—130ï¼‰");
    _pending=null;
  }catch(e){ progress(100,"ã‚¨ãƒ©ãƒ¼"); log("ğŸ’¥ ERROR(resolveAndWrite): "+e.message); console.error(e); }
}

/* ====== ã‚¤ãƒ™ãƒ³ãƒˆ ====== */
$("btnConnect").onclick=startAuth;
$("btnReset").onclick=()=>{ for(const k in LS) localStorage.removeItem(LS[k]); setStatus(); log("ğŸ§½ ãƒ­ãƒ¼ã‚«ãƒ«ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤"); };
$("btnCheck").onclick=async()=>{ try{ await refreshTokenIfNeeded(); const me=await spFetch("/v1/me","GET"); $("status").textContent="æ¥ç¶šä¸­ï¼ˆ"+(me.display_name||me.id)+")"; log("âœ… APIç¢ºèª OK"); if(_pending) await resolveAndWrite(_pending); }catch(e){ log("âš ï¸ æ¥ç¶šã‚¨ãƒ©ãƒ¼: "+e.message); } };
$("fileSource").addEventListener("change",()=>{ if($("fileAnalytics").files.length) loadFiles(); });
$("fileAnalytics").addEventListener("change",()=>{ if($("fileAnalytics").files.length) loadFiles(); });
$("btnExportXlsx").onclick=exportXlsx; $("btnExportCsv").onclick=exportCsv;
setStatus();
log("Ready. èª­è¾¼â†’çªåˆâ†’TDCSè£œå……(analytics/top/new/search/discog)â†’AU/NZ/US/GB/ES/NLå„ªå…ˆURIè§£æ±ºâ†’éŒ²éŸ³ãƒ¦ãƒ‹ãƒ¼ã‚¯(å¸‚å ´ã¯æœ€å¾Œã«å³å¯†)â†’åˆ†é…â†’ä¸è¶³ã¯ç‰ˆå†…ãƒªãƒ”ãƒ¼ãƒˆã§æº€æ•°â†’æ›²é †â†’ä¸Šæ›¸ã/æ–°è¦â†’CSV/XLSXã€‚");
</script>
</body></html>
