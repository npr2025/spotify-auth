<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Editions Builder â€“ Simple Modeï¼ˆBreaks 2010+ / Remix Onlyï¼‰</title>

<meta name="robots" content="noindex,nofollow">
<meta name="referrer" content="no-referrer">
<meta http-equiv="Content-Security-Policy"
  content="default-src 'self';
           connect-src 'self' https://accounts.spotify.com https://api.spotify.com;
           img-src 'self' data:;
           style-src 'self' 'unsafe-inline';
           script-src 'self' 'unsafe-inline';
           frame-ancestors 'none';
           base-uri 'self';
           form-action 'self' https://accounts.spotify.com;">

<style>
  :root{--w:980px}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    -webkit-text-size-adjust:100%;
    -webkit-tap-highlight-color:transparent;
    max-width:var(--w); margin:28px auto; padding:0 14px 72px; /* 72px = ãƒ‰ãƒƒã‚¯åˆ† */
    background:#fff;
  }
  h1{margin:0 0 10px}
  .muted{color:#667085}
  .note{font-size:12px;color:#667085}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
  .row>*{flex:1 1 220px}
  input,select{
    width:100%;padding:12px 12px;border:1px solid #D0D5DD;border-radius:10px;font-size:16px;
  }
  button,a.btn{
    display:inline-block;padding:12px 14px;border:1px solid #D0D5DD;border-radius:10px;background:#F9FAFB;
    cursor:pointer;text-decoration:none;min-height:44px
  }
  button:disabled{opacity:.55;cursor:not-allowed}
  fieldset{border:1px solid #E4E7EC;border-radius:12px;padding:12px;margin:12px 0}
  legend{padding:0 6px}
  .pill{display:inline-block;font-size:12px;border:1px solid #E4E7EC;border-radius:999px;padding:2px 8px;margin-left:8px}
  .hud{border:1px solid #E4E7EC;border-radius:12px;padding:12px;margin:10px 0}
  .kv{display:grid;grid-template-columns:120px 1fr;gap:6px 10px}
  progress{width:100%;height:16px}
  details>summary{cursor:pointer;padding:8px 0;font-weight:600}
  #log{
    white-space:pre-wrap;background:#0b1220;color:#cfe3ff;border-radius:10px;padding:12px;max-height:420px;overflow:auto;
  }
  .dock{
    position:fixed;left:0;right:0;bottom:0;z-index:10;
    background:#fff;border-top:1px solid #E4E7EC;
    padding:8px 10px calc(8px + env(safe-area-inset-bottom));
    display:flex;gap:8px;justify-content:space-between
  }
  .dock button{flex:1 1 auto}
  @media (max-width:720px){
    body{margin:16px auto;padding:0 10px 86px}
    .row>*{flex:1 1 100%}
    .kv{grid-template-columns:1fr}
    .kv>div:nth-child(odd){color:#667085}
    fieldset legend{font-size:14px}
    h1{font-size:20px}
    .sticky-actions{display:none}
  }
</style>

<!-- Excelèª­ã¿è¾¼ã¿ãŒå¿…è¦ãªã‚‰ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã«ç½®ã„ã¦æœ‰åŠ¹åŒ– -->
<script src="./xlsx.full.min.js"></script>
</head>
<body>
<h1>Editions Builder â€“ Simple Mode<span class="pill">Breaksé™å®šãƒ»2010+ãƒ»Remixã®ã¿</span></h1>
<p class="note">é€šä¿¡å…ˆã¯ <code>accounts.spotify.com</code> / <code>api.spotify.com</code> ã®å…¬å¼APIã®ã¿ã€‚ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯æ‰±ã„ã¾ã›ã‚“ã€‚</p>

<!-- HUD -->
<div class="hud">
  <div class="kv">
    <div>æ¥ç¶šãƒ¦ãƒ¼ã‚¶ãƒ¼</div><div id="hudUser">æœªæ¥ç¶š</div>
    <div>ãƒˆãƒ¼ã‚¯ãƒ³æ®‹ã‚Š</div><div id="hudTTL">â€”</div>
    <div>é€²æ—</div>
    <div>
      <progress id="prog" value="0" max="100"></progress>
      <div class="row" style="margin-top:8px">
        <span id="progTxt" class="muted" style="flex:1 1 auto">æº–å‚™OK</span>
        <button id="btnRepair" style="flex:0 0 auto">ğŸ”§ ç·Šæ€¥ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
    </div>
  </div>
  <div class="row" style="margin-top:8px">
    <div><a class="btn" href="./auth.html">Connect with Spotify</a> <button id="btnMe">/v1/me</button> <button id="btnSignOut">åˆ‡æ–­ï¼ˆä¿å­˜ãƒˆãƒ¼ã‚¯ãƒ³å‰Šé™¤ï¼‰</button></div>
    <div class="muted" id="status">æœªæ¥ç¶šï¼ˆä¸Šã®ãƒœã‚¿ãƒ³ã‹ã‚‰é–‹å§‹ï¼‰</div>
  </div>
</div>

<!-- ã‚·ãƒ³ãƒ—ãƒ«è¨­å®šï¼ˆæ—¢å­˜ã‚¯ã‚¤ãƒƒã‚¯ãƒ“ãƒ«ãƒ‰ï¼‰ -->
<fieldset>
  <legend>ãƒ—ãƒªã‚»ãƒƒãƒˆï¼ˆUK / US / EU / Worldï¼‰</legend>
  <div class="row">
    <div>
      <label>ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³</label>
      <div class="note">4ã¤ã™ã¹ã¦æ—¢å®šONï¼ˆå¿…è¦ãªã‚‰å¤–ã—ã¦ãã ã•ã„ï¼‰</div>
      <label><input type="checkbox" class="ed" value="UK" checked> UK</label>
      <label><input type="checkbox" class="ed" value="US" checked> US</label>
      <label><input type="checkbox" class="ed" value="EU" checked> EU</label>
      <label><input type="checkbox" class="ed" value="WORLD" checked> World</label>
    </div>
    <div>
      <label>ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆID</label>
      <input id="artistId" value="55fvQ5I2IZUfcFT2DV02T3">
      <div class="note">The Darrow Chem Syndicateï¼ˆå¤‰æ›´å¯ï¼‰</div>
    </div>
    <div>
      <label>æœ€æ–°ã‹ã‚‰å–ã‚‹æšæ•°</label>
      <input id="albumRecent" type="number" min="24" max="64" value="48">
      <div class="note">å¤ã„ã‚«ã‚¿ãƒ­ã‚°ã‚‚æ‹¾ã†ãŸã‚å¤šã‚æ¨å¥¨</div>
    </div>
    <div>
      <label>æ—§ä½œã‚µãƒ³ãƒ—ãƒ«æ¯”ç‡ï¼ˆ0â€“0.8ï¼‰</label>
      <input id="oldAlbumRatio" type="number" step="0.05" min="0" max="0.8" value="0.40">
      <div class="note">ä¾‹ï¼‰48æš Ã— 0.40 â‰’ 19æšã¶ã‚“éå»ã‚’è¿½åŠ </div>
    </div>
  </div>
  <div class="row">
    <div>
      <label>æ¡ç”¨ã™ã‚‹ãƒªãƒªãƒ¼ã‚¹ã®æ›²æ•°ä¸Šé™</label>
      <input id="maxTracks" type="number" min="6" max="20" value="9">
      <div class="note">EP/Singleä¸­å¿ƒã«ã™ã‚‹ãŸã‚ã®ä¸Šé™ã€‚è¶³ã‚Šãªã‘ã‚Œã° 12ã€‚</div>
    </div>
    <div>
      <label>Trimä¸Šé™ï¼ˆå€™è£œã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼‰</label>
      <input id="targetPool" type="number" min="120" max="220" value="150">
      <div class="note">ã¾ãš 150 æ›²ã¸ãƒˆãƒªãƒ </div>
    </div>
    <div>
      <label>Balancedæ›²æ•°</label>
      <select id="balancedSize">
        <option value="100">100</option>
        <option value="120">120</option>
        <option value="150" selected>150</option>
      </select>
    </div>
    <div>
      <label>äººæ°—ã®é‡ã¿</label>
      <input id="wPopularity" type="number" step="0.05" min="0" max="1" value="0.55">
    </div>
    <div>
      <label>æ–°ã—ã•ã®é‡ã¿</label>
      <input id="wRecent" type="number" step="0.05" min="0" max="1" value="0.45">
    </div>
  </div>
  <div class="row sticky-actions">
    <div>
      <button id="btnFast">â‘  åé›†ï¼ˆQuickï¼‰</button>
      <button id="btnTrim" disabled>â‘¡ Trimï¼ˆ150ï¼‰</button>
      <button id="btnBalance" disabled>â‘¢ Balancedï¼ˆ100/120/150ï¼‰</button>
      <button id="btnBuildEditions" disabled>â‘£ 4ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ä½œæˆ</button>
    </div>
    <div>
      <label>APIæœ€å°é–“éš”ms</label>
      <input id="gap" type="number" value="900">
    </div>
  </div>
</fieldset>

<!-- æ–°æ©Ÿèƒ½ï¼šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æœ€çµ‚ç‰ˆï¼ˆ130Ã—4ï¼‰ç”Ÿæˆï¼†æ—¢å­˜ãƒ‰ãƒ©ãƒ•ãƒˆã¸ä¸Šæ›¸ã -->
<fieldset>
  <legend>ãƒ•ã‚¡ã‚¤ãƒ«å–ã‚Šè¾¼ã¿ â†’ 130æ›²Ã— EU/UK/US/WORLD ã‚’ç”Ÿæˆ & æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆã¸ä¸Šæ›¸ã</legend>
  <div class="row">
    <div>
      <label>ã‚½ãƒ¼ã‚¹CSVï¼ˆPropgapandaã‚½ãƒ¼ã‚¹.csvï¼‰</label>
      <input id="fileSourceCsv" type="file" accept=".csv">
      <div class="note">Remix/Breaksåˆ¤å®šã«ä½¿ã†å…ƒãƒ‡ãƒ¼ã‚¿</div>
    </div>
    <div>
      <label>åˆ†æãƒ‡ãƒ¼ã‚¿ï¼ˆExcel or CSVï¼‰</label>
      <input id="fileMetrics" type="file" accept=".xlsx,.xls,.csv">
      <div class="note">ä¿å­˜ç‡/å†ç”Ÿç³»ã®æŒ‡æ¨™ã‚’å«ã‚€è¡¨ï¼ˆExcelãªã‚‰ <code>xlsx.full.min.js</code> ãŒå¿…è¦ï¼‰</div>
    </div>
  </div>
  <div class="row">
    <div><label>EUãƒ‰ãƒ©ãƒ•ãƒˆURL/ID</label><input id="plEU" placeholder="URL or ID" value="https://open.spotify.com/playlist/2JWHMN3yxLI5S4XFdDZbwt"></div>
    <div><label>UKãƒ‰ãƒ©ãƒ•ãƒˆURL/ID</label><input id="plUK" placeholder="URL or ID" value="https://open.spotify.com/playlist/1zqDXSgnbc87v4BxbHxtKK"></div>
    <div><label>USãƒ‰ãƒ©ãƒ•ãƒˆURL/ID</label><input id="plUS" placeholder="URL or ID" value="https://open.spotify.com/playlist/2oeS8QglwS4hLtLuqvPZgH"></div>
    <div><label>WORLDãƒ‰ãƒ©ãƒ•ãƒˆURL/ID</label><input id="plWORLD" placeholder="URL or ID" value="https://open.spotify.com/playlist/4SCclM9zLNuSPOmqORdVN8"></div>
  </div>
  <div class="row">
    <div><button id="btnBuildFromFiles">ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æœ€çµ‚ç‰ˆï¼ˆ130Ã—4ï¼‰ä½œæˆ</button></div>
    <div><button id="btnUpdateFromFiles" disabled>å„ç‰ˆã‚’æ—¢å­˜Playlistã«ä¸Šæ›¸ãåæ˜ </button></div>
  </div>
  <div class="note">â€œãƒ‰ãƒ©ãƒ•ãƒˆã‚’å…ƒã«â€ã®è¦æœ›å¯¾å¿œï¼šå„ãƒ‰ãƒ©ãƒ•ãƒˆã®ç¾è¡Œæ›²ã‚’ <b>ãƒ”ãƒ³ï¼ˆéŒ¨ï¼‰</b> ã¨ã—ã¦å„ªå…ˆé…ç½®ã—ã¾ã™ï¼ˆè¦‹ã¤ã‹ã£ãŸç¯„å›²ï¼‰</div>
</fieldset>

<!-- å˜ç™ºä½œæˆï¼ˆæ—¢å­˜æ©Ÿèƒ½ï¼‰ -->
<fieldset>
  <legend>ï¼ˆä»»æ„ï¼‰å˜ç™ºã§ä½œæˆ/æ›´æ–°</legend>
  <div class="row">
    <div><label>ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆå</label><input id="plName" placeholder="TDCS â€“ Breaks Remix Only (Balanced 150)"></div>
    <div><label>èª¬æ˜æ–‡</label><input id="plDesc" placeholder="Breaks/Breakbeaté™å®šãƒ»2010+ãƒ»Remixã®ã¿ãƒ»Pinså›ºå®šãƒ»Balancedå‡ºåŠ›"></div>
    <div><label>å…¬é–‹è¨­å®š</label><select id="plPublic"><option value="false" selected>éå…¬é–‹</option><option value="true">å…¬é–‹</option></select></div>
  </div>
  <div class="row">
    <div><label>æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒªã‚¹ãƒˆIDï¼ˆç©ºï¼æ–°è¦ï¼‰</label><input id="existingId" placeholder="ä¾‹ï¼‰37i9dQZF1DX..."></div>
    <div><label>æœ€å¤§ãƒªãƒˆãƒ©ã‚¤</label><input id="maxRetry" type="number" value="5"></div>
    <div><button id="btnCommit" disabled>â‘¤ ä½œæˆ/æ›´æ–°ã™ã‚‹</button></div>
  </div>
  <div class="note">â€» BalancedãŒæœªç”Ÿæˆãªã‚‰ Trim(æœ€å¤§150) ã‚’ãã®ã¾ã¾å‡ºã—ã¾ã™ã€‚</div>
</fieldset>

<h2 style="margin-bottom:6px">ãƒ­ã‚°</h2>
<details id="logBox">
  <summary class="muted">é–‹ãï¼ˆãƒ¢ãƒã‚¤ãƒ«ã§ã¯é‡ã„ã®ã§é–‰ã˜ã¦ã„ã¾ã™ï¼‰</summary>
  <pre id="log"></pre>
</details>

<!-- ç”»é¢ä¸‹ãƒ‰ãƒƒã‚¯ï¼ˆãƒ¢ãƒã‚¤ãƒ«æ“ä½œãƒãƒ¼ï¼‰ -->
<div class="dock" role="toolbar" aria-label="æ“ä½œ">
  <button id="mbFast">åé›†</button>
  <button id="mbTrim" disabled>Trim</button>
  <button id="mbBalance" disabled>Bal</button>
  <button id="mbBuild" disabled>ä½œæˆ</button>
  <button id="mbCommit" disabled>æ›´æ–°</button>
</div>

<script>
"use strict";

/*** å›ºå®šï¼šèªå¯/ä¿å­˜ã‚­ãƒ¼ ***/
const CLIENT_ID="1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI="https://npr2025.github.io/spotify-auth/callback.html";
const K={access:"sp_access_token",type:"sp_token_type",expAt:"sp_expires_at",refresh:"sp_refresh_token",scope:"sp_scope"};

/*** ä¾¿åˆ© ***/
const el=id=>document.getElementById(id);
const log=(m)=>{
  const d=new Date().toLocaleTimeString();
  const L=el("log");
  const next=L.textContent+`[${d}] ${m}\n`;
  const lines=next.split("\n");
  const trimmed=(lines.length>300?lines.slice(-300):lines).join("\n");
  L.textContent=trimmed;
  L.scrollTop=L.scrollHeight;
};
const setProg=(v,t)=>{el("prog").value=v; el("progTxt").textContent=t||"";};
const status=(t)=>{el("status").textContent=t||"";};
const sleep=ms=>new Promise(r=>setTimeout(r,ms));

/*** æ¥ç¶šè¡¨ç¤º ***/
function renderStatus(){
  try{
    const a=sessionStorage.getItem(K.access); const e=parseInt(sessionStorage.getItem(K.expAt)||"0",10);
    if(!a){ el("hudUser").textContent="æœªæ¥ç¶š"; el("hudTTL").textContent="â€”"; status("æœªæ¥ç¶šï¼ˆConnect ã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼‰"); return; }
    const left=e-Date.now();
    el("hudUser").textContent="æ¥ç¶šä¸­"; el("hudTTL").textContent=left>0?`${Math.floor(left/1000)}s`:"æœŸé™åˆ‡ã‚Œ";
    status(left>0?"æ¥ç¶šä¸­":"æœŸé™åˆ‡ã‚Œï¼ˆConnect ã—ç›´ã—ï¼‰");
  }catch(e){ status("çŠ¶æ…‹è¡¨ç¤ºã‚¨ãƒ©ãƒ¼: "+(e.message||e)); }
}

/*** ãƒ¬ãƒ¼ãƒˆ/ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥/HTTP ***/
let MIN_API_GAP_MS=900, lastApiTs=0, refreshInflight=null;
async function ensureFreshToken(){
  const access=sessionStorage.getItem(K.access), expAt=parseInt(sessionStorage.getItem(K.expAt)||"0",10), refresh=sessionStorage.getItem(K.refresh);
  if(access && Date.now()<(expAt-5000)) return access;
  if(!refresh) return null;
  if(!refreshInflight){
    refreshInflight=(async()=>{
      let attempt=0;
      while(true){ attempt++;
        const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:refresh,redirect_uri:REDIRECT_URI})});
        if(res.status===429){const ra=parseInt(res.headers.get("Retry-After")||"1",10); await sleep((isNaN(ra)?1:Math.min(60,ra))*1000+200); continue;}
        if(res.status>=500 && attempt<=3){await sleep(Math.min(5000,600*Math.pow(2,attempt-1))); continue;}
        const txt=await res.text(); let data=null; try{data=JSON.parse(txt);}catch(_){}
        if(!res.ok) throw new Error("refresh failed: "+res.status+" "+txt);
        const exp=Date.now()+data.expires_in*1000;
        sessionStorage.setItem(K.access,data.access_token);
        sessionStorage.setItem(K.expAt,String(exp));
        if(data.refresh_token) sessionStorage.setItem(K.refresh,data.refresh_token);
        if(data.scope) sessionStorage.setItem(K.scope,data.scope);
        renderStatus();
        return data.access_token;
      }
    })().finally(()=>{refreshInflight=null;});
  }
  return refreshInflight;
}
function parse403(txt){ try{const j=JSON.parse(txt); return j?.error?.message||"";}catch(_){return "";} }
async function callSpotifyJSON(url,opts={}, {maxRetry=5,expectJSON=true,tag=""}={}){
  MIN_API_GAP_MS=Math.max(300, parseInt(el("gap")?.value||"900",10));
  const wait=Math.max(0,MIN_API_GAP_MS-(Date.now()-lastApiTs)); if(wait) await sleep(wait);
  let token=await ensureFreshToken(); if(!token) throw new Error("No valid token. Connect again.");
  let attempt=0;
  while(true){
    attempt++;
    const headers=new Headers(opts.headers||{}); headers.set("Authorization","Bearer "+token); headers.set("Accept","application/json");
    if(opts.body && !(opts.body instanceof FormData) && !headers.has("Content-Type")) headers.set("Content-Type","application/json");
    const res=await fetch(url,{...opts,headers}); lastApiTs=Date.now();

    if(res.status===429 && attempt<=maxRetry){const ra=parseInt(res.headers.get("Retry-After")||"1",10); await sleep((isNaN(ra)?1:Math.min(60,ra))*1000+200); continue;}
    if(res.status===401 && attempt===1){ token=await ensureFreshToken(); if(!token) throw new Error("Unauthorized and cannot refresh."); continue; }
    if(res.status===403){ const txt=await res.text(); throw new Error(`${tag||"HTTP"} 403${parse403(txt)?": "+parse403(txt):""}`); }
    if(res.status>=500 && attempt<=maxRetry){ await sleep(Math.min(8000,700*Math.pow(2,attempt-1))); continue; }
    if(!res.ok){ const txt=await res.text(); throw new Error(`${tag||"HTTP"} ${res.status}: ${txt}`); }

    if(!expectJSON) return null;
    const txt=await res.text(); if(!txt) return {}; try{ return JSON.parse(txt); }catch(_){ return {}; }
  }
}

/*** åˆ¤å®šï¼šRemix only / Breaks / EP/Single ***/
function tokenize(s){ return (s||"").toLowerCase().replace(/[()[\]{}\-]/g," ").replace(/\s+/g," ").trim().split(" ").filter(Boolean); }
function isRemixOnlyTitle(name){
  const t=tokenize(name);
  const hasRemix=t.includes("remix")||t.includes("remixed")||t.includes("rmx");
  const hasMix = t.includes("mix") || (t.includes("dj")&&t.includes("mix")) || (t.includes("original")&&t.includes("mix")) || (t.includes("club")&&t.includes("mix")) || (t.includes("continuous")&&t.includes("mix"));
  return hasRemix && !hasMix;
}
const breaksWord=/\b(breaks?|break[-\s]?beat|nu[-\s]?breaks?|big\s*beat|funky[-\s]*breaks?|electro[-\s]*breaks?|progressive\s*breaks?|psy[-\s]*breaks?|acid\s*breaks?)\b/i;
const genreOK=g=>/breakbeat|breaks?|big beat|nu skool breaks|electro breaks?|progressive breaks?|funky breaks?|psybreaks?|acid breaks?/i.test(g||"");
function yearFromDate(s){ if(!s) return 0; const y=parseInt(String(s).slice(0,4),10); return isNaN(y)?0:y; }
function isEP(album){ const type=(album.album_type||"").toLowerCase(); const tracks=album.total_tracks||0; const name=(album.name||"").toLowerCase(); return (type==="single" && tracks>=3) || /\bep\b/.test(name); }
function isSingle(album){ const type=(album.album_type||"").toLowerCase(); return type==="single" && !isEP(album); }

/*** å¯ç”¨æ€§ï¼ˆã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ç”¨ï¼‰ ***/
const trackSeenBy=new Map(); function markSeen(id,market){ let s=trackSeenBy.get(id); if(!s){s=new Set(); trackSeenBy.set(id,s);} s.add(market); }

/*** Editions ***/
const EDITIONS={
  UK:    { markets:["GB","IE"], anyOf:["GB"], suffix:" [UK Edition]" },
  US:    { markets:["US","CA"], anyOf:["US"], suffix:" [US Edition]" },
  EU:    { markets:["DE","FR","NL","ES","IT","SE","DK","FI","BE"], needCount:3, suffix:" [EU Edition]" },
  WORLD: { markets:["US","GB","DE","FR","NL","ES","IT","SE","AU","CA"], needPct:0.6, suffix:" [World Edition]" }
};

/*** å°é“å…· ***/
const chunk=(a,n)=>{const out=[]; for(let i=0;i<a.length;i+=n) out.push(a.slice(i,i+n)); return out; };
function computeScores(tracks,wPop,wRec){
  let minD=Infinity,maxD=-Infinity;
  for(const t of tracks){ const ms=new Date(t.album?.release_date||t.__albumDate||0).getTime()||0; t._dateMs=ms; if(ms){ if(ms<minD)minD=ms; if(ms>maxD)maxD=ms; } }
  for(const t of tracks){ const recent=t._dateMs?((t._dateMs-minD)/Math.max(1,(maxD-minD))):0.5; const pop=(t.popularity||0)/100; t._score=wPop*pop+wRec*recent; }
  tracks.sort((a,b)=>b._score-a._score);
}
function artistsSet(t){ return new Set((t.artists||[]).map(a=>a.id)); }
function shareArtist(a,b){ const A=artistsSet(a),B=artistsSet(b); for(const x of A){ if(B.has(x)) return true; } return false; }
function eraBlendCands(tracks,ratioOld,poolN){
  const arr=[...tracks].sort((a,b)=>(a._dateMs||0)-(b._dateMs||0));
  const N=Math.min(poolN, arr.length);
  const kOld=Math.max(0, Math.min(arr.length, Math.floor(N*ratioOld)));
  const olds=arr.slice(0, Math.min(kOld, Math.floor(arr.length/2)));
  const news=arr.slice(-Math.min(N-kOld, Math.ceil(arr.length/2)));
  const set=new Map(); [...news,...olds].forEach(t=>set.set(t.id,t)); return [...set.values()];
}
function balancedOrder(cands,pins,finalSize,{noAdjacent=true}={}){
  const posPins=new Map(Object.entries(pins).map(([k,v])=>[parseInt(k,10),v]).filter(([,v])=>v));
  const pinIds=new Set([...posPins.values()]);
  let rest=cands.filter(t=>!pinIds.has(t.id));
  const energies=rest.map(t=>t.features.energy||0.5).sort((a,b)=>a-b);
  const q1=energies[Math.floor(energies.length*0.25)]||0.25, q2=energies[Math.floor(energies.length*0.5)]||0.5, q3=energies[Math.floor(energies.length*0.75)]||0.75;
  const bucket=t=>(t.features.energy<=q1)?0:(t.features.energy<=q2)?1:(t.features.energy<=q3)?2:3;
  const bins=[[],[],[],[]]; rest.forEach(t=>bins[bucket(t)].push(t)); bins.forEach(b=>b.sort((a,b)=>b._score-a._score));
  const seq=new Array(finalSize).fill(null); let cyc=0;
  for(const [pos,id] of posPins){ const t=cands.find(x=>x.id===id); if(t) seq[pos-1]=t; }
  function pick(prev){ for(let r=0;r<4;r++){ const bi=(cyc+r)%4; const a=bins[bi]; for(let i=0;i<a.length;i++){ const t=a[i]; if(noAdjacent && prev && shareArtist(prev,t)) continue; a.splice(i,1); cyc=(bi+1)%4; return t; } } for(let bi=0;bi<4;bi++){ if(bins[bi].length) return bins[bi].shift(); } return null; }
  for(let i=0;i<finalSize;i++){ if(seq[i]) continue; const prev=i?seq[i-1]:null; seq[i]=pick(prev); }
  return seq.filter(Boolean);
}

/*** æ—¢å­˜ã®ã‚¢ãƒ«ãƒãƒ â†’æ›²åé›†ï¼ˆQuickãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰ ***/
async function scanArtistAlbums(artistId, market, groupsCsv, scanMax){
  let items=[]; let url=`https://api.spotify.com/v1/artists/${artistId}/albums?market=${encodeURIComponent(market)}&include_groups=${encodeURIComponent(groupsCsv)}&limit=50&offset=0`;
  while(url && items.length<scanMax){ const data=await callSpotifyJSON(url,{}, {tag:`albums(${market})`}); items.push(...(data.items||[])); url=data.next||null; }
  items.sort((a,b)=> new Date(b.release_date)-new Date(a.release_date));
  return items;
}
async function fetchAlbumTracks(albumId, albumName, albumDate, market){
  let items=[]; let url=`https://api.spotify.com/v1/albums/${albumId}/tracks?limit=50&offset=0`;
  while(url){ const data=await callSpotifyJSON(url,{}, {tag:`album:${market}`}); items.push(...(data.items||[])); url=data.next||null; }
  items.forEach(t=>{ if(t?.id) markSeen(t.id,market); });
  return items.map(t=>({ ...t, __albumDate: albumDate, __albumName: albumName }));
}
async function searchRemixesByArtist(artistId, markets, minYear){
  const outIds=new Set(); let artistName="";
  try{ const ai=await callSpotifyJSON(`https://api.spotify.com/v1/artists/${artistId}`,{}, {tag:"artist"}); artistName=ai?.name||"";}catch{ return []; }
  const years=`${minYear}-2030`;
  for(const mkt of markets){
    for(let offset=0; offset<=400; offset+=50){
      try{
        const q=encodeURIComponent(`artist:"${artistName}" remix year:${years}`);
        const data=await callSpotifyJSON(`https://api.spotify.com/v1/search?type=track&limit=50&offset=${offset}&q=${q}&market=${mkt}`,{}, {tag:`search:${mkt}:${offset}`});
        const tracks=(data.tracks&&data.tracks.items)||[];
        if(!tracks.length) break;
        for(const t of tracks){
          if(!t?.id) continue;
          const hasSeed=(t.artists||[]).some(a=>a?.id===artistId); if(!hasSeed) continue;
          if(!isRemixOnlyTitle(t.name)) continue;
          const yOk=yearFromDate(t.album?.release_date)>=minYear; if(!yOk) continue;
          outIds.add(t.id);
        }
      }catch{ break; }
    }
  }
  return [...outIds];
}
async function fetchTracksBatched(ids){
  const uniq=[...new Set(ids)]; const results=[];
  async function chunkFetch(list,tag){
    try{ const data=await callSpotifyJSON(`https://api.spotify.com/v1/tracks?ids=${list.join(",")}`,{}, {tag}); (data.tracks||[]).forEach(t=>t&&results.push(t)); }
    catch(e){ if(String(e.message||"").includes(" 403") && list.length>1){ const m=Math.floor(list.length/2); await chunkFetch(list.slice(0,m),tag+"a"); await chunkFetch(list.slice(m),tag+"b"); } else if(list.length===1){ log(`Ã— 403 skip track ${list[0]}`); } else { throw e; } }
  }
  for(const c of chunk(uniq,50)) await chunkFetch(c,"tracks");
  return results;
}
async function fetchFeaturesBatched(ids){
  const uniq=[...new Set(ids)]; const feats=new Map();
  async function batch(list,tag){ const d=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features?ids=${list.join(",")}`,{}, {tag}); (d.audio_features||[]).forEach((f,i)=>{const id=list[i]; if(f&&f.id)feats.set(f.id,f); else feats.set(id,null);}); }
  async function single(id){ try{ const f=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features/${id}`,{}, {tag:`feature:${id}`}); if(f&&f.id) return void feats.set(id,f); }catch{} feats.set(id,null); }
  async function analysis(id){ try{ const a=await callSpotifyJSON(`https://api.spotify.com/v1/audio-analysis/${id}`,{}, {tag:`analysis:${id}`}); const tempo=a?.track?.tempo||132; feats.set(id,{id,energy:0.58,valence:0.45,danceability:0.60,tempo,__fallback:"analysis"});}catch{feats.set(id,{id,energy:0.58,valence:0.45,danceability:0.60,tempo:132,__fallback:"neutral"});} }
  for(const c of chunk(uniq,100)) try{ await batch(c,"features"); }catch{ c.forEach(id=>feats.set(id,null)); }
  const need1=uniq.filter(id=>!feats.has(id) || feats.get(id)===null);
  for(const id of need1) await single(id);
  const need2=uniq.filter(id=>!feats.has(id) || feats.get(id)===null);
  for(const id of need2) await analysis(id);
  return feats;
}
async function fetchArtistsGenresMapBatched(ids){
  const uniq=[...new Set(ids)]; const map=new Map();
  async function chunkFetch(list,tag){ const data=await callSpotifyJSON(`https://api.spotify.com/v1/artists?ids=${list.join(",")}`,{}, {tag}); (data.artists||[]).forEach(a=>a&&map.set(a.id,a.genres||[])); }
  for(const c of chunk(uniq,50)) await chunkFetch(c,"artists");
  return map;
}

/*** ã‚°ãƒ­ãƒ¼ãƒãƒ«ï¼ˆQuickç”¨ï¼‰ ***/
let trimmed=[], finalSeq=[];
const albumCache=new Map();

/*** åé›†ï¼ˆQuick ãƒ¢ãƒ¼ãƒ‰ï¼‰ ***/
async function doFastBuild(){
  trimmed=[]; finalSeq=[]; trackSeenBy.clear();
  setProg(2,"start");

  const eds=[...document.querySelectorAll(".ed:checked")].map(x=>x.value);
  if(!eds.length){ alert("ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„"); return; }
  const markets=[...new Set(eds.flatMap(k=>EDITIONS[k].markets))];
  const artistId=el("artistId").value.trim();
  const recentN=parseInt(el("albumRecent").value||"48",10);
  const oldRatio=parseFloat(el("oldAlbumRatio").value||"0.40");
  const maxTracks=parseInt(el("maxTracks").value||"9",10);
  const targetPool=parseInt(el("targetPool").value||"150",10);
  const minYear=2010;

  log(`=== FAST Build start editions=[${eds.join(",")}] recent=${recentN} oldRatio=${oldRatio} maxTracks<=${maxTracks} ===`);

  const groupsCsv="album,single,compilation,appears_on";
  const SCAN_MAX=200;
  const pickedMap=new Map();
  for(const m of markets){
    let all=albumCache.get(m); if(!all){ all=await scanArtistAlbums(artistId,m,groupsCsv,SCAN_MAX); albumCache.set(m,all); }
    const filtered=all.filter(a=>{
      const ep=isEP(a), single=isSingle(a);
      const tracks=(a.total_tracks||99) <= maxTracks;
      return (ep||single) && tracks;
    });
    const rec=filtered.slice(0, recentN);
    const old=oldRatio ? filtered.slice(-Math.round(recentN*oldRatio)) : [];
    log(`å¸‚å ´ ${m}: albums(all=${all.length}, afterType=${filtered.length}) â‰¤${maxTracks} â†’ recent=${rec.length}, old=${old.length}`);
    [...rec,...old].forEach(a=>{
      if(!pickedMap.has(a.id)) pickedMap.set(a.id,{album:a,markets:new Set()});
      pickedMap.get(a.id).markets.add(m);
    });
  }
  const picked=[...pickedMap.values()];
  setProg(12,`albums ${picked.length}`);

  const collectIds=new Set();
  for(let i=0;i<picked.length;i++){
    const {album:a, markets:mkts}=picked[i];
    const tracks=await fetchAlbumTracks(a.id,a.name,a.release_date,[...mkts][0]||markets[0]);
    for(const t of tracks){
      if(!t?.id) continue;
      for(const m of mkts) markSeen(t.id,m);
      const seedOK=(t.artists||[]).some(x=>x?.id===artistId); if(!seedOK) continue;
      if(!isRemixOnlyTitle(t.name)) continue;
      if(yearFromDate(a.release_date)<minYear) continue;
      collectIds.add(t.id);
    }
    if(collectIds.size>=targetPool*3) break;
  }
  log(`ã‚¢ãƒ«ãƒãƒ å…¨æ›²ã‚¹ã‚­ãƒ£ãƒ³å¾Œ: ${collectIds.size}æ›²`);

  if(collectIds.size<targetPool){
    const extra=await searchRemixesByArtist(artistId, markets, minYear);
    extra.forEach(id=>collectIds.add(id));
    log(`search fallback åç©«å¾Œ: ${collectIds.size}æ›²`);
  }
  if(!collectIds.size){ log("å€™è£œ0ã€‚æ¡ä»¶ã‚’è¦‹ç›´ã—ã¦ãã ã•ã„ã€‚"); return; }

  setProg(40,"details");
  const trackObjs=await fetchTracksBatched([...collectIds]);
  setProg(56,"features");
  const featsMap=await fetchFeaturesBatched(trackObjs.map(t=>t.id));
  const artistIds=new Set(); trackObjs.forEach(t=> (t.artists||[]).forEach(a=>a?.id&&artistIds.add(a.id)));
  setProg(70,"artists");
  const genresMap=await fetchArtistsGenresMapBatched([...artistIds]);

  function classifyBreaks(t){
    const byGenres=(t.artists||[]).some(a=>(genresMap.get(a.id)||[]).some(genreOK));
    const byTitle =breaksWord.test(t.name||"");
    const byAlbum =breaksWord.test(t.album?.name||"");
    const byLabel =breaksWord.test(t.album?.label||"");
    const bySeed  =(t.artists||[]).some(a=>a?.id===artistId);
    return byGenres||byTitle||byAlbum||byLabel||bySeed;
  }

  setProg(78,"filter");
  let base = trackObjs.map(t=>{ const f=featsMap.get(t.id)||{}; return {
    id:t.id, name:t.name, artists:t.artists||[], popularity:t.popularity||0, duration_ms:t.duration_ms||0,
    album:t.album||{}, features:{energy:f?.energy??0.58,valence:f?.valence??0.45,danceability:f?.danceability??0.60,tempo:f?.tempo??132}
  }; });

  const passCore = (t)=>{
    const a=t.album||{};
    if(yearFromDate(a.release_date) < 2010) return false;
    if(!isRemixOnlyTitle(t.name))          return false;
    const ep=isEP(a), single=isSingle(a);   if(!(ep||single)) return false;
    if((a.total_tracks||99) > maxTracks)    return false;
    return true;
  };

  let filtered = base.filter(t => passCore(t) && classifyBreaks(t));
  if(filtered.length < 120){
    log(`Breaks åˆ¤å®šã‚’ç·©å’Œ: ${filtered.length}æ›² â†’ å†è©•ä¾¡ä¸­â€¦`);
    filtered = base.filter(passCore);
    log(`â†’ ç·©å’Œå¾Œ: ${filtered.length}æ›²`);
  }

  const wPop=parseFloat(el("wPopularity").value||"0.55");
  const wRec=parseFloat(el("wRecent").value||"0.45");
  computeScores(filtered,wPop,wRec);
  const upper=Math.min(parseInt(el("targetPool").value||"150",10), filtered.length);
  trimmed=filtered.slice(0, upper);
  log(`Trim å®Œäº†ï¼š${trimmed.length}æ›²ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆ${upper}ï¼‰`);
  setProg(90,`trimmed ${trimmed.length}`);

  ['btnTrim','btnBalance','btnBuildEditions','btnCommit','mbTrim','mbBalance','mbBuild','mbCommit'].forEach(id=>{
    const b=el(id); if(b) b.disabled=false;
  });
}

async function doTrim(){
  if(!trimmed.length) return alert("å…ˆã«â‘ åé›†ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„");
  const upper=Math.min(parseInt(el("targetPool").value||"150",10), trimmed.length);
  trimmed=trimmed.slice(0, upper);
  log(`Trim å†å®Ÿè¡Œï¼š${trimmed.length}æ›²`);
  setProg(92,"Trim done");
}

async function doBalance(){
  if(!trimmed.length) return alert("å…ˆã«â‘ åé›†/â‘¡Trimã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„");
  const wantN = Math.max(80, Math.min(parseInt(el("balancedSize").value||"150",10), trimmed.length));
  const pins  = {1:"0ueNjvhtXGDFkJQ5WBQ4mE",5:"63dYSEftdSYwMAFBNfQYsA",40:"3NQuIFfQPhTICaXGYe5dAt",60:"7ltcrdlVsXyU5HU9VCAj6P"};
  const pool  = eraBlendCands(trimmed, 0.40, Math.min(trimmed.length, wantN*2));
  finalSeq    = balancedOrder(pool, pins, wantN, {noAdjacent:true});
  log(`Balanced ç”Ÿæˆï¼š${finalSeq.length}æ›²ï¼ˆæŒ‡å®š=${wantN} / old 40% mixï¼‰`);
  setProg(100,`Balanced ${wantN} ready`);
}

async function putPlaylist(name, desc, isPublic, uris, existingId=null){
  const maxRetry=Math.max(1, parseInt(el("maxRetry").value||"5",10));
  const me=await callSpotifyJSON("https://api.spotify.com/v1/me",{}, {tag:"/me",maxRetry}); const uid=me.id;
  let playlistId=existingId||null;
  if(playlistId){
    await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}`,{method:"PUT",body:JSON.stringify({name,description:desc,public:isPublic})},{tag:"PUT playlist",maxRetry,expectJSON:false});
  }else{
    const created=await callSpotifyJSON(`https://api.spotify.com/v1/users/${uid}/playlists`,{method:"POST",body:JSON.stringify({name,description:desc,public:isPublic})},{tag:"POST playlist",maxRetry});
    playlistId=created.id;
  }
  const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
  await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`,{method:"PUT",body:JSON.stringify({uris:chunks[0]||[]})},{tag:"PUT tracks",maxRetry,expectJSON:false});
  for(let i=1;i<chunks.length;i++) await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`,{method:"POST",body:JSON.stringify({uris:chunks[i]})},{tag:`POST tracks #${i+1}`,maxRetry});
  log(`å®Œæˆ: https://open.spotify.com/playlist/${playlistId}`);
}

function selectedEditions(){ return [...document.querySelectorAll(".ed:checked")].map(x=>x.value); }
function coverageOk(trackId, ed, relaxStep=0){
  const seen=trackSeenBy.get(trackId)||new Set();
  if(ed.anyOf){ return ed.anyOf.some(m=>seen.has(m)); }
  if(ed.needCount){ const c=ed.markets.reduce((n,m)=>n+(seen.has(m)?1:0),0); const need=Math.max(1, ed.needCount-relaxStep); return c>=need; }
  if(ed.needPct){ const total=ed.markets.length; const c=ed.markets.reduce((n,m)=>n+(seen.has(m)?1:0),0); const need=Math.max(1, Math.ceil(total*(ed.needPct-relaxStep*0.1))); return c>=need; }
  return true;
}

async function buildEditions(){
  if(!trimmed.length) return alert("å…ˆã«â‘ åé›†ï¼ˆã§ãã‚Œã° â‘¡Trim / â‘¢Balancedï¼‰ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„");
  const eds=selectedEditions(); if(!eds.length) return alert("ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã‚’é¸ã‚“ã§ãã ã•ã„");

  const base=(document.getElementById("plName").value||"TDCS â€“ Breaks Remix Only").trim();
  const desc=(document.getElementById("plDesc").value||"Breaks/Breakbeaté™å®šãƒ»2010+ãƒ»Remixã®ã¿ãƒ»Pinså›ºå®š").trim();
  const isPublic=document.getElementById("plPublic").value==="true";

  const wantN = (finalSeq&&finalSeq.length) ? finalSeq.length : Math.min(parseInt(el("balancedSize").value||"150",10), trimmed.length);
  const pins  = {1:"0ueNjvhtXGDFkJQ5WBQ4mE",5:"63dYSEftdSYwMAFBNfQYsA",40:"3NQuIFfQPhTICaXGYe5dAt",60:"7ltcrdlVsXyU5HU9VCAj6P"};

  for(const key of eds){
    const ed=EDITIONS[key];
    let keep=trimmed.filter(t=>coverageOk(t.id,ed,0));
    if(keep.length<wantN) keep=trimmed.filter(t=>coverageOk(t.id,ed,1));
    if(keep.length<wantN) keep=trimmed.filter(t=>coverageOk(t.id,ed,2));
    if(keep.length<wantN) keep=trimmed;

    const seq = (finalSeq&&finalSeq.length)
      ? balancedOrder(keep, pins, wantN, {noAdjacent:true})
      : balancedOrder(keep, pins, Math.min(wantN, keep.length), {noAdjacent:true});

    const uris=seq.map(t=>`spotify:track:${t.id}`);
    const name=`${base} (${wantN})${ed.suffix}`;
    log(`Edition ${key}: ${seq.length}æ›²ã‚’åæ˜ `);
    await putPlaylist(name, `${desc} ${ed.suffix}`, isPublic, uris, null);
  }
  alert("UK/US/EU/World ã®ä½œæˆãŒå®Œäº†ã—ã¾ã—ãŸã€‚");
}

/*** ã“ã“ã‹ã‚‰ï¼šãƒ•ã‚¡ã‚¤ãƒ«å–ã‚Šè¾¼ã¿ç‰ˆï¼ˆCSV/XLSX â†’ 130æ›²Ã—4 â†’ æ—¢å­˜ãƒ‰ãƒ©ãƒ•ãƒˆã¸ä¸Šæ›¸ãï¼‰ ***/
function getPlaylistId(input){
  const v=(input||"").trim();
  const m=v.match(/playlist\/([A-Za-z0-9]+)/);
  return m?m[1]:v;
}
function csvParse(text){
  const rows=[]; let i=0, cur="", inQ=false, row=[];
  while(i<text.length){
    const ch=text[i];
    if(ch==='\"'){ if(inQ && text[i+1]==='\"'){ cur+='\"'; i++; } else { inQ=!inQ; } }
    else if(ch===',' && !inQ){ row.push(cur); cur=""; }
    else if((ch==='\n' || ch==='\r') && !inQ){
      if(ch==='\r' && text[i+1]==='\n') i++;
      row.push(cur); rows.push(row); row=[]; cur="";
    }else{ cur+=ch; }
    i++;
  }
  if(cur.length||row.length) { row.push(cur); rows.push(row); }
  const header=rows.shift().map(h=>h.trim());
  return rows.map(r=>Object.fromEntries(header.map((h,idx)=>[h,(r[idx]??"").trim()])));
}
async function readFileAny(file){
  if(!file) throw new Error("ãƒ•ã‚¡ã‚¤ãƒ«æœªé¸æŠ");
  const buf=await file.arrayBuffer();
  const name=(file.name||"").toLowerCase();
  if((name.endsWith(".xlsx")||name.endsWith(".xls")) && window.XLSX && XLSX.read){
    const wb=XLSX.read(buf,{type:"array"});
    const ws=wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(ws,{defval:""});
  }else{
    const text=new TextDecoder("utf-8").decode(buf);
    return csvParse(text);
  }
}
const low = s => (s||"").toString().toLowerCase();
const normISRC = s => low(s).replace(/\s|-/g,"").toUpperCase();
const normTitle = s => low(s).replace(/[\s\-\(\)\[\]\{\}_]+/g," ").trim();

function detectCols(rows){
  const heads = Object.keys(rows[0]||{});
  const find = (alts)=> heads.find(h => alts.some(a=> low(h).includes(a)));
  return {
    TITLE:  find(["track title","title","track name","original file name"])||heads[0],
    ARTIST: find(["track primary artists","primary artists","artists","artist"]),
    ALBUM:  find(["album title","release name","album"]),
    FORMAT: find(["album format","format"]),
    ISRC:   find(["isrc"]),
    UPC:    find(["upc"]),
    DATE:   find(["original release date","release date","date"]),
    GENRE:  find(["track main genre","main genre","genre"]),
    SUBGEN: find(["track main subgenre","main subgenre","sub-genre","subgenre"]),
    REMIX:  find(["remixer"])
  };
}
const remixRe=/\bremix(ed)?\b/i, mixOnlyRe=/\b(?:dj\s*)?mix\b/i;
const breaksRe=/\b(breaks?|break[-\s]?beat|big\s*beat|nu[-\s]*breaks?|electro[-\s]*breaks?|progressive\s*breaks?|funky[-\s]*breaks?|psy[-\s]*breaks?|acid\s*breaks?)\b/i;
function isRemixOnly(row,C){
  const t=row[C.TITLE]||"", r=row[C.REMIX]||"";
  const hasRemix = remixRe.test(t)||!!r;
  const hasMix   = mixOnlyRe.test(t);
  return hasRemix && !(hasMix && !/remix/i.test(t));
}
function isBreaks(row,C){
  const g=`${row[C.GENRE]||""} ${row[C.SUBGEN]||""}`, t=row[C.TITLE]||"", a=row[C.ALBUM]||"";
  return breaksRe.test(g)||breaksRe.test(t)||breaksRe.test(a);
}
function yearOK(row,C){
  const d=((row[C.DATE]||"")+"").slice(0,10);
  const y= parseInt(d.slice(0,4),10);
  return !isNaN(y)? y>=2010 : true;
}
function bucketByRecency(rows,C){
  const ms=rows.map(r=>Date.parse((r[C.DATE]||"")+"")||null).filter(Boolean);
  const min=Math.min(...ms), max=Math.max(...ms);
  return r=>{
    const t=Date.parse((r[C.DATE]||"")+"")||((min+max)/2);
    const z=(t-min)/Math.max(1,(max-min));
    return z;
  };
}
function styleBonus(row,C,region){
  const g=low(`${row[C.GENRE]||""} ${row[C.SUBGEN]||""}`);
  if(region==="EU"   && /(electro|tech|industrial|progressive)/.test(g)) return 0.05;
  if(region==="UK"   && /(rave|nu\s*break|breakbeat)/.test(g))           return 0.05;
  if(region==="US"   && /(electro|bass|funky)/.test(g))                   return 0.05;
  if(region==="WORLD"&& /(melod|psy)/.test(g))                            return 0.03;
  return 0;
}
function remixerTag(row,C){
  const r=(row[C.REMIX]||"").trim().toLowerCase();
  if(r) return r;
  const m=(row[C.TITLE]||"").match(/\((.+?)\s+remix\)/i);
  return m? m[1].trim().toLowerCase() : "";
}
function buildMetricScore(metrics){
  const cols = Object.keys(metrics[0]||{});
  const isSaveRate = c => /save/i.test(c) && /(rate|ç‡)/i.test(c);
  const isPlays    = c => /(play|å†ç”Ÿ)/i.test(c) && !/rate/i.test(c);
  const srCols=cols.filter(isSaveRate), plCols=cols.filter(isPlays);
  const zminmax = arr=>{
    const v=arr.map(x=>Number(x)).filter(x=>!isNaN(x));
    if(v.length<3) return arr.map(()=>0.5);
    const mn=Math.min(...v), mx=Math.max(...v);
    if(mx===mn) return arr.map(()=>0.5);
    return arr.map(x=> isNaN(Number(x))?0.5 : (Number(x)-mn)/(mx-mn));
  };
  const srAvg = srCols.length ? metrics.map(r=> {
    const zs = srCols.map(c=>zminmax(metrics.map(rr=>rr[c])) );
    const i  = metrics.indexOf(r);
    return zs.map(z=>z[i]).reduce((a,b)=>a+b,0)/zs.length;
  }) : metrics.map(()=>0.5);
  const plAvg = plCols.length ? metrics.map(r=> {
    const zs = plCols.map(c=>zminmax(metrics.map(rr=>rr[c])) );
    const i  = metrics.indexOf(r);
    return zs.map(z=>z[i]).reduce((a,b)=>a+b,0)/zs.length;
  }) : metrics.map(()=>0.5);
  return srAvg.map((v,i)=> 0.55*v + 0.45*plAvg[i]);
}

async function fetchDraftPinIds(playlistId){
  const pins=[];
  if(!playlistId) return pins;
  try{
    let url=`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100&offset=0`;
    while(url && pins.length<150){
      const d=await callSpotifyJSON(url,{}, {tag:`get pins ${playlistId}`});
      (d.items||[]).forEach(it=>{ const id=it?.track?.id; if(id) pins.push(id); });
      url=d.next||null;
    }
  }catch(_){}
  return [...new Set(pins)].slice(0,40); // ãƒ”ãƒ³ã¯æœ€å¤§40æ›²ã¾ã§
}

async function buildFromFiles(){
  try{
    const fCsv=el('fileSourceCsv').files[0];
    const fMet=el('fileMetrics').files[0];
    if(!fCsv||!fMet){ alert("CSVã¨åˆ†æãƒ‡ãƒ¼ã‚¿ã®ä¸¡æ–¹ã‚’é¸ã‚“ã§ãã ã•ã„"); return; }
    log("ãƒ•ã‚¡ã‚¤ãƒ«èª­è¾¼ä¸­â€¦");
    const [src, met] = await Promise.all([readFileAny(fCsv), readFileAny(fMet)]);
    if(!src.length){ throw new Error("ã‚½ãƒ¼ã‚¹CSVãŒç©ºã§ã™"); }
    const C = detectCols(src);

    // 1) ãƒ•ã‚£ãƒ«ã‚¿
    let pool = src.filter(r=> isRemixOnly(r,C) && isBreaks(r,C) && yearOK(r,C));
    if(pool.length<130) pool = src.filter(r=> isRemixOnly(r,C) && yearOK(r,C));
    log(`å€™è£œ ${pool.length} ä»¶`);

    // 2) æŒ‡æ¨™çµåˆï¼ˆISRCâ†’ã‚¿ã‚¤ãƒˆãƒ«ï¼‰
    const metByISRC=new Map(), metByTitle=new Map();
    const mHeads=Object.keys(met[0]||{});
    const mISRC = mHeads.find(h=> /isrc/i.test(h));
    const mTitle= mHeads[0];
    met.forEach(r=>{
      if(mISRC && r[mISRC]) metByISRC.set(normISRC(r[mISRC]), r);
      if(mTitle && r[mTitle]) metByTitle.set(normTitle(r[mTitle]), r);
    });

    const metricRows = pool.map(r=>{
      const kISRC = C.ISRC && r[C.ISRC] ? metByISRC.get(normISRC(r[C.ISRC])) : null;
      const kTitle= metByTitle.get(normTitle(r[C.TITLE]||"")) || null;
      return kISRC || kTitle || {};
    });
    const metricScore = buildMetricScore(metricRows);
    const recF = bucketByRecency(pool, C);
    const rec = pool.map(r=> recF(r));
    const balanced = metricScore.map((v,i)=> 0.55*v + 0.45*rec[i]);

    // 3) per-release cap=1ï¼ˆSingle/EPã®ã¿åˆ¶é™ï¼‰
    const formatIs = s=> /^(single|ep|e\.p\.|eps)$/i.test((s||"")+"");
    const capKey = r => (C.UPC && r[C.UPC]) ? r[C.UPC] : (r[C.ALBUM]||"");
    const scored = pool.map((r,i)=> ({row:r, score:balanced[i]}));
    const singles = scored.filter(x=> formatIs(x.row[C.FORMAT]));
    const albums  = scored.filter(x=> !formatIs(x.row[C.FORMAT]));
    const keepSingles = [...new Map(singles
        .sort((a,b)=>b.score-a.score)
        .map(x=> [capKey(x.row), x])
    ).values()];
    const capped = keepSingles.concat(albums).sort((a,b)=>b.score-a.score);

    // 4) åœ°åŸŸåˆ¥ã‚¹ã‚³ã‚¢ + â€œã©å®šç•ªCore 65â€ + æ®‹ã‚Š
    const regions=["EU","UK","US","WORLD"];
    const byRegion = {};
    for(const reg of regions){
      const withBias = capped.map(x=>{
        const bias = styleBonus(x.row, C, reg);
        return {...x, scoreReg: x.score + bias};
      }).sort((a,b)=>b.scoreReg-a.scoreReg);
      const core65 = new Set(withBias.slice(0,65).map(x=>x.row));
      const seenRemix=new Set();
      const rest = [];
      for(const x of withBias){
        if(core65.has(x.row)) continue;
        const tag = remixerTag(x.row,C);
        if(seenRemix.has(tag)) { if(Math.random()<0.5) continue; }
        seenRemix.add(tag);
        rest.push(x.row);
        if(rest.length>=220) break;
      }
      const pick = [...core65, ...rest].slice(0, 220);
      byRegion[reg] = pick;
    }

    // 5) ãƒ‰ãƒ©ãƒ•ãƒˆã®ãƒ”ãƒ³ã‚’å–å¾—ï¼ˆã‚ã‚Œã°å„ªå…ˆï¼‰
    const pinInputs={ EU:el('plEU').value, UK:el('plUK').value, US:el('plUS').value, WORLD:el('plWORLD').value };
    const pinIds = {};
    for(const reg of regions){
      const pid=getPlaylistId(pinInputs[reg]);
      pinIds[reg] = pid? await fetchDraftPinIds(pid) : [];
      if(pinIds[reg].length) log(`${reg}: ç¾è¡Œãƒ‰ãƒ©ãƒ•ãƒˆã‹ã‚‰ PIN ${pinIds[reg].length} æ›²`);
    }

    // 6) Spotifyæ¤œç´¢ã§URIè§£æ±ºï¼ˆISRCâ†’ã‚¿ã‚¤ãƒˆãƒ«fallbackï¼‰
    async function searchOne(row){
      const isrc = C.ISRC && row[C.ISRC] ? normISRC(row[C.ISRC]) : "";
      if(isrc){
        try{
          const q=`isrc:${encodeURIComponent(isrc)}`;
          const d=await callSpotifyJSON(`https://api.spotify.com/v1/search?type=track&limit=1&q=${q}`,{}, {tag:"search:isrc"});
          const t=d?.tracks?.items?.[0]; if(t&&t.uri) return t;
        }catch(_){}
      }
      const title=(row[C.TITLE]||"").replace(/\s+/g," ").trim();
      const artist=(row[C.ARTIST]||"").replace(/\s+/g," ").trim();
      const qParts=[];
      if(title) qParts.push(`track:"${title}"`);
      if(artist) qParts.push(`artist:"${artist}"`);
      qParts.push("remix");
      qParts.push("year:2010-2035");
      const q=encodeURIComponent(qParts.join(" "));
      const d=await callSpotifyJSON(`https://api.spotify.com/v1/search?type=track&limit=3&q=${q}`,{}, {tag:"search:title"});
      const items=d?.tracks?.items||[];
      items.sort((a,b)=>{
        const as = (a.name+" "+a.artists.map(x=>x.name).join(" ")).toLowerCase();
        const bs = (b.name+" "+b.artists.map(x=>x.name).join(" ")).toLowerCase();
        const ar = +(as.includes("remix"));
        const br = +(bs.includes("remix"));
        return br-ar;
      });
      return items[0]||null;
    }

    // 7) å„ãƒªãƒ¼ã‚¸ãƒ§ãƒ³: è§£æ±ºâ†’featuresâ†’ä¸¦ã¹ï¼ˆãƒªãƒŸã‚­ã‚µãƒ¼é€£ç¶šç¦æ­¢ã€ãƒ”ãƒ³å°Šé‡ï¼‰
    const editionURIs={}, editionIDs={};
    for(const reg of regions){
      log(`URIè§£æ±ºä¸­: ${reg}`);
      const rows = byRegion[reg];
      const resolved=[];
      for(const r of rows){
        try{ const t=await searchOne(r); if(t) resolved.push(t); }catch(_){}
        if(resolved.length>=190) break;
      }
      const ids = [...new Set(resolved.map(t=>t.id))].slice(0,200);
      // ãƒ”ãƒ³IDã¨çªåˆï¼ˆè§£æ±ºæ¸ˆã¿ã®ä¸­ã«å­˜åœ¨ã™ã‚‹åˆ†ã ã‘ï¼‰
      const draftPins = (pinIds[reg]||[]).filter(id=> ids.includes(id)).slice(0,40);

      const featsMap = new Map();
      for(let i=0;i<ids.length;i+=100){
        const part=ids.slice(i,i+100);
        try{
          const f=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features?ids=${part.join(",")}`,{}, {tag:"features"});
          (f.audio_features||[]).forEach((x,j)=>{ if(x) featsMap.set(part[j],x); });
        }catch(_){}
      }
      const energy = id => (featsMap.get(id)?.energy ?? 0.58);
      const sortedE = ids.map(energy).sort((a,b)=>a-b);
      const q1=sortedE[Math.floor(sortedE.length*0.25)]||0.25;
      const q2=sortedE[Math.floor(sortedE.length*0.50)]||0.50;
      const q3=sortedE[Math.floor(sortedE.length*0.75)]||0.75;
      const bucket = e => e<=q1?0: e<=q2?1: e<=q3?2:3;

      // ãƒ”ãƒ³ä½ç½®ï¼ˆCoreå¯„ã‚Šï¼‰â€” ãƒ‰ãƒ©ãƒ•ãƒˆãƒ”ãƒ³ãŒå„ªå…ˆã€è¶³ã‚Šãªã‘ã‚Œã°ä¸Šä½ã‹ã‚‰è£œå®Œ
      const pinsPos=[1,5,20,40,65,90,110,130];
      const pinIdsResolved = draftPins.length ? draftPins
        : ids.slice(0, Math.min(8, Math.floor(130*0.5/8)*8 || 8));

      const pinSet=new Set(pinIdsResolved);
      const bins=[[],[],[],[]];
      resolved.forEach(t=>{
        if(pinSet.has(t.id)) return;
        bins[bucket(energy(t.id))].push(t);
      });
      bins.forEach(b=>b.sort((a,b)=> (b.popularity||0)-(a.popularity||0)));

      const seq=new Array(130).fill(null);
      // ãƒ”ãƒ³é…ç½®ï¼ˆè§£æ±ºé †ã®ã¾ã¾ï¼‰
      for(let i=0;i<Math.min(pinIdsResolved.length,pinsPos.length);i++){
        const id=pinIdsResolved[i];
        const t=resolved.find(x=>x.id===id);
        if(t) seq[pinsPos[i]-1]=t;
      }
      function remixTagOf(t){
        const name=(t?.name||"")+" "+(t?.artists?.map(x=>x.name).join(" ")||"");
        const m=name.match(/\((.+?)\s+remix\)/i);
        return m? m[1].toLowerCase() : "";
      }
      function pick(prev){
        const prevTag=prev?remixTagOf(prev):"";
        for(let r=0;r<4;r++){
          const bi=r;
          const arr=bins[bi];
          for(let i=0;i<arr.length;i++){
            const t=arr[i], tag=remixTagOf(t);
            if(prevTag && tag && prevTag===tag) continue;
            arr.splice(i,1);
            return t;
          }
        }
        for(let bi=0;bi<4;bi++){
          if(bins[bi].length) return bins[bi].shift();
        }
        return null;
      }
      for(let i=0;i<130;i++){
        if(seq[i]) continue;
        const prev=i?seq[i-1]:null;
        const t=pick(prev);
        if(!t) break;
        seq[i]=t;
      }
      const final=seq.filter(Boolean).slice(0,130);
      editionURIs[reg]=final.map(t=>`spotify:track:${t.id}`);
      editionIDs[reg]=final.map(t=>t.id);
      log(`${reg} å®Œæˆ: ${final.length} æ›²`);
    }

    // ä¿å­˜
    window.__editionURIs = editionURIs;
    el('btnUpdateFromFiles').disabled=false;
    alert("OKï¼š4ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ã®æœ€çµ‚å€™è£œã‚’ä½œã‚Šã¾ã—ãŸã€‚ã€å„ç‰ˆã‚’æ—¢å­˜Playlistã«ä¸Šæ›¸ãã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚");
  }catch(e){
    log("ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼: "+(e.message||e));
    alert("ã‚¨ãƒ©ãƒ¼: "+(e.message||e));
  }
}

async function updateFromFiles(){
  if(!window.__editionURIs){ alert("å…ˆã«ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æœ€çµ‚ç‰ˆã€ã‚’ä½œã£ã¦ãã ã•ã„"); return; }
  const map={
    EU:   getPlaylistId(el('plEU').value),
    UK:   getPlaylistId(el('plUK').value),
    US:   getPlaylistId(el('plUS').value),
    WORLD:getPlaylistId(el('plWORLD').value)
  };
  for(const reg of Object.keys(map)){
    const pid=map[reg]; if(!pid) continue;
    const uris = window.__editionURIs[reg]||[];
    if(!uris.length){ log(`${reg}: æ¥½æ›²0`); continue; }
    log(`${reg}: ${uris.length}æ›²ã‚’ ${pid} ã¸åæ˜ ä¸­â€¦`);
    const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
    await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${pid}/tracks`,{method:"PUT",body:JSON.stringify({uris:chunks[0]||[]})},{tag:`PUT ${reg}`,expectJSON:false});
    for(let i=1;i<chunks.length;i++){
      await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${pid}/tracks`,{method:"POST",body:JSON.stringify({uris:chunks[i]})},{tag:`POST ${reg} #${i+1}`});
    }
    log(`${reg}: åæ˜ å®Œäº†`);
  }
  alert("4ã‚¨ãƒ‡ã‚£ã‚·ãƒ§ãƒ³ä¸Šæ›¸ãå®Œäº†ï¼");
}

/*** ã‚¯ãƒªãƒƒã‚¯å§”ä»»ï¼ˆPCç”¨ãƒœã‚¿ãƒ³ã¨ãƒ¢ãƒã‚¤ãƒ«ãƒ‰ãƒƒã‚¯é€£å‹•ï¼‰ + ç·Šæ€¥ç³» ***/
document.addEventListener('click', async (e)=>{
  const btn=e.target.closest('button, a.btn'); if(!btn) return;
  const id=btn.id||btn.getAttribute('href')||'(no-id)'; log(`â–¶ click: ${id}`);
  if(btn.tagName==='A') return;
  e.preventDefault();
  try{
    switch(id){
      case 'mbFast': return void el('btnFast').click();
      case 'mbTrim': return void el('btnTrim').click();
      case 'mbBalance': return void el('btnBalance').click();
      case 'mbBuild': return void el('btnBuildEditions').click();
      case 'mbCommit': return void el('btnCommit').click();
      case 'btnMe': {
        try{ const me=await callSpotifyJSON('https://api.spotify.com/v1/me',{}, {tag:'/me'}); el('hudUser').textContent=`${me.display_name||'(no name)'} / ${me.id}`; }
        catch(err){ alert('Spotify æ¥ç¶šãŒå¿…è¦ã§ã™'); log('ã‚¨ãƒ©ãƒ¼: '+(err.message||err)); }
        break;
      }
      case 'btnSignOut': {
        try{ ['sp_access_token','sp_expires_at','sp_refresh_token','sp_scope','sp_token_type'].forEach(k=>sessionStorage.removeItem(k)); renderStatus(); log('ä¿å­˜ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‰Šé™¤ã—ã¾ã—ãŸ'); }
        catch(err){ log('ã‚¨ãƒ©ãƒ¼: '+(err.message||err)); }
        break;
      }
      case 'btnFast': await doFastBuild(); break;
      case 'btnTrim': await doTrim(); break;
      case 'btnBalance': await doBalance(); break;
      case 'btnBuildEditions': await buildEditions(); break;
      case 'btnCommit': {
        const list=(finalSeq&&finalSeq.length)?finalSeq:trimmed;
        if(!list||!list.length) { alert('â‘¡Trim ã¾ãŸã¯ â‘¢Balanced ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„'); return; }
        const name=(el('plName').value || ((finalSeq&&finalSeq.length)?'TDCS â€“ Breaks Remix Only (Balanced)':'TDCS â€“ Breaks Remix Only (Trim)')).trim();
        const desc=(el('plDesc').value || ((finalSeq&&finalSeq.length)?'Breaks/Breakbeaté™å®šãƒ»2010+ãƒ»Remixã®ã¿ãƒ»Pinså›ºå®šãƒ»Balanced':'Breaks/Breakbeaté™å®šãƒ»2010+ãƒ»Remixã®ã¿ãƒ»Trim')).trim();
        const isPublic=el('plPublic').value==='true';
        const existing=el('existingId').value.trim()||null;
        const uris=list.map(t=>`spotify:track:${t.id}`);
        await putPlaylist(name, desc, isPublic, uris, existing);
        break;
      }
      case 'btnBuildFromFiles': await buildFromFiles(); break;
      case 'btnUpdateFromFiles': await updateFromFiles(); break;
      case 'btnRepair': {
        try{
          ['sp_access_token','sp_expires_at','sp_refresh_token','sp_scope','sp_token_type'].forEach(k=>sessionStorage.removeItem(k));
          renderStatus(); log('ğŸ”§ ç·Šæ€¥ãƒªã‚»ãƒƒãƒˆ: ãƒˆãƒ¼ã‚¯ãƒ³é¡ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ');
          alert('ãƒªã‚»ãƒƒãƒˆå®Œäº†ã€‚å¿…è¦ãªã‚‰ Connect ã—ã¦ãã ã•ã„ã€‚');
        }catch(err){ log('ã‚¨ãƒ©ãƒ¼: '+(err.message||err)); }
        break;
      }
    }
  }catch(err){ log('ã‚¨ãƒ©ãƒ¼: '+(err.message||err)); }
});

/*** èµ·å‹• ***/
(function boot(){
  log(`âœ… index loaded: ${location.href}`);
  renderStatus();
  try{ if (window.matchMedia('(max-width: 720px)').matches) el('logBox').open=false; }catch(_){}
  const mirror=()=>['mbTrim','mbBalance','mbBuild','mbCommit'].forEach((id,i)=>{
    const src=['btnTrim','btnBalance','btnBuildEditions','btnCommit'][i];
    const s=el(src), d=el(id); if(s && d) d.disabled=s.disabled;
  });
  const mo=new MutationObserver(mirror);
  ['btnTrim','btnBalance','btnBuildEditions','btnCommit'].forEach(id=>{
    const b=el(id); if(!b) return;
    mo.observe(b,{attributes:true,attributeFilter:['disabled']});
  });
})();
</script>
</body>
</html>
