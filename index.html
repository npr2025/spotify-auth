<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">

<!-- 安全メタ（inline JS 許可 / 公式ドメインのみ接続） -->
<meta name="robots" content="noindex,nofollow">
<meta name="referrer" content="no-referrer">
<meta name="description" content="Spotify公式APIでBreaks/Breakbeat（2010+）Remix限定の100曲プレイリストをUK/EU/US/Worldの4エディションで高速構築します。">
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               connect-src 'self' https://accounts.spotify.com https://api.spotify.com;
               img-src 'self' data:;
               style-src 'self' 'unsafe-inline';
               script-src 'self' 'unsafe-inline';
               frame-ancestors 'none';
               base-uri 'self';
               form-action 'self' https://accounts.spotify.com;">

<title>Editions Builder – Breaks Remix Only 2010+ (Fast Preset)</title>
<style>
  :root{--w:1100px}
  *{box-sizing:border-box}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:var(--w);margin:32px auto;padding:0 12px}
  h1{margin:0 0 10px}
  fieldset{border:1px solid #E4E7EC;border-radius:12px;padding:12px 12px 14px;margin:12px 0}
  legend{padding:0 6px;color:#101828}
  label{display:block;margin:8px 0 4px}
  input,select{width:100%;padding:8px 10px;border:1px solid #D0D5DD;border-radius:8px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
  .row>*{flex:1 1 240px}
  button,a.btn{display:inline-block;padding:9px 12px;border:1px solid #D0D5DD;border-radius:8px;background:#F9FAFB;text-decoration:none;cursor:pointer}
  button:disabled{opacity:.55;cursor:not-allowed}
  .note{font-size:12px;color:#667085}
  .muted{color:#667085}
  .pill{display:inline-block;padding:2px 8px;border:1px solid #D0D5DD;border-radius:999px;font-size:12px;margin-left:6px}
  .grid4{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
  .tight{margin-top:4px}
  #log{white-space:pre-wrap;background:#0b1220;color:#cfe3ff;padding:12px;border-radius:8px;max-height:420px;overflow:auto}

  /* HUD */
  .hud{border:1px solid #E4E7EC;border-radius:12px;padding:12px;margin:10px 0}
  .hud-top{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .hud-card{border:1px solid #EAECF0;border-radius:10px;padding:10px}
  .hud-kv{display:grid;grid-template-columns:160px 1fr;gap:6px 10px}
  .hud-kv .k{color:#475467}.hud-kv .v{color:#101828}
  .bar{display:flex;align-items:center;gap:10px}
  progress{width:280px;height:16px}
  .phase{display:grid;grid-template-columns:repeat(8,1fr);gap:6px;margin-top:8px}
  .badge{border-radius:8px;padding:6px 8px;border:1px solid #EAECF0;background:#F9FAFB;font-size:12px;display:flex;gap:6px;align-items:center;justify-content:center}
  .b-run{border-color:#BBD6FF;background:#EEF5FF;color:#0D5BD6}
  .b-ok{border-color:#C9F0D0;background:#F1FFF4;color:#1A7F37}
  .b-err{border-color:#F7C5C0;background:#FFF2F1;color:#B42318}
  .b-idle{color:#667085}
  .hud-counters{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:8px}
  .ct{border:1px solid #EAECF0;border-radius:10px;padding:8px}
  .ct .k{font-size:12px;color:#475467}
  .ct .v{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;color:#101828}
  .warn{color:#b54708}
</style>
</head>
<body>
<h1>Editions Builder（Breaks限定・2010+・Remixのみ）<span class="pill">Fast Preset</span></h1>
<p class="note">通信先は <code>accounts.spotify.com</code> / <code>api.spotify.com</code> のみ。パスワード等は扱いません。</p>

<!-- HUD -->
<div class="hud">
  <div class="hud-top">
    <div class="hud-card">
      <div class="hud-kv">
        <div class="k">接続ユーザー</div><div class="v" id="hudUser">未接続</div>
        <div class="k">トークン期限</div><div class="v" id="hudToken">—</div>
        <div class="k">現在フェーズ</div>
        <div class="v bar">
          <progress id="prog" value="0" max="100"></progress>
          <span id="progTxt" class="muted">準備OK</span>
          <button id="btnRepair" style="margin-left:auto">🔧 緊急リセット</button>
        </div>
      </div>
      <div class="phase" id="phaseRow">
        <div class="badge b-idle" data-p="albums">Albums</div>
        <div class="badge b-idle" data-p="tracks">Tracks</div>
        <div class="badge b-idle" data-p="details">Details</div>
        <div class="badge b-idle" data-p="features">Features</div>
        <div class="badge b-idle" data-p="artists">Artists</div>
        <div class="badge b-idle" data-p="filter">Filter</div>
        <div class="badge b-idle" data-p="trim">Trim</div>
        <div class="badge b-idle" data-p="balance">Balance</div>
      </div>
      <div class="hud-counters">
        <div class="ct"><div class="k">市場</div><div class="v" id="c_markets">—</div></div>
        <div class="ct"><div class="k">アルバム（処理/対象）</div><div class="v" id="c_albums">0 / 0</div></div>
        <div class="ct"><div class="k">収集トラック（累計）</div><div class="v" id="c_tracks">0</div></div>
        <div class="ct"><div class="k">候補ID（重複除去後）</div><div class="v" id="c_cands">0</div></div>
      </div>
      <div class="note" id="mini">mini-status…</div>
      <div class="warn" id="warn"></div>
    </div>
    <div class="hud-card">
      <div class="row">
        <div>
          <a class="btn" href="./auth.html">Connect with Spotify</a>
          <button id="btnMe">/v1/me</button>
          <button id="btnSignOut">切断（保存トークン削除）</button>
        </div>
      </div>
      <div class="note" id="status">未接続（上のボタンから開始）</div>
    </div>
  </div>
</div>

<!-- エディション固定（4択） -->
<fieldset>
  <legend>エディション（UK / US / EU / World）</legend>
  <div class="row">
    <div>
      <label class="tight"><input type="checkbox" class="ed" value="UK" checked> UK</label>
      <label class="tight"><input type="checkbox" class="ed" value="US" checked> US</label>
      <label class="tight"><input type="checkbox" class="ed" value="EU" checked> EU</label>
      <label class="tight"><input type="checkbox" class="ed" value="WORLD" checked> World</label>
      <div class="note">available_markets を考慮し、各エディションが100曲で着地するよう段階的に緩和。</div>
    </div>
    <div>
      <label>ベース名（末尾に [UK Edition] 等を自動付与）</label>
      <input id="baseName" value="TDCS – Breaks Remix Only 100 (2010+)" />
    </div>
    <div>
      <label>説明文（共通）</label>
      <input id="baseDesc" value="Breaks/Breakbeat限定・2010+・Remixのみ・Pins固定・バランス配置" />
    </div>
    <div>
      <label>公開設定</label>
      <select id="isPublic"><option value="false" selected>非公開</option><option value="true">公開</option></select>
    </div>
  </div>
</fieldset>

<!-- 収集ポリシー（催促案デフォルト） -->
<fieldset>
  <legend>収集ポリシー（Fastデフォルト）</legend>
  <div class="row">
    <div>
      <label>アーティストID</label>
      <input id="artistId" value="55fvQ5I2IZUfcFT2DV02T3" />
      <div class="note">The Darrow Chem Syndicate（変更可）</div>
    </div>
    <div><label>最新から取るアルバム枚数</label><input id="albumRecent" type="number" min="8" max="80" value="20" /></div>
    <div><label>旧作サンプル比率（0–0.8）</label><input id="oldAlbumRatio" type="number" step="0.05" min="0" max="0.8" value="0.20" /></div>
    <div><label>Era Mix（古め混合率 0–0.8）</label><input id="ratioOld" type="number" step="0.05" min="0" max="0.8" value="0.25" /></div>
  </div>
  <div class="row">
    <div><label>人気の重み</label><input id="wPopularity" type="number" step="0.05" min="0" max="1" value="0.6" /></div>
    <div><label>新しさの重み</label><input id="wRecent" type="number" step="0.05" min="0" max="1" value="0.4" /></div>
    <div><label>最終曲数</label><input id="finalSize" type="number" min="80" max="100" value="100" /></div>
  </div>
  <div class="row">
    <div>
      <label>対象リリース種別</label>
      <div class="tight">
        <label><input type="checkbox" class="rtype" value="ALBUM" checked> Album</label>
        <label><input type="checkbox" class="rtype" value="SINGLE" checked> Single</label>
        <label><input type="checkbox" class="rtype" value="EP" checked> EP</label>
        <label><input type="checkbox" class="rtype" value="COMPILATION" checked> Compilation</label>
      </div>
      <div class="note">EP は「album_type: single かつ曲数≥3」またはタイトルに“EP”。</div>
    </div>
    <div><label>ターゲット候補数（Trim上限）</label><input id="targetPool" type="number" min="120" max="220" value="130" /></div>
  </div>

  <div class="grid4">
    <div><label>#1 ピン</label><input id="pin1"  value="0ueNjvhtXGDFkJQ5WBQ4mE"></div>
    <div><label>#5 ピン</label><input id="pin5"  value="63dYSEftdSYwMAFBNfQYsA"></div>
    <div><label>#40 ピン</label><input id="pin40" value="3NQuIFfQPhTICaXGYe5dAt"></div>
    <div><label>#60 ピン</label><input id="pin60" value="7ltcrdlVsXyU5HU9VCAj6P"></div>
  </div>
  <div class="row">
    <div>
      <button id="btnFast">① 収集（FAST Build）</button>
      <button id="btnTrim" disabled>② Trim（120–130）</button>
      <button id="btnBalance" disabled>③ Balanced 100</button>
    </div>
  </div>
</fieldset>

<!-- 一括エディション -->
<fieldset>
  <legend>④ UK / US / EU / World をまとめて作成</legend>
  <div class="row"><div><button id="btnBuildEditions" disabled>4エディションを作成</button></div></div>
</fieldset>

<!-- 単発作成 -->
<fieldset>
  <legend>（任意）単発で作成/更新</legend>
  <div class="row">
    <div><label>プレイリスト名</label><input id="plName" placeholder="TDCS – Breaks Remix Only 100 (2010+)" /></div>
    <div><label>説明文</label><input id="plDesc" placeholder="Breaks/Breakbeat限定・2010+・Remixのみ・Pins固定・バランス配置" /></div>
    <div><label>公開設定</label><select id="plPublic"><option value="false" selected>非公開</option><option value="true">公開</option></select></div>
  </div>
  <div class="row">
    <div><label>既存プレイリストID（空＝新規）</label><input id="existingId" placeholder="例）37i9dQZF1DX..." /></div>
    <div><label>API最小間隔ms</label><input id="gap" type="number" value="1000" /></div>
    <div><label>最大リトライ</label><input id="maxRetry" type="number" value="5" /></div>
  </div>
  <div class="row"><div><button id="btnCommit" disabled>⑤ 作成/更新する</button></div></div>
</fieldset>

<h2>ログ</h2>
<pre id="log"></pre>

<script>
"use strict";

/* 固定・キー */
const CLIENT_ID="1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI="https://npr2025.github.io/spotify-auth/callback.html";
const K={access:"sp_access_token",type:"sp_token_type",expAt:"sp_expires_at",refresh:"sp_refresh_token",scope:"sp_scope"};
const BUILD_LOCK_KEY="sp_build_lock_v1"; const TAB_ID=Math.random().toString(36).slice(2);

/* UI util */
const el=id=>document.getElementById(id);
const log=m=>{const d=new Date().toLocaleTimeString(); el("log").textContent+=`[${d}] ${m}\n`; el("log").scrollTop=el("log").scrollHeight;};
const setProg=(v,label)=>{ el("prog").value=v; el("progTxt").textContent=label||""; el("mini").textContent=label||""; };
const warn=m=>{el("warn").textContent=m||"";};

/* HUD */
const HUD={
  counters:{markets:"—", albumsDone:0, albumsTotal:0, tracks:0, cands:0},
  phase(name, status){ const box=[...document.querySelectorAll('.phase .badge')].find(b=>b.dataset.p===name); if(!box) return; box.classList.remove('b-idle','b-run','b-ok','b-err'); box.classList.add(status==='run'?'b-run':status==='ok'?'b-ok':status==='err'?'b-err':'b-idle'); },
  countersRender(){ el("c_markets").textContent=this.counters.markets; el("c_albums").textContent=`${this.counters.albumsDone} / ${this.counters.albumsTotal}`; el("c_tracks").textContent=String(this.counters.tracks); el("c_cands").textContent=String(this.counters.cands); }
};

/* 接続表示 */
function renderStatus(){
  try{
    const a=sessionStorage.getItem(K.access); const e=parseInt(sessionStorage.getItem(K.expAt)||"0",10);
    if(!a){ el("status").textContent="未接続（上のボタンから開始）"; el("hudUser").textContent="未接続"; el("hudToken").textContent="—"; return; }
    const left=e-Date.now();
    if(left>0){ el("status").textContent="接続中 – 有効期限まで約 "+Math.floor(left/1000)+" 秒"; el("hudToken").textContent=`残り ${Math.floor(left/1000)}s`; }
    else{ el("status").textContent="トークン期限切れ（再接続してください）"; el("hudToken").textContent="期限切れ"; }
  }catch(err){ el("status").textContent="状態表示エラー: "+(err.message||err); }
}
window.addEventListener("error", e => log("SCRIPT ERROR: "+e.message));
window.addEventListener("unhandledrejection", e => log("UNHANDLED: "+(e?.reason?.message||e?.reason||"(no reason)")));

/* レート/リフレッシュ/HTTP */
let MIN_API_GAP_MS=1000, lastApiTs=0;
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
let refreshInflight=null;
async function ensureFreshToken(){
  const access=sessionStorage.getItem(K.access), expAt=parseInt(sessionStorage.getItem(K.expAt)||"0",10), refresh=sessionStorage.getItem(K.refresh);
  if(access && Date.now()<(expAt-5000)) return access;
  if(!refresh) return null;
  if(!refreshInflight){
    refreshInflight=(async()=>{
      let attempt=0;
      while(true){ attempt++;
        const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:refresh,redirect_uri:REDIRECT_URI})});
        if(res.status===429){const ra=parseInt(res.headers.get("Retry-After")||"1",10);await sleep((isNaN(ra)?1:Math.min(60,ra))*1000+200);continue;}
        if(res.status>=500 && attempt<=3){await sleep(Math.min(4000,500*Math.pow(2,attempt-1)));continue;}
        const txt=await res.text(); let data=null; try{data=JSON.parse(txt);}catch(_){}
        if(!res.ok) throw new Error("refresh failed: "+res.status+" "+txt);
        const expAt=Date.now()+data.expires_in*1000;
        sessionStorage.setItem(K.access,data.access_token);
        sessionStorage.setItem(K.type,data.token_type||"Bearer");
        sessionStorage.setItem(K.expAt,String(expAt));
        if(data.refresh_token) sessionStorage.setItem(K.refresh,data.refresh_token);
        if(data.scope) sessionStorage.setItem(K.scope,data.scope);
        renderStatus(); return data.access_token;
      }
    })().finally(()=>{refreshInflight=null;});
  }
  return refreshInflight;
}
function parse403Message(txt){ try{const j=JSON.parse(txt); return j?.error?.message||"";}catch(_){return "";} }
async function callSpotifyJSON(url,opts={}, {maxRetry=5,expectJSON=true,tag=""}={}){
  const wait=Math.max(0,MIN_API_GAP_MS-(Date.now()-lastApiTs)); if(wait) await sleep(wait);
  let token=await ensureFreshToken(); if(!token) throw new Error("No valid token. Connect again.");
  let attempt=0;
  while(true){
    attempt++;
    const headers=new Headers(opts.headers||{}); headers.set("Authorization","Bearer "+token); headers.set("Accept","application/json");
    if(opts.body && !(opts.body instanceof FormData) && !headers.has("Content-Type")) headers.set("Content-Type","application/json");
    const res=await fetch(url,{...opts,headers}); lastApiTs=Date.now();

    if(res.status===429 && attempt<=maxRetry){ const ra=parseInt(res.headers.get("Retry-After")||"1",10); await sleep((isNaN(ra)?1:Math.min(60,ra))*1000+200); continue; }
    if(res.status===401 && attempt===1){ token=await ensureFreshToken(); if(!token) throw new Error("Unauthorized and cannot refresh."); continue; }
    if(res.status===403){ const txt=await res.text(); const msg=parse403Message(txt); throw new Error(`${tag||"HTTP"} 403${msg?(": "+msg):""} ::RAW:: ${txt}`); }
    if(res.status>=500 && attempt<=maxRetry){ await sleep(Math.min(8000,700*Math.pow(2,attempt-1))); continue; }
    if(!res.ok){ const txt=await res.text(); throw new Error(`${tag||"HTTP"} ${res.status}: ${txt}`); }

    if(!expectJSON) return null;
    const txt=await res.text(); if(!txt) return {}; try{return JSON.parse(txt);}catch(_){return {};}
  }
}

/* 判定 */
function tokenize(name){ return (name||"").toLowerCase().replace(/[()[\]{}\-]/g," ").replace(/\s+/g," ").trim().split(" ").filter(Boolean); }
function isRemixOnlyTitle(name){
  const t=tokenize(name);
  const hasRemix=t.includes("remix")||t.includes("remixed")||t.includes("rmx");
  const hasMix = t.includes("mix") || (t.includes("dj")&&t.includes("mix")) || (t.includes("original")&&t.includes("mix")) || (t.includes("club")&&t.includes("mix")) || (t.includes("extended")&&t.includes("mix")) || (t.includes("continuous")&&t.includes("mix"));
  return hasRemix && !hasMix;
}
const breaksWordRe=/\b(breaks?|break[-\s]?beat|nu[-\s]?breaks?|big\s*beat|funky[-\s]*breaks?|electro[-\s]*breaks?|progressive\s*breaks?|psy[-\s]*breaks?|acid\s*breaks?)\b/i;
const genreOk=g=>/breakbeat|breaks?|big beat|nu skool breaks|electro breaks?|progressive breaks?|funky breaks?|psybreaks?|acid breaks?/i.test(g||"");
function yearFromDate(s){ if(!s) return 0; const y=parseInt(String(s).slice(0,4),10); return isNaN(y)?0:y; }

/* ロック */
const LOCK_TTL=120000; const now=()=>Date.now();
const readLock=k=>{try{return JSON.parse(localStorage.getItem(k)||"null");}catch(_){return null;}};
const writeLock=(k,o)=>localStorage.setItem(k,JSON.stringify(o));
function acquireLock(k){const cur=readLock(k),t=now(); if(!cur||(t-cur.ts)>LOCK_TTL){writeLock(k,{owner:TAB_ID,ts:t});return true;} return cur.owner===TAB_ID;}
function releaseLock(k){const cur=readLock(k); if(cur && cur.owner===TAB_ID) localStorage.removeItem(k);}

/* 可用性メモ */
const trackSeenBy=new Map(); // id -> Set(markets)
function markSeen(id,market){ let s=trackSeenBy.get(id); if(!s){s=new Set(); trackSeenBy.set(id,s);} s.add(market); }

/* Edition/Markets（強市場のみ / JP除外） */
const EDITIONS={
  UK:    { markets:["GB","IE"], anyOf:["GB"], suffix:" [UK Edition]" },
  US:    { markets:["US","CA"], anyOf:["US"], suffix:" [US Edition]" },
  EU:    { markets:["DE","FR","NL","ES","IT","SE","DK","FI","BE"], needCount:3, suffix:" [EU Edition]" },
  WORLD: { markets:["US","GB","DE","FR","NL","ES","IT","SE","AU","CA"], needPct:0.6, suffix:" [World Edition]" }
};

/* リリース種別 */
function needTypes(){ const s=new Set([...document.querySelectorAll(".rtype:checked")].map(x=>x.value)); return {wantAlbum:s.has("ALBUM"),wantSingle:s.has("SINGLE"),wantEP:s.has("EP"),wantComp:s.has("COMPILATION")}; }
function isEP(album){ const type=(album.album_type||"").toLowerCase(); const tracks=album.total_tracks||0; const name=(album.name||"").toLowerCase(); return (type==="single" && tracks>=3) || /\bep\b/.test(name); }
function matchReleaseType(album, types){ const t=(album.album_type||"").toLowerCase(); if(t==="album"&&types.wantAlbum) return true; if(t==="compilation"&&types.wantComp) return true; if(t==="single"){ if(types.wantEP&&isEP(album)) return true; if(types.wantSingle&&!isEP(album)) return true; } return false; }

/* 小道具 */
const chunkArr=(a,n)=>{const out=[]; for(let i=0;i<a.length;i+=n) out.push(a.slice(i,i+n)); return out;};

/* 詳細/特徴量/アーティスト */
async function fetchTracksBatched(ids){
  const uniq=[...new Set(ids)]; const results=[];
  async function fetchChunk(list,tagBase){
    try{
      const data=await callSpotifyJSON(`https://api.spotify.com/v1/tracks?ids=${list.join(",")}`,{}, {tag:`${tagBase}[${list.length}]`});
      (data.tracks||[]).forEach(t=>{ if(t) results.push(t); });
    }catch(e){
      if(String(e.message||"").includes(" 403") && list.length>1){
        const mid=Math.floor(list.length/2); await fetchChunk(list.slice(0,mid),tagBase+"a"); await fetchChunk(list.slice(mid),tagBase+"b");
      }else if(String(e.message||"").includes(" 403") && list.length===1){ log(`   × 403 skip track ${list[0]}`); }
      else throw e;
    }
  }
  const chunks=chunkArr(uniq,50);
  for(let i=0;i<chunks.length;i++){ setProg(44+Math.round((i/chunks.length)*8),`details ${i+1}/${chunks.length}`); await fetchChunk(chunks[i],`tracks#${i+1}`); }
  return results;
}
async function fetchFeaturesBatched(ids){
  const uniq=[...new Set(ids)];
  const feats=new Map();
  const stats={batchOK:0,batchNull:0,singleOK:0,singleNG:0,analysisOK:0,analysisNG:0,neutral:0};
  const neutral=id=>({id,energy:0.58,valence:0.45,danceability:0.60,tempo:132,__fallback:"neutral"});
  async function tryBatch(list,tagBase){
    const data=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features?ids=${list.join(",")}`, {}, {tag:`${tagBase}[${list.length}]`});
    (data.audio_features||[]).forEach((f,i)=>{ const id=list[i]; if(f&&f.id){feats.set(f.id,f);stats.batchOK++;} else {feats.set(id,null);stats.batchNull++;} });
  }
  async function trySingle(id){
    let attempt=0; while(attempt<3){ attempt++;
      try{ const f=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features/${id}`, {}, {tag:`feature:${id}`});
        if(f&&f.id){ feats.set(id,f); stats.singleOK++; return; }
      }catch(e){ if(String(e.message||"").includes(" 403")){ await sleep(300*attempt); continue; } break; }
    }
    feats.set(id,null); stats.singleNG++;
  }
  async function tryAnalysis(id){
    let attempt=0; while(attempt<2){ attempt++;
      try{ const a=await callSpotifyJSON(`https://api.spotify.com/v1/audio-analysis/${id}`, {}, {tag:`analysis:${id}`});
        const tempo=a?.track?.tempo||132; feats.set(id,{id,energy:0.58,valence:0.45,danceability:0.60,tempo,__fallback:"analysis"}); stats.analysisOK++; return;
      }catch(e){ if(String(e.message||"").includes(" 403")){ await sleep(400*attempt); continue; } break; }
    }
    feats.set(id, neutral(id)); stats.analysisNG++; stats.neutral++;
  }
  const chunks=chunkArr(uniq,100);
  HUD.phase('features','run');
  for(let i=0;i<chunks.length;i++){ setProg(54+Math.round((i/chunks.length)*6), `features ${i+1}/${chunks.length}`); try{ await tryBatch(chunks[i], `features#${i+1}`);}catch{ chunks[i].forEach(id=>feats.set(id,null)); } }
  const needSingle=uniq.filter(id=>!feats.has(id) || feats.get(id)===null);
  for(const id of needSingle) await trySingle(id);
  const needAna=uniq.filter(id=>!feats.has(id) || feats.get(id)===null);
  for(const id of needAna) await tryAnalysis(id);
  log(`features fallback: batchOK=${stats.batchOK} / batchNull=${stats.batchNull} / singleOK=${stats.singleOK} / singleNG=${stats.singleNG} / analysisOK=${stats.analysisOK} / analysisNG=${stats.analysisNG} / neutral=${stats.neutral}`);
  HUD.phase('features','ok');
  return feats;
}
async function fetchArtistsGenresMapBatched(ids){
  const uniq=[...new Set(ids)]; const map=new Map();
  async function fetchChunk(list,tagBase){
    try{
      const data=await callSpotifyJSON(`https://api.spotify.com/v1/artists?ids=${list.join(",")}`,{}, {tag:`${tagBase}[${list.length}]`});
      (data.artists||[]).forEach(a=>{ if(a) map.set(a.id,a.genres||[]); });
    }catch(e){
      if(String(e.message||"").includes(" 403") && list.length>1){
        const mid=Math.floor(list.length/2); await fetchChunk(list.slice(0,mid),tagBase+"a"); await fetchChunk(list.slice(mid),tagBase+"b");
      }else if(String(e.message||"").includes(" 403") && list.length===1){ log(`   × 403 skip artist ${list[0]}`); }
      else throw e;
    }
  }
  const chunks=chunkArr(uniq,50);
  HUD.phase('artists','run');
  for(let i=0;i<chunks.length;i++){ setProg(62+Math.round((i/chunks.length)*8),`artists ${i+1}/${chunks.length}`); await fetchChunk(chunks[i],`artists#${i+1}`); }
  HUD.phase('artists','ok');
  return map;
}

/* 並び/スコア/分類 */
function dedupeById(arr){ const seen=new Set(); const out=[]; for(const t of arr){ if(seen.has(t.id)) continue; seen.add(t.id); out.push(t);} return out; }
function computeScores(tracks,wPop,wRec){
  let minD=Infinity,maxD=-Infinity;
  for(const t of tracks){ const ms=new Date(t.album?.release_date||t.__albumDate||0).getTime()||0; t._dateMs=ms; if(ms){ if(ms<minD)minD=ms; if(ms>maxD)maxD=ms; } }
  for(const t of tracks){ const recent=t._dateMs?((t._dateMs-minD)/Math.max(1,(maxD-minD))):0.5; const pop=(t.popularity||0)/100; t._score=wPop*pop+wRec*recent; }
  tracks.sort((a,b)=>b._score-a._score);
}
function artistsSet(t){ return new Set((t.artists||[]).map(a=>a.id)); }
function shareArtist(a,b){ const A=artistsSet(a),B=artistsSet(b); for(const x of A){ if(B.has(x)) return true; } return false; }
function eraBlendCands(tracks,ratioOld,poolFactor){
  const arr=[...tracks]; arr.sort((a,b)=> (a._dateMs||0)-(b._dateMs||0));
  const N=Math.max(80, Math.floor((parseInt(el("finalSize").value||"100",10))*(poolFactor||1.6)));
  const kOld=Math.max(0, Math.min(arr.length, Math.floor(N*ratioOld)));
  const kNew=Math.max(0, Math.min(arr.length-kOld, N-kOld));
  const olds=arr.slice(0, Math.min(kOld, Math.floor(arr.length/2)));
  const news=arr.slice(-Math.min(kNew, Math.ceil(arr.length/2)));
  const set=new Map(); [...news,...olds].forEach(t=>set.set(t.id,t)); return [...set.values()];
}
function balancedOrder(cands,pins,finalSize,opt){
  const posPins=new Map(Object.entries(pins).map(([k,v])=>[parseInt(k,10),v]).filter(([,v])=>v));
  const pinIds=new Set([...posPins.values()]);
  let rest=cands.filter(t=>!pinIds.has(t.id));

  const energies=rest.map(t=>t.features.energy||0.5).sort((a,b)=>a-b);
  const q1=energies[Math.floor(energies.length*0.25)]||0.25, q2=energies[Math.floor(energies.length*0.50)]||0.5, q3=energies[Math.floor(energies.length*0.75)]||0.75;
  const bucket=t=>(t.features.energy<=q1)?0:(t.features.energy<=q2)?1:(t.features.energy<=q3)?2:3;
  const bins=[[],[],[],[]]; rest.forEach(t=>bins[bucket(t)].push(t)); bins.forEach(b=>b.sort((a,b)=>b._score-a._score));

  const seq=new Array(finalSize).fill(null);
  for(const [pos,id] of posPins){ const t=cands.find(x=>x.id===id); if(t) seq[pos-1]=t; }
  let cycIdx=0; const wantHead5=true;
  function pickFromBin(bi,prev){
    const arr=bins[bi];
    for(let i=0;i<arr.length;i++){
      const t=arr[i];
      if(opt.noAdjacent!==false && prev && shareArtist(prev,t)) continue;
      arr.splice(i,1); return t;
    }
    return null;
  }
  function pickAny(prev){
    for(let r=0;r<4;r++){ const t=pickFromBin((cycIdx+r)%4,prev); if(t){cycIdx=(cycIdx+r+1)%4; return t;} }
    for(let bi=0;bi<4;bi++){ if(bins[bi].length){ return bins[bi].shift(); } }
    return null;
  }
  for(let i=0;i<finalSize;i++){
    if(seq[i]) continue;
    const prev=i>0?seq[i-1]:null; let chosen=null;
    if(wantHead5 && i>=1 && i<=3){
      const top=[...bins[3],...bins[2]].slice(0,20);
      for(const t of top){ if(opt.noAdjacent===false || !prev || !shareArtist(prev,t)){ chosen=t; break; } }
      if(chosen){ const bi=bucket(chosen); const idx=bins[bi].findIndex(x=>x.id===chosen.id); if(idx>=0) bins[bi].splice(idx,1); }
    }
    if(!chosen) chosen=pickAny(prev);
    seq[i]=chosen;
  }
  return seq.filter(Boolean);
}
function classifyBreaks(t, genresMap, seedArtistId){
  for(const a of (t.artists||[])){ const gs=genresMap.get(a.id)||[]; if(gs.some(g=>genreOk(g))) return {ok:true, reason:"genres"}; }
  if(breaksWordRe.test(t.name||"")) return {ok:true, reason:"title"};
  if(breaksWordRe.test(t.album?.name||"")) return {ok:true, reason:"album"};
  const label=(t.album && t.album.label)?t.album.label:""; if(breaksWordRe.test(label||"")) return {ok:true, reason:"label"};
  if(seedArtistId && (t.artists||[]).some(a=>a?.id===seedArtistId)){ return {ok:true, reason:"seed"}; }
  return {ok:false, reason:"none"};
}

/* グローバル */
let trimmed=[], final100=[];
const albumCache=new Map();

/* API: アーティストのアルバム一覧 */
async function scanArtistAlbums(artistId, market, groupsCsv, scanMax){
  let items=[]; let url=`https://api.spotify.com/v1/artists/${artistId}/albums?market=${encodeURIComponent(market)}&include_groups=${encodeURIComponent(groupsCsv)}&limit=50&offset=0`;
  let page=0;
  while(url && items.length<scanMax){
    page++; setProg(4,`albums ${market} p${page}`);
    const data=await callSpotifyJSON(url,{}, {tag:`albums(${market})#${page}`});
    items.push(...(data.items||[]));
    url=data.next||null;
  }
  items.sort((a,b)=> new Date(b.release_date)-new Date(a.release_date));
  return items;
}

/* アルバム→トラック（ログ強化） */
async function fetchAlbumTracks(albumId, albumName, albumDate, logMarket, idx, total){
  log(`→ tracks fetch ${logMarket} [${idx}/${total}] ${albumName} (${albumDate})`);
  setProg(10+Math.round((idx/Math.max(1,total))*20),`album ${logMarket}: ${idx}/${total}`);
  let items=[]; let url=`https://api.spotify.com/v1/albums/${albumId}/tracks?limit=50&offset=0`;
  while(url){
    const data=await callSpotifyJSON(url,{}, {tag:`album:${logMarket}:${idx}/${total}`});
    items.push(...(data.items||[]));
    url=data.next||null;
  }
  HUD.counters.tracks += items.length; HUD.countersRender();
  log(`← tracks fetched ${logMarket} [${idx}/${total}] ${albumName} → ${items.length}曲 (+${items.length})`);
  return items.map(t=>({ ...t, __albumDate: albumDate, __albumName: albumName }));
}

/* 検索フォールバック（強市場のみ / 浅め） */
async function searchRemixesByArtist(artistId, markets, minYear){
  const outIds=new Set(); let artistName=null;
  try{ const ai=await callSpotifyJSON(`https://api.spotify.com/v1/artists/${artistId}`,{}, {tag:"artistName"}); artistName=ai?.name||""; }
  catch(e){ log("artist name 取得失敗: "+(e.message||e)); return []; }
  const years=`${minYear}-2030`;
  for(const mkt of markets){
    for(let offset=0; offset<=200; offset+=50){ // shallow（速さ優先）
      try{
        setProg(32, `search ${mkt} off ${offset}`);
        const q=encodeURIComponent(`artist:"${artistName}" remix year:${years}`);
        const data=await callSpotifyJSON(`https://api.spotify.com/v1/search?type=track&limit=50&offset=${offset}&q=${q}&market=${mkt}`,{}, {tag:`search:${mkt}:${offset}`});
        const tracks=(data.tracks&&data.tracks.items)||[];
        if(!tracks.length) break;
        for(const t of tracks){
          if(!t?.id) continue;
          const hasSeed=(t.artists||[]).some(a=>a?.id===artistId); if(!hasSeed) continue;
          if(!isRemixOnlyTitle(t.name)) continue;
          const yOk=yearFromDate(t.album?.release_date)>=minYear; if(!yOk) continue;
          outIds.add(t.id); // available_markets はトラック詳細で補完
        }
      }catch(e){ log(`search ${mkt} off ${offset} 失敗: ${e.message||e}`); break; }
    }
  }
  log(`search fallback 収穫: ${outIds.size}曲`);
  return [...outIds];
}

/* FAST Build（催促案：市場限定＋アルバム重複統合） */
async function doFastBuild(){
  // ロック
  const cur=readLock(BUILD_LOCK_KEY); if(cur && Date.now()-(cur.ts||0) < 30000 && cur.owner!==TAB_ID){ warn("他タブで実行中。少し待って再実行してください。"); return; }
  writeLock(BUILD_LOCK_KEY,{owner:TAB_ID,ts:Date.now()});

  // 初期化
  trimmed=[]; final100=[]; trackSeenBy.clear(); warn("");
  HUD.phase('albums','run'); HUD.phase('tracks','idle'); HUD.phase('details','idle'); HUD.phase('features','idle'); HUD.phase('artists','idle'); HUD.phase('filter','idle'); HUD.phase('trim','idle'); HUD.phase('balance','idle');
  HUD.counters={markets:"—", albumsDone:0, albumsTotal:0, tracks:0, cands:0}; HUD.countersRender();

  try{
    // エディションの市場（強市場のみ）
    const eds=[...document.querySelectorAll(".ed:checked")].map(x=>x.value);
    if(!eds.length){ alert("エディションを選択してください。"); releaseLock(BUILD_LOCK_KEY); return; }
    const markets=[...new Set(eds.flatMap(k=>EDITIONS[k].markets))];
    HUD.counters.markets=markets.join(", "); HUD.countersRender();

    const artistId=el("artistId").value.trim();
    const recentN=Math.max(8, Math.min(80, parseInt(el("albumRecent").value||"20",10)));
    const oldRatio=Math.max(0, Math.min(0.8, parseFloat(el("oldAlbumRatio").value||"0.20")));
    const minYear=2010;
    const wPop=parseFloat(el("wPopularity").value||"0.6");
    const wRec=parseFloat(el("wRecent").value||"0.4");
    let targetPool=Math.max(120, Math.min(220, parseInt(el("targetPool").value||"130",10)));
    const SCAN_MAX=100; // 催促案：ページ浅め
    const types=needTypes();
    const groupsCsv="album,single,compilation,appears_on";

    log(`=== FAST Build (fast-preset) editions=[${eds.join(",")}] markets=[${markets.join(",")}] recentN=${recentN} oldN=${Math.round(recentN*oldRatio)} ===`);

    // アルバム収集（市場横断で重複を統合）
    const pickedRaw=[];
    for(const m of markets){
      let all=albumCache.get(m);
      if(!all){ all=await scanArtistAlbums(artistId, m, groupsCsv, SCAN_MAX); albumCache.set(m, all); }
      const filteredAlbums=all.filter(a=>matchReleaseType(a, types));
      const rec=filteredAlbums.slice(0, recentN);
      const old=oldRatio ? filteredAlbums.slice(-Math.round(recentN*oldRatio)) : [];
      log(`市場 ${m}: albums(all=${all.length}, afterType=${filteredAlbums.length}) → recent=${rec.length}, old=${old.length}`);
      rec.forEach(a=>pickedRaw.push({market:m, album:a}));
      old.forEach(a=>pickedRaw.push({market:m, album:a}));
    }
    // 同一アルバム統合
    const pickedMap=new Map();
    for(const {market,album} of pickedRaw){
      if(!pickedMap.has(album.id)) pickedMap.set(album.id,{album,markets:new Set()});
      pickedMap.get(album.id).markets.add(market);
    }
    const picked=[...pickedMap.values()];
    HUD.counters.albumsTotal=picked.length; HUD.countersRender();
    HUD.phase('albums','ok'); HUD.phase('tracks','run');

    // トラック収集（統合アルバムで1回だけ取得し、可視市場を全付与）
    const collectIds=new Set();
    for(let i=0;i<picked.length;i++){
      const {album:a, markets:mkts}=picked[i];
      const logMkt = mkts.values().next().value || markets[0];
      const tracks=await fetchAlbumTracks(a.id, a.name, a.release_date, logMkt, i+1, picked.length);
      HUD.counters.albumsDone=i+1; HUD.countersRender();

      for(const t of tracks){
        if(!t?.id) continue;
        // 見えた全市場を付与
        for(const m of mkts) markSeen(t.id, m);

        const seedOK=(t.artists||[]).some(x=>x?.id===artistId);
        if(!seedOK) continue;
        if(!isRemixOnlyTitle(t.name)) continue;
        const yOk=yearFromDate(a.release_date)>=minYear;
        if(!yOk) continue;
        collectIds.add(t.id);
      }
      HUD.counters.cands=collectIds.size; HUD.countersRender();

      if(collectIds.size>=targetPool*3) break;
    }
    log(`アルバム全曲スキャン後: ${collectIds.size}曲`);
    HUD.phase('tracks','ok');

    // search フォールバック（強市場のみ / 浅め）
    if(collectIds.size < targetPool){
      const extra=await searchRemixesByArtist(artistId, markets, minYear);
      extra.forEach(id=>collectIds.add(id));
      HUD.counters.cands=collectIds.size; HUD.countersRender();
      log(`search フォールバック後: ${collectIds.size}曲`);
    }

    const uniq=[...collectIds];
    if(!uniq.length){ warn("候補0。条件を見直してください。"); releaseLock(BUILD_LOCK_KEY); return; }

    log(`候補（下ごしらえ前）: ${uniq.length}曲 → 詳細/特徴量/ジャンル取得…`);

    HUD.phase('details','run');
    const trackObjs=await fetchTracksBatched(uniq);
    HUD.phase('details','ok');

    HUD.phase('features','run');
    const featsMap=await fetchFeaturesBatched(trackObjs.map(t=>t.id));
    HUD.phase('features','ok');

    const artistIds=new Set(); trackObjs.forEach(t=> (t.artists||[]).forEach(a=>a?.id&&artistIds.add(a.id)));
    const genresMap=await fetchArtistsGenresMapBatched([...artistIds]);

    // フィルタ
    HUD.phase('filter','run');
    const counts={year:0, remix:0, breaks:0}; const accept={genres:0,title:0,album:0,label:0,seed:0};
    let filtered=trackObjs.map(t=>{ const f=featsMap.get(t.id)||{}; return {
      id:t.id, name:t.name, artists:t.artists||[], popularity:t.popularity||0, duration_ms:t.duration_ms||0,
      album:t.album||{}, features:{energy:f.energy??0.58,valence:f.valence??0.45,tempo:f.tempo??132,danceability:f.danceability??0.60}
    }; });
    filtered=filtered.filter(t=>{
      const yOk=yearFromDate(t.album?.release_date)>=minYear; if(!yOk){counts.year++;return false;}
      const rOk=isRemixOnlyTitle(t.name); if(!rOk){counts.remix++;return false;}
      const cls=classifyBreaks(t,genresMap,artistId); if(!cls.ok){counts.breaks++;return false;}
      accept[cls.reason]=(accept[cls.reason]||0)+1; return true;
    });
    filtered=dedupeById(filtered);
    computeScores(filtered, wPop, wRec);

    // Poolが薄ければ、そのままでも Trim で着地（催促案）
    const upper=Math.max(120, Math.min(130, filtered.length));
    trimmed=filtered.slice(0, upper);

    const minYearTxt=2010;
    log(`Breaks採用内訳: genres=${accept.genres||0} / title=${accept.title||0} / album=${accept.album||0} / label=${accept.label||0} / seed=${accept.seed||0}`);
    log(`フィルタ後: ${filtered.length}曲（除外: 年<${minYearTxt}:${counts.year} / Remix規則:${counts.remix} / Breaks非該当:${counts.breaks}）`);
    HUD.phase('filter','ok');

    if(trimmed.length>=120){
      el("btnTrim").disabled=false;
      el("btnBalance").disabled=false;
      el("btnBuildEditions").disabled=false;
      HUD.counters.cands=trimmed.length; HUD.countersRender();
      log(`FAST Build 完了：${trimmed.length}曲`);
      setProg(96,"ready to Trim / Balance");
    }else{
      warn("候補が120未満。Album/Single/EP/Compilationを全ON・albumRecent↑で増やせます。");
      setProg(92,"need more pool");
    }
  }catch(e){
    log("エラー: "+(e.message||e));
    HUD.phase('albums','err'); HUD.phase('tracks','err');
  }finally{
    releaseLock(BUILD_LOCK_KEY);
  }
}

/* Trim / Balance / 反映 */
async function doTrim(){ HUD.phase('trim','run'); trimmed=trimmed.slice(0, Math.max(120, Math.min(130, trimmed.length))); log(`Trim 完了：${trimmed.length}曲`); HUD.phase('trim','ok'); setProg(98,"Trim done"); }
async function doBalance(){
  HUD.phase('balance','run');
  const finalSize=Math.max(80, Math.min(100, parseInt(el("finalSize").value||"100",10)));
  const pins={1:(el("pin1").value||"").trim(),5:(el("pin5").value||"").trim(),40:(el("pin40").value||"").trim(),60:(el("pin60").value||"").trim()};
  const ratioOld=Math.max(0, Math.min(0.8, parseFloat(el("ratioOld").value||"0.25")));
  const cand=eraBlendCands(trimmed, ratioOld, 1.6);
  final100=balancedOrder(cand, pins, finalSize, {noAdjacent:true, head5:true});
  log(`Balanced 生成：${final100.length}曲（EraMix=${ratioOld} / Remix Only / 2010+）`);
  el("btnCommit").disabled=final100.length===0;
  HUD.phase('balance','ok'); setProg(100,"Balanced 100 ready");
}
async function putPlaylist(name, desc, isPublic, uris, existingId=null){
  const maxRetry=Math.max(1, parseInt(el("maxRetry").value||"5",10));
  MIN_API_GAP_MS=Math.max(300, parseInt(el("gap").value||"1000",10));
  const me=await callSpotifyJSON("https://api.spotify.com/v1/me",{}, {tag:"/me",maxRetry}); const uid=me.id;
  let playlistId=existingId||null;
  if(playlistId){
    await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}`,{method:"PUT",body:JSON.stringify({name,description:desc,public:isPublic})},{tag:"PUT playlist",maxRetry,expectJSON:false});
  }else{
    const created=await callSpotifyJSON(`https://api.spotify.com/v1/users/${uid}/playlists`,{method:"POST",body:JSON.stringify({name,description:desc,public:isPublic})},{tag:"POST playlist",maxRetry});
    playlistId=created.id;
  }
  const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
  await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`,{method:"PUT",body:JSON.stringify({uris:chunks[0]||[]})},{tag:"PUT tracks",maxRetry,expectJSON:false});
  for(let i=1;i<chunks.length;i++){
    await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`,{method:"POST",body:JSON.stringify({uris:chunks[i]})},{tag:`POST tracks #${i+1}`,maxRetry});
  }
  log(`完成: https://open.spotify.com/playlist/${playlistId}`);
}

/* Edition作成 */
function selectedEditions(){ return [...document.querySelectorAll(".ed:checked")].map(x=>x.value); }
function coverageOk(trackId, ed, relaxStep=0){
  const seen=trackSeenBy.get(trackId)||new Set();
  if(ed.anyOf){ return ed.anyOf.some(m=>seen.has(m)); }
  if(ed.needCount){ const c=ed.markets.reduce((n,m)=>n+(seen.has(m)?1:0),0); const need=Math.max(1, ed.needCount-relaxStep); return c>=need; }
  if(ed.needPct){ const total=ed.markets.length; const c=ed.markets.reduce((n,m)=>n+(seen.has(m)?1:0),0); const need=Math.max(1, Math.ceil(total*(ed.needPct-relaxStep*0.1))); return c>=need; }
  return true;
}
async function buildEditions(){
  const eds=selectedEditions(); if(!eds.length){ alert("エディションを選択してください。"); return; }
  await doFastBuild(); if(!trimmed.length){ alert("候補が不足しています。"); return; }

  const finalSize=Math.max(80, Math.min(100, parseInt(el("finalSize").value||"100",10)));
  const pins={1:(el("pin1").value||"").trim(),5:(el("pin5").value||"").trim(),40:(el("pin40").value||"").trim(),60:(el("pin60").value||"").trim()};
  const ratioOld=Math.max(0, Math.min(0.8, parseFloat(el("ratioOld").value||"0.25")));
  const base=(el("baseName").value||"TDCS – Breaks Remix Only 100 (2010+)").trim();
  const desc=(el("baseDesc").value||"Breaks/Breakbeat限定・2010+・Remixのみ・Pins固定・バランス配置").trim();
  const isPublic=el("isPublic").value==="true";

  for(const key of eds){
    const ed=EDITIONS[key];
    let keep=trimmed.filter(t=>coverageOk(t.id,ed,0));
    if(keep.length<finalSize) keep=trimmed.filter(t=>coverageOk(t.id,ed,1));
    if(keep.length<finalSize) keep=trimmed.filter(t=>coverageOk(t.id,ed,2));
    if(keep.length<finalSize) keep=trimmed;

    const cand=eraBlendCands(keep, ratioOld, 1.6);
    const seq=balancedOrder(cand, pins, finalSize, {noAdjacent:true, head5:true});
    const uris=seq.map(t=>`spotify:track:${t.id}`);
    const name=`${base}${ed.suffix}`;
    log(`Edition ${key}: 可用性 ${keep.length}曲 → 最終 ${seq.length}曲`);
    await putPlaylist(name, `${desc} ${ed.suffix}`, isPublic, uris, null);
  }
  alert("UK/US/EU/World の作成が完了しました。");
}

/* クリック委任 + 緊急リセット */
document.addEventListener('click', async (e)=>{
  const btn=e.target.closest('button, a.btn'); if(!btn) return;
  const id=btn.id||btn.getAttribute('href')||'(no-id)'; log(`▶ click: ${id}`);
  if(btn.tagName==='A') return;
  e.preventDefault();
  try{
    switch(btn.id){
      case 'btnMe': {
        try{ const me=await callSpotifyJSON('https://api.spotify.com/v1/me',{}, {tag:'/me'}); el('hudUser').textContent=`${me.display_name||'(no name)'} / ${me.id}`; log(`/v1/me OK: ${me.display_name||'(no name)'} / ${me.id}`);} catch(err){ alert('Spotify 接続が必要です'); log('エラー: '+(err.message||err)); }
        break;
      }
      case 'btnSignOut': { try{ Object.values(K).forEach(k=>sessionStorage.removeItem(k)); log('保存トークンを削除しました。'); renderStatus(); el('hudUser').textContent='未接続'; }catch(err){ log('エラー: '+(err.message||err)); } break; }
      case 'btnFast': await doFastBuild(); break;
      case 'btnTrim': await doTrim(); break;
      case 'btnBalance': await doBalance(); break;
      case 'btnBuildEditions': await buildEditions(); break;
      case 'btnCommit': {
        if(!window.final100 || !final100.length){ alert('③Balanced を先に実行してください'); return; }
        const name=(el('plName').value||'TDCS – Breaks Remix Only 100 (2010+)').trim();
        const desc=(el('plDesc').value||'Breaks/Breakbeat限定・2010+・Remixのみ・Pins固定・バランス配置').trim();
        const isPublic=el('plPublic').value==='true';
        const existing=el('existingId').value.trim()||null;
        await putPlaylist(name, desc, isPublic, final100.map(t=>`spotify:track:${t.id}`), existing);
        break;
      }
      case 'btnRepair': {
        localStorage.removeItem(BUILD_LOCK_KEY);
        [K.access,K.expAt,K.refresh,K.scope].forEach(k=>sessionStorage.removeItem(k));
        log('🔧 緊急リセット: ロック/トークンをクリアしました'); renderStatus(); alert('リセット完了。必要なら Connect してください。');
        break;
      }
    }
  }catch(err){ log('エラー: '+(err.message||err)); }
});

/* 起動 */
(function boot(){
  log("✅ index loaded: "+location.href);
  renderStatus();
  // 古いロック自動解放（30s）
  try{ const raw=localStorage.getItem(BUILD_LOCK_KEY); if(raw){ const obj=JSON.parse(raw); if(!obj || (Date.now()-(obj.ts||0)>30000)) localStorage.removeItem(BUILD_LOCK_KEY); } }catch(_){}
})();
</script>
</body>
</html>
