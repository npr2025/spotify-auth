<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TDCS Primary Seek – Spotify Auditor</title>
  <link rel="preconnect" href="https://accounts.spotify.com"/>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans JP', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'; margin: 2rem; }
    header { margin-bottom: 1rem; }
    h1 { font-size: 1.4rem; margin: 0 0 .25rem; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 1rem; margin-bottom: 1rem; }
    .row { display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; }
    button { padding: .6rem 1rem; border-radius: 8px; border: 1px solid #999; background: #111; color: white; cursor: pointer; }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    input[type=file] { border: 1px dashed #bbb; padding: .75rem; border-radius: 8px; background: #fafafa; }
    code, .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; }
    .muted { color: #666; }
    .ok { color: #0a7f29; }
    .bad { color: #b00020; }
    progress { width: 100%; height: 14px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #eee; padding: .5rem; text-align: left; font-size: .9rem; }
    .small { font-size: .88rem; }
    footer { margin-top: 2rem; font-size: .85rem; }
  </style>
</head>
<body>
  <header>
    <h1>TDCS Primary Seek – Spotify Auditor (Web API)</h1>
    <div class="muted small">Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> | Redirect URI: <code>https://npr2025.github.io/spotify-auth/callback.html</code></div>
  </header>

  <section class="card">
    <h2>1) 接続</h2>
    <div class="row">
      <a href="./auth.html"><button>Spotifyに接続</button></a>
      <div id="authStatus" class="muted">未接続</div>
    </div>
    <div class="small muted">※ 公開メタデータのみを利用。トークンはブラウザの localStorage に保存されます。</div>
  </section>

  <section class="card">
    <h2>2) CSVをアップロード</h2>
    <p class="muted small">対応列（自動検出）：<code>spotify_url</code> / <code>UPC</code> / <code>ISRC</code> / <code>Album title</code> / <code>Album version</code> / <code>Track title</code></p>
    <div class="row">
      <input type="file" id="csvFile" accept=".csv"/>
      <label>遅延(ms)：<input type="number" id="delayMs" value="150" min="0" step="50" style="width:7rem;"/></label>
      <button id="startBtn" disabled>監査スタート</button>
      <a id="downloadOut" class="muted" download="spotify_audit_result.csv">結果CSVをダウンロード</a>
    </div>
    <div id="fileInfo" class="small muted"></div>
  </section>

  <section class="card">
    <h2>進捗</h2>
    <progress id="prog" value="0" max="100"></progress>
    <div id="log" class="small mono" style="white-space:pre-wrap; max-height:240px; overflow:auto;"></div>
  </section>

  <section class="card">
    <h2>最新の結果（サンプル数行）</h2>
    <table id="previewTbl"><thead></thead><tbody></tbody></table>
  </section>

  <footer class="muted">© Nipponeer Records — Uses Spotify Web API. No server or secret required.</footer>

<script>
const TARGET_ARTIST_ID = "55fvQ5I2IZUfcFT2DV02T3";

function log(msg) { const el = document.getElementById('log'); el.textContent += msg + "\n"; el.scrollTop = el.scrollHeight; }
function setAuthStatus(ok, text) { const el = document.getElementById('authStatus'); el.textContent = text; el.className = ok ? 'ok' : 'bad'; }

function getStoredToken() {
  const raw = localStorage.getItem('sp_token');
  if (!raw) return null;
  try { const obj = JSON.parse(raw); if (Date.now() < obj.expires_at) return obj; } catch(e) {}
  return null;
}

async function api(path, token, params={}) {
  const url = new URL('https://api.spotify.com' + path);
  Object.entries(params).forEach(([k,v]) => v!=null && url.searchParams.set(k, v));
  const res = await fetch(url.toString(), { headers: { 'Authorization': 'Bearer ' + token } });
  if (!res.ok) { const t = await res.text(); throw new Error('HTTP ' + res.status + ': ' + t); }
  return res.json();
}

function detectCols(header) {
  const lc = header.map(h => String(h||'').toLowerCase());
  function pick(...cands) { for (const c of cands) { const i = lc.indexOf(String(c).toLowerCase()); if (i>-1) return header[i]; } return null; }
  return {
    url: pick('spotify_url','url','link'),
    upc: pick('upc','UPC'),
    isrc: pick('isrc','ISRC'),
    album: pick('album title','album'),
    version: pick('album version','version'),
    track: pick('track title','track')
  };
}

function parseSpotifyUrl(u) { 
  try { const m = u.match(/open\.spotify\.com\/(album|track)\/([A-Za-z0-9]+)/); if (m) return { type: m[1], id: m[2] }; } catch(e){}
  return null;
}

async function findSpotifyForRow(row, cols, token) { 
  if (cols.url && row[cols.url]) {
    const pu = parseSpotifyUrl(row[cols.url].trim());
    if (pu) return { via: 'url', type: pu.type, id: pu.id, url: 'https://open.spotify.com/' + pu.type + '/' + pu.id };
  }
  if (cols.upc && row[cols.upc]) {
    const q = 'upc:' + row[cols.upc].trim();
    const res = await api('/v1/search', token, { q, type: 'album', limit: 1 });
    if (res.albums && res.albums.items && res.albums.items.length) { 
      const a = res.albums.items[0];
      return { via: 'upc', type: 'album', id: a.id, url: a.external_urls.spotify };
    }
  }
  if (cols.isrc && row[cols.isrc]) {
    const q = 'isrc:' + row[cols.isrc].trim();
    const res = await api('/v1/search', token, { q, type: 'track', limit: 1 });
    if (res.tracks && res.tracks.items && res.tracks.items.length) { 
      const t = res.tracks.items[0];
      return { via: 'isrc', type: 'track', id: t.id, url: t.external_urls.spotify, album_id: t.album.id, album_url: t.album.external_urls.spotify };
    }
  }
  const parts = [];
  if (cols.album && row[cols.album]) parts.push('album:"' + row[cols.album].trim() + '"');
  parts.push('artist:"The Darrow Chem Syndicate"');
  if (cols.version && row[cols.version]) parts.push('"' + row[cols.version].trim() + '"');
  const q = parts.join(' ');
  const res = await api('/v1/search', token, { q, type: 'album', limit: 1 });
  if (res.albums && res.albums.items && res.albums.items.length) { 
    const a = res.albums.items[0];
    return { via: 'search', type: 'album', id: a.id, url: a.external_urls.spotify };
  }
  return null;
}

async function auditAlbum(albumId, token) { 
  const a = await api('/v1/albums/' + albumId, token);
  const album_type = a.album_type; // 'album' | 'single' | 'compilation'
  const album_artists = (a.artists || []).map(x => ({ id: x.id, name: x.name }));
  const t = await api('/v1/albums/' + albumId + '/tracks', token, { limit: 50 });
  const trackArtists = new Set();
  (t.items || []).forEach(tr => (tr.artists || []).forEach(ar => trackArtists.add(ar.id)));
  return { album_type, album_artists, track_artists_count: trackArtists.size };
}

function classify(findRes, aRes) { 
  const reasons = [];
  let cat = 'UNKNOWN';
  if (!aRes) return { category: cat, reasons: ['album fetch failed'] };
  const isCompilation = aRes.album_type && aRes.album_type.toLowerCase() === 'compilation';
  const albumArtistIds = (aRes.album_artists || []).map(x => x.id);
  const includesTDCS = albumArtistIds.includes(TARGET_ARTIST_ID);
  if (isCompilation) reasons.push('album_type=compilation');
  if (albumArtistIds.length > 1 && (!includesTDCS || albumArtistIds.some(id => id !== TARGET_ARTIST_ID))) { reasons.push('multiple album artists: ' + albumArtistIds.length); }
  if (aRes.track_artists_count > 5) reasons.push('many distinct track artists (~' + aRes.track_artists_count + ')');

  if (isCompilation) cat = 'COMPILATION';
  else if (includesTDCS && albumArtistIds.length === 1) cat = 'ALBUM';
  else if (includesTDCS) cat = 'LIKELY_ALBUM';
  return { category: cat, reasons };
}

function rowsToCSV(rows) { 
  const header = Object.keys(rows[0] || {});
  const esc = v => (v==null ? '' : ('"'+String(v).replace(/"/g,'""')+'"'));
  return [header.map(esc).join(','), ...rows.map(r => header.map(h => esc(r[h])).join(','))].join('\r\n');
}

function setPreview(rows) { 
  const tblh = document.querySelector('#previewTbl thead');
  const tblb = document.querySelector('#previewTbl tbody');
  tblh.innerHTML=''; tblb.innerHTML='';
  const sample = rows.slice(0, Math.min(10, rows.length));
  if (!sample.length) return;
  const header = Object.keys(sample[0]);
  const trh = document.createElement('tr');
  header.forEach(h => { const th = document.createElement('th'); th.textContent = h; trh.appendChild(th); });
  tblh.appendChild(trh);
  sample.forEach(r => { const tr = document.createElement('tr'); header.forEach(h => { const td = document.createElement('td'); td.textContent = r[h]; tr.appendChild(td); }); tblb.appendChild(tr); });
}

document.getElementById('csvFile').addEventListener('change', (ev) => { 
  const file = ev.target.files[0];
  if (!file) return;
  document.getElementById('fileInfo').textContent = file.name + ' / ' + (file.size/1024).toFixed(1) + ' KB';
  Papa.parse(file, { header: true, skipEmptyLines: true, complete: (res) => { 
    window._parsedRows = res.data;
    window._cols = detectCols(res.meta.fields || []);
    document.getElementById('startBtn').disabled = false;
    log('CSV loaded: ' + window._parsedRows.length + ' rows');
    log('Detected columns: ' + JSON.stringify(window._cols));
  } });
});

document.getElementById('startBtn').addEventListener('click', async () => {
  const tokenObj = getStoredToken();
  if (!tokenObj) { alert('先に Spotify に接続してください（上のボタン）。'); return; }
  const token = tokenObj.access_token;
  const delay = parseInt(document.getElementById('delayMs').value, 10) || 0;

  const out = [];
  const prog = document.getElementById('prog');
  const rows = window._parsedRows || [];
  const cols = window._cols || {}
  const N = rows.length;
  prog.value = 0; prog.max = N;

  for (let i=0;i<N;i++) { 
    const row = rows[i];
    try {
      const findRes = await findSpotifyForRow(row, cols, token);
      let albumId = null, resolvedUrl = null, foundVia = null;
      if (findRes) { 
        foundVia = findRes.via;
        if (findRes.type === 'album') { albumId = findRes.id; resolvedUrl = findRes.url; }
        else if (findRes.type === 'track') { albumId = findRes.album_id || null; resolvedUrl = findRes.album_url || findRes.url; }
      }
      let aRes = null, category='UNKNOWN', reasons=[];
      if (albumId) { 
        aRes = await auditAlbum(albumId, token);
        const cl = classify(findRes, aRes);
        category = cl.category; reasons = cl.reasons;
      }
      const rowOut = Object.assign({}, row, {
        spotify_found_via: foundVia || '',
        spotify_album_id: albumId || '',
        spotify_url: resolvedUrl || (findRes ? findRes.url : ''),
        album_type: aRes ? aRes.album_type : '',
        album_artists: aRes ? (aRes.album_artists.map(x => x.name).join(' ; ')) : '',
        album_artist_ids: aRes ? (aRes.album_artists.map(x => x.id).join(' ; ')) : '',
        track_artists_distinct: aRes ? aRes.track_artists_count : '',
        inferred_category: category,
        reasons: reasons.join(' | ')
      });
      out.push(rowOut);
    } catch(e) { 
      log('Row ' + (i+1) + ': ERROR -> ' + e.message);
      const rowOut = Object.assign({}, row, { error: e.message });
      out.push(rowOut);
    }
    prog.value = i+1;
    if (delay) await new Promise(r => setTimeout(r, delay));
  }

  const csv = rowsToCSV(out);
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const dl = document.getElementById('downloadOut');
  dl.href = url; dl.download = 'spotify_audit_result.csv'; dl.className='';
  setPreview(out);
  log('Done.');
});

function init() { 
  const tok = getStoredToken();
  if (tok) setAuthStatus(true, 'トークンOK（有効）');
  else setAuthStatus(false, '未接続');
}
init();
</script>
</body>
</html>
