<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Editions Builder – Simple Mode（Breaks 2010+ / Remix Only）</title>

<meta name="robots" content="noindex,nofollow">
<meta name="referrer" content="no-referrer">
<meta http-equiv="Content-Security-Policy"
  content="default-src 'self';
           connect-src 'self' https://accounts.spotify.com https://api.spotify.com;
           img-src 'self' data:;
           style-src 'self' 'unsafe-inline';
           script-src 'self' 'unsafe-inline';
           frame-ancestors 'none';
           base-uri 'self';
           form-action 'self' https://accounts.spotify.com;">

<style>
  :root{--w:980px}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    -webkit-text-size-adjust:100%;
    -webkit-tap-highlight-color:transparent;
    max-width:var(--w); margin:28px auto; padding:0 14px 72px; /* 72px = ドック分 */
    background:#fff;
  }
  h1{margin:0 0 10px}
  .muted{color:#667085}
  .note{font-size:12px;color:#667085}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
  .row>*{flex:1 1 220px}
  input,select{
    width:100%;padding:12px 12px;border:1px solid #D0D5DD;border-radius:10px;font-size:16px;
  }
  button,a.btn{
    display:inline-block;padding:12px 14px;border:1px solid #D0D5DD;border-radius:10px;background:#F9FAFB;
    cursor:pointer;text-decoration:none;min-height:44px
  }
  button:disabled{opacity:.55;cursor:not-allowed}
  fieldset{border:1px solid #E4E7EC;border-radius:12px;padding:12px;margin:12px 0}
  legend{padding:0 6px}
  .pill{display:inline-block;font-size:12px;border:1px solid #E4E7EC;border-radius:999px;padding:2px 8px;margin-left:8px}
  .hud{border:1px solid #E4E7EC;border-radius:12px;padding:12px;margin:10px 0}
  .kv{display:grid;grid-template-columns:120px 1fr;gap:6px 10px}
  progress{width:100%;height:16px}
  details>summary{cursor:pointer;padding:8px 0;font-weight:600}
  #log{
    white-space:pre-wrap;background:#0b1220;color:#cfe3ff;border-radius:10px;padding:12px;max-height:420px;overflow:auto;
  }
  .dock{
    position:fixed;left:0;right:0;bottom:0;z-index:10;
    background:#fff;border-top:1px solid #E4E7EC;
    padding:8px 10px calc(8px + env(safe-area-inset-bottom));
    display:flex;gap:8px;justify-content:space-between
  }
  .dock button{flex:1 1 auto}
  @media (max-width:720px){
    body{margin:16px auto;padding:0 10px 86px}
    .row>*{flex:1 1 100%}
    .kv{grid-template-columns:1fr}
    .kv>div:nth-child(odd){color:#667085}
    fieldset legend{font-size:14px}
    h1{font-size:20px}
    .sticky-actions{display:none}
  }
</style>

<!-- Excel読み込みが必要ならこのファイルを同じフォルダに置いて有効化 -->
<script src="./xlsx.full.min.js"></script>
</head>
<body>
<h1>Editions Builder – Simple Mode<span class="pill">Breaks限定・2010+・Remixのみ</span></h1>
<p class="note">通信先は <code>accounts.spotify.com</code> / <code>api.spotify.com</code> の公式APIのみ。パスワードは扱いません。</p>

<!-- HUD -->
<div class="hud">
  <div class="kv">
    <div>接続ユーザー</div><div id="hudUser">未接続</div>
    <div>トークン残り</div><div id="hudTTL">—</div>
    <div>進捗</div>
    <div>
      <progress id="prog" value="0" max="100"></progress>
      <div class="row" style="margin-top:8px">
        <span id="progTxt" class="muted" style="flex:1 1 auto">準備OK</span>
        <button id="btnRepair" style="flex:0 0 auto">🔧 緊急リセット</button>
      </div>
    </div>
  </div>
  <div class="row" style="margin-top:8px">
    <div><a class="btn" href="./auth.html">Connect with Spotify</a> <button id="btnMe">/v1/me</button> <button id="btnSignOut">切断（保存トークン削除）</button></div>
    <div class="muted" id="status">未接続（上のボタンから開始）</div>
  </div>
</div>

<!-- シンプル設定（既存クイックビルド） -->
<fieldset>
  <legend>プリセット（UK / US / EU / World）</legend>
  <div class="row">
    <div>
      <label>エディション</label>
      <div class="note">4つすべて既定ON（必要なら外してください）</div>
      <label><input type="checkbox" class="ed" value="UK" checked> UK</label>
      <label><input type="checkbox" class="ed" value="US" checked> US</label>
      <label><input type="checkbox" class="ed" value="EU" checked> EU</label>
      <label><input type="checkbox" class="ed" value="WORLD" checked> World</label>
    </div>
    <div>
      <label>アーティストID</label>
      <input id="artistId" value="55fvQ5I2IZUfcFT2DV02T3">
      <div class="note">The Darrow Chem Syndicate（変更可）</div>
    </div>
    <div>
      <label>最新から取る枚数</label>
      <input id="albumRecent" type="number" min="24" max="64" value="48">
      <div class="note">古いカタログも拾うため多め推奨</div>
    </div>
    <div>
      <label>旧作サンプル比率（0–0.8）</label>
      <input id="oldAlbumRatio" type="number" step="0.05" min="0" max="0.8" value="0.40">
      <div class="note">例）48枚 × 0.40 ≒ 19枚ぶん過去を追加</div>
    </div>
  </div>
  <div class="row">
    <div>
      <label>採用するリリースの曲数上限</label>
      <input id="maxTracks" type="number" min="6" max="20" value="9">
      <div class="note">EP/Single中心にするための上限。足りなければ 12。</div>
    </div>
    <div>
      <label>Trim上限（候補ターゲット）</label>
      <input id="targetPool" type="number" min="120" max="220" value="150">
      <div class="note">まず 150 曲へトリム</div>
    </div>
    <div>
      <label>Balanced曲数</label>
      <select id="balancedSize">
        <option value="100">100</option>
        <option value="120">120</option>
        <option value="150" selected>150</option>
      </select>
    </div>
    <div>
      <label>人気の重み</label>
      <input id="wPopularity" type="number" step="0.05" min="0" max="1" value="0.55">
    </div>
    <div>
      <label>新しさの重み</label>
      <input id="wRecent" type="number" step="0.05" min="0" max="1" value="0.45">
    </div>
  </div>
  <div class="row sticky-actions">
    <div>
      <button id="btnFast">① 収集（Quick）</button>
      <button id="btnTrim" disabled>② Trim（150）</button>
      <button id="btnBalance" disabled>③ Balanced（100/120/150）</button>
      <button id="btnBuildEditions" disabled>④ 4エディション作成</button>
    </div>
    <div>
      <label>API最小間隔ms</label>
      <input id="gap" type="number" value="900">
    </div>
  </div>
</fieldset>

<!-- 新機能：ファイルから最終版（130×4）生成＆既存ドラフトへ上書き -->
<fieldset>
  <legend>ファイル取り込み → 130曲× EU/UK/US/WORLD を生成 & 既存プレイリストへ上書き</legend>
  <div class="row">
    <div>
      <label>ソースCSV（Propgapandaソース.csv）</label>
      <input id="fileSourceCsv" type="file" accept=".csv">
      <div class="note">Remix/Breaks判定に使う元データ</div>
    </div>
    <div>
      <label>分析データ（Excel or CSV）</label>
      <input id="fileMetrics" type="file" accept=".xlsx,.xls,.csv">
      <div class="note">保存率/再生系の指標を含む表（Excelなら <code>xlsx.full.min.js</code> が必要）</div>
    </div>
  </div>
  <div class="row">
    <div><label>EUドラフトURL/ID</label><input id="plEU" placeholder="URL or ID" value="https://open.spotify.com/playlist/2JWHMN3yxLI5S4XFdDZbwt"></div>
    <div><label>UKドラフトURL/ID</label><input id="plUK" placeholder="URL or ID" value="https://open.spotify.com/playlist/1zqDXSgnbc87v4BxbHxtKK"></div>
    <div><label>USドラフトURL/ID</label><input id="plUS" placeholder="URL or ID" value="https://open.spotify.com/playlist/2oeS8QglwS4hLtLuqvPZgH"></div>
    <div><label>WORLDドラフトURL/ID</label><input id="plWORLD" placeholder="URL or ID" value="https://open.spotify.com/playlist/4SCclM9zLNuSPOmqORdVN8"></div>
  </div>
  <div class="row">
    <div><button id="btnBuildFromFiles">ファイルから最終版（130×4）作成</button></div>
    <div><button id="btnUpdateFromFiles" disabled>各版を既存Playlistに上書き反映</button></div>
  </div>
  <div class="note">“ドラフトを元に”の要望対応：各ドラフトの現行曲を <b>ピン（錨）</b> として優先配置します（見つかった範囲）</div>
</fieldset>

<!-- 単発作成（既存機能） -->
<fieldset>
  <legend>（任意）単発で作成/更新</legend>
  <div class="row">
    <div><label>プレイリスト名</label><input id="plName" placeholder="TDCS – Breaks Remix Only (Balanced 150)"></div>
    <div><label>説明文</label><input id="plDesc" placeholder="Breaks/Breakbeat限定・2010+・Remixのみ・Pins固定・Balanced出力"></div>
    <div><label>公開設定</label><select id="plPublic"><option value="false" selected>非公開</option><option value="true">公開</option></select></div>
  </div>
  <div class="row">
    <div><label>既存プレイリストID（空＝新規）</label><input id="existingId" placeholder="例）37i9dQZF1DX..."></div>
    <div><label>最大リトライ</label><input id="maxRetry" type="number" value="5"></div>
    <div><button id="btnCommit" disabled>⑤ 作成/更新する</button></div>
  </div>
  <div class="note">※ Balancedが未生成なら Trim(最大150) をそのまま出します。</div>
</fieldset>

<h2 style="margin-bottom:6px">ログ</h2>
<details id="logBox">
  <summary class="muted">開く（モバイルでは重いので閉じています）</summary>
  <pre id="log"></pre>
</details>

<!-- 画面下ドック（モバイル操作バー） -->
<div class="dock" role="toolbar" aria-label="操作">
  <button id="mbFast">収集</button>
  <button id="mbTrim" disabled>Trim</button>
  <button id="mbBalance" disabled>Bal</button>
  <button id="mbBuild" disabled>作成</button>
  <button id="mbCommit" disabled>更新</button>
</div>

<script>
"use strict";

/*** 固定：認可/保存キー ***/
const CLIENT_ID="1fd6350fcf4945a0b3ddffa2d5730d4e";
const REDIRECT_URI="https://npr2025.github.io/spotify-auth/callback.html";
const K={access:"sp_access_token",type:"sp_token_type",expAt:"sp_expires_at",refresh:"sp_refresh_token",scope:"sp_scope"};

/*** 便利 ***/
const el=id=>document.getElementById(id);
const log=(m)=>{
  const d=new Date().toLocaleTimeString();
  const L=el("log");
  const next=L.textContent+`[${d}] ${m}\n`;
  const lines=next.split("\n");
  const trimmed=(lines.length>300?lines.slice(-300):lines).join("\n");
  L.textContent=trimmed;
  L.scrollTop=L.scrollHeight;
};
const setProg=(v,t)=>{el("prog").value=v; el("progTxt").textContent=t||"";};
const status=(t)=>{el("status").textContent=t||"";};
const sleep=ms=>new Promise(r=>setTimeout(r,ms));

/*** 接続表示 ***/
function renderStatus(){
  try{
    const a=sessionStorage.getItem(K.access); const e=parseInt(sessionStorage.getItem(K.expAt)||"0",10);
    if(!a){ el("hudUser").textContent="未接続"; el("hudTTL").textContent="—"; status("未接続（Connect を押してください）"); return; }
    const left=e-Date.now();
    el("hudUser").textContent="接続中"; el("hudTTL").textContent=left>0?`${Math.floor(left/1000)}s`:"期限切れ";
    status(left>0?"接続中":"期限切れ（Connect し直し）");
  }catch(e){ status("状態表示エラー: "+(e.message||e)); }
}

/*** レート/リフレッシュ/HTTP ***/
let MIN_API_GAP_MS=900, lastApiTs=0, refreshInflight=null;
async function ensureFreshToken(){
  const access=sessionStorage.getItem(K.access), expAt=parseInt(sessionStorage.getItem(K.expAt)||"0",10), refresh=sessionStorage.getItem(K.refresh);
  if(access && Date.now()<(expAt-5000)) return access;
  if(!refresh) return null;
  if(!refreshInflight){
    refreshInflight=(async()=>{
      let attempt=0;
      while(true){ attempt++;
        const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body:new URLSearchParams({client_id:CLIENT_ID,grant_type:"refresh_token",refresh_token:refresh,redirect_uri:REDIRECT_URI})});
        if(res.status===429){const ra=parseInt(res.headers.get("Retry-After")||"1",10); await sleep((isNaN(ra)?1:Math.min(60,ra))*1000+200); continue;}
        if(res.status>=500 && attempt<=3){await sleep(Math.min(5000,600*Math.pow(2,attempt-1))); continue;}
        const txt=await res.text(); let data=null; try{data=JSON.parse(txt);}catch(_){}
        if(!res.ok) throw new Error("refresh failed: "+res.status+" "+txt);
        const exp=Date.now()+data.expires_in*1000;
        sessionStorage.setItem(K.access,data.access_token);
        sessionStorage.setItem(K.expAt,String(exp));
        if(data.refresh_token) sessionStorage.setItem(K.refresh,data.refresh_token);
        if(data.scope) sessionStorage.setItem(K.scope,data.scope);
        renderStatus();
        return data.access_token;
      }
    })().finally(()=>{refreshInflight=null;});
  }
  return refreshInflight;
}
function parse403(txt){ try{const j=JSON.parse(txt); return j?.error?.message||"";}catch(_){return "";} }
async function callSpotifyJSON(url,opts={}, {maxRetry=5,expectJSON=true,tag=""}={}){
  MIN_API_GAP_MS=Math.max(300, parseInt(el("gap")?.value||"900",10));
  const wait=Math.max(0,MIN_API_GAP_MS-(Date.now()-lastApiTs)); if(wait) await sleep(wait);
  let token=await ensureFreshToken(); if(!token) throw new Error("No valid token. Connect again.");
  let attempt=0;
  while(true){
    attempt++;
    const headers=new Headers(opts.headers||{}); headers.set("Authorization","Bearer "+token); headers.set("Accept","application/json");
    if(opts.body && !(opts.body instanceof FormData) && !headers.has("Content-Type")) headers.set("Content-Type","application/json");
    const res=await fetch(url,{...opts,headers}); lastApiTs=Date.now();

    if(res.status===429 && attempt<=maxRetry){const ra=parseInt(res.headers.get("Retry-After")||"1",10); await sleep((isNaN(ra)?1:Math.min(60,ra))*1000+200); continue;}
    if(res.status===401 && attempt===1){ token=await ensureFreshToken(); if(!token) throw new Error("Unauthorized and cannot refresh."); continue; }
    if(res.status===403){ const txt=await res.text(); throw new Error(`${tag||"HTTP"} 403${parse403(txt)?": "+parse403(txt):""}`); }
    if(res.status>=500 && attempt<=maxRetry){ await sleep(Math.min(8000,700*Math.pow(2,attempt-1))); continue; }
    if(!res.ok){ const txt=await res.text(); throw new Error(`${tag||"HTTP"} ${res.status}: ${txt}`); }

    if(!expectJSON) return null;
    const txt=await res.text(); if(!txt) return {}; try{ return JSON.parse(txt); }catch(_){ return {}; }
  }
}

/*** 判定：Remix only / Breaks / EP/Single ***/
function tokenize(s){ return (s||"").toLowerCase().replace(/[()[\]{}\-]/g," ").replace(/\s+/g," ").trim().split(" ").filter(Boolean); }
function isRemixOnlyTitle(name){
  const t=tokenize(name);
  const hasRemix=t.includes("remix")||t.includes("remixed")||t.includes("rmx");
  const hasMix = t.includes("mix") || (t.includes("dj")&&t.includes("mix")) || (t.includes("original")&&t.includes("mix")) || (t.includes("club")&&t.includes("mix")) || (t.includes("continuous")&&t.includes("mix"));
  return hasRemix && !hasMix;
}
const breaksWord=/\b(breaks?|break[-\s]?beat|nu[-\s]?breaks?|big\s*beat|funky[-\s]*breaks?|electro[-\s]*breaks?|progressive\s*breaks?|psy[-\s]*breaks?|acid\s*breaks?)\b/i;
const genreOK=g=>/breakbeat|breaks?|big beat|nu skool breaks|electro breaks?|progressive breaks?|funky breaks?|psybreaks?|acid breaks?/i.test(g||"");
function yearFromDate(s){ if(!s) return 0; const y=parseInt(String(s).slice(0,4),10); return isNaN(y)?0:y; }
function isEP(album){ const type=(album.album_type||"").toLowerCase(); const tracks=album.total_tracks||0; const name=(album.name||"").toLowerCase(); return (type==="single" && tracks>=3) || /\bep\b/.test(name); }
function isSingle(album){ const type=(album.album_type||"").toLowerCase(); return type==="single" && !isEP(album); }

/*** 可用性（エディション用） ***/
const trackSeenBy=new Map(); function markSeen(id,market){ let s=trackSeenBy.get(id); if(!s){s=new Set(); trackSeenBy.set(id,s);} s.add(market); }

/*** Editions ***/
const EDITIONS={
  UK:    { markets:["GB","IE"], anyOf:["GB"], suffix:" [UK Edition]" },
  US:    { markets:["US","CA"], anyOf:["US"], suffix:" [US Edition]" },
  EU:    { markets:["DE","FR","NL","ES","IT","SE","DK","FI","BE"], needCount:3, suffix:" [EU Edition]" },
  WORLD: { markets:["US","GB","DE","FR","NL","ES","IT","SE","AU","CA"], needPct:0.6, suffix:" [World Edition]" }
};

/*** 小道具 ***/
const chunk=(a,n)=>{const out=[]; for(let i=0;i<a.length;i+=n) out.push(a.slice(i,i+n)); return out; };
function computeScores(tracks,wPop,wRec){
  let minD=Infinity,maxD=-Infinity;
  for(const t of tracks){ const ms=new Date(t.album?.release_date||t.__albumDate||0).getTime()||0; t._dateMs=ms; if(ms){ if(ms<minD)minD=ms; if(ms>maxD)maxD=ms; } }
  for(const t of tracks){ const recent=t._dateMs?((t._dateMs-minD)/Math.max(1,(maxD-minD))):0.5; const pop=(t.popularity||0)/100; t._score=wPop*pop+wRec*recent; }
  tracks.sort((a,b)=>b._score-a._score);
}
function artistsSet(t){ return new Set((t.artists||[]).map(a=>a.id)); }
function shareArtist(a,b){ const A=artistsSet(a),B=artistsSet(b); for(const x of A){ if(B.has(x)) return true; } return false; }
function eraBlendCands(tracks,ratioOld,poolN){
  const arr=[...tracks].sort((a,b)=>(a._dateMs||0)-(b._dateMs||0));
  const N=Math.min(poolN, arr.length);
  const kOld=Math.max(0, Math.min(arr.length, Math.floor(N*ratioOld)));
  const olds=arr.slice(0, Math.min(kOld, Math.floor(arr.length/2)));
  const news=arr.slice(-Math.min(N-kOld, Math.ceil(arr.length/2)));
  const set=new Map(); [...news,...olds].forEach(t=>set.set(t.id,t)); return [...set.values()];
}
function balancedOrder(cands,pins,finalSize,{noAdjacent=true}={}){
  const posPins=new Map(Object.entries(pins).map(([k,v])=>[parseInt(k,10),v]).filter(([,v])=>v));
  const pinIds=new Set([...posPins.values()]);
  let rest=cands.filter(t=>!pinIds.has(t.id));
  const energies=rest.map(t=>t.features.energy||0.5).sort((a,b)=>a-b);
  const q1=energies[Math.floor(energies.length*0.25)]||0.25, q2=energies[Math.floor(energies.length*0.5)]||0.5, q3=energies[Math.floor(energies.length*0.75)]||0.75;
  const bucket=t=>(t.features.energy<=q1)?0:(t.features.energy<=q2)?1:(t.features.energy<=q3)?2:3;
  const bins=[[],[],[],[]]; rest.forEach(t=>bins[bucket(t)].push(t)); bins.forEach(b=>b.sort((a,b)=>b._score-a._score));
  const seq=new Array(finalSize).fill(null); let cyc=0;
  for(const [pos,id] of posPins){ const t=cands.find(x=>x.id===id); if(t) seq[pos-1]=t; }
  function pick(prev){ for(let r=0;r<4;r++){ const bi=(cyc+r)%4; const a=bins[bi]; for(let i=0;i<a.length;i++){ const t=a[i]; if(noAdjacent && prev && shareArtist(prev,t)) continue; a.splice(i,1); cyc=(bi+1)%4; return t; } } for(let bi=0;bi<4;bi++){ if(bins[bi].length) return bins[bi].shift(); } return null; }
  for(let i=0;i<finalSize;i++){ if(seq[i]) continue; const prev=i?seq[i-1]:null; seq[i]=pick(prev); }
  return seq.filter(Boolean);
}

/*** 既存のアルバム→曲収集（Quickモード用） ***/
async function scanArtistAlbums(artistId, market, groupsCsv, scanMax){
  let items=[]; let url=`https://api.spotify.com/v1/artists/${artistId}/albums?market=${encodeURIComponent(market)}&include_groups=${encodeURIComponent(groupsCsv)}&limit=50&offset=0`;
  while(url && items.length<scanMax){ const data=await callSpotifyJSON(url,{}, {tag:`albums(${market})`}); items.push(...(data.items||[])); url=data.next||null; }
  items.sort((a,b)=> new Date(b.release_date)-new Date(a.release_date));
  return items;
}
async function fetchAlbumTracks(albumId, albumName, albumDate, market){
  let items=[]; let url=`https://api.spotify.com/v1/albums/${albumId}/tracks?limit=50&offset=0`;
  while(url){ const data=await callSpotifyJSON(url,{}, {tag:`album:${market}`}); items.push(...(data.items||[])); url=data.next||null; }
  items.forEach(t=>{ if(t?.id) markSeen(t.id,market); });
  return items.map(t=>({ ...t, __albumDate: albumDate, __albumName: albumName }));
}
async function searchRemixesByArtist(artistId, markets, minYear){
  const outIds=new Set(); let artistName="";
  try{ const ai=await callSpotifyJSON(`https://api.spotify.com/v1/artists/${artistId}`,{}, {tag:"artist"}); artistName=ai?.name||"";}catch{ return []; }
  const years=`${minYear}-2030`;
  for(const mkt of markets){
    for(let offset=0; offset<=400; offset+=50){
      try{
        const q=encodeURIComponent(`artist:"${artistName}" remix year:${years}`);
        const data=await callSpotifyJSON(`https://api.spotify.com/v1/search?type=track&limit=50&offset=${offset}&q=${q}&market=${mkt}`,{}, {tag:`search:${mkt}:${offset}`});
        const tracks=(data.tracks&&data.tracks.items)||[];
        if(!tracks.length) break;
        for(const t of tracks){
          if(!t?.id) continue;
          const hasSeed=(t.artists||[]).some(a=>a?.id===artistId); if(!hasSeed) continue;
          if(!isRemixOnlyTitle(t.name)) continue;
          const yOk=yearFromDate(t.album?.release_date)>=minYear; if(!yOk) continue;
          outIds.add(t.id);
        }
      }catch{ break; }
    }
  }
  return [...outIds];
}
async function fetchTracksBatched(ids){
  const uniq=[...new Set(ids)]; const results=[];
  async function chunkFetch(list,tag){
    try{ const data=await callSpotifyJSON(`https://api.spotify.com/v1/tracks?ids=${list.join(",")}`,{}, {tag}); (data.tracks||[]).forEach(t=>t&&results.push(t)); }
    catch(e){ if(String(e.message||"").includes(" 403") && list.length>1){ const m=Math.floor(list.length/2); await chunkFetch(list.slice(0,m),tag+"a"); await chunkFetch(list.slice(m),tag+"b"); } else if(list.length===1){ log(`× 403 skip track ${list[0]}`); } else { throw e; } }
  }
  for(const c of chunk(uniq,50)) await chunkFetch(c,"tracks");
  return results;
}
async function fetchFeaturesBatched(ids){
  const uniq=[...new Set(ids)]; const feats=new Map();
  async function batch(list,tag){ const d=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features?ids=${list.join(",")}`,{}, {tag}); (d.audio_features||[]).forEach((f,i)=>{const id=list[i]; if(f&&f.id)feats.set(f.id,f); else feats.set(id,null);}); }
  async function single(id){ try{ const f=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features/${id}`,{}, {tag:`feature:${id}`}); if(f&&f.id) return void feats.set(id,f); }catch{} feats.set(id,null); }
  async function analysis(id){ try{ const a=await callSpotifyJSON(`https://api.spotify.com/v1/audio-analysis/${id}`,{}, {tag:`analysis:${id}`}); const tempo=a?.track?.tempo||132; feats.set(id,{id,energy:0.58,valence:0.45,danceability:0.60,tempo,__fallback:"analysis"});}catch{feats.set(id,{id,energy:0.58,valence:0.45,danceability:0.60,tempo:132,__fallback:"neutral"});} }
  for(const c of chunk(uniq,100)) try{ await batch(c,"features"); }catch{ c.forEach(id=>feats.set(id,null)); }
  const need1=uniq.filter(id=>!feats.has(id) || feats.get(id)===null);
  for(const id of need1) await single(id);
  const need2=uniq.filter(id=>!feats.has(id) || feats.get(id)===null);
  for(const id of need2) await analysis(id);
  return feats;
}
async function fetchArtistsGenresMapBatched(ids){
  const uniq=[...new Set(ids)]; const map=new Map();
  async function chunkFetch(list,tag){ const data=await callSpotifyJSON(`https://api.spotify.com/v1/artists?ids=${list.join(",")}`,{}, {tag}); (data.artists||[]).forEach(a=>a&&map.set(a.id,a.genres||[])); }
  for(const c of chunk(uniq,50)) await chunkFetch(c,"artists");
  return map;
}

/*** グローバル（Quick用） ***/
let trimmed=[], finalSeq=[];
const albumCache=new Map();

/*** 収集（Quick モード） ***/
async function doFastBuild(){
  trimmed=[]; finalSeq=[]; trackSeenBy.clear();
  setProg(2,"start");

  const eds=[...document.querySelectorAll(".ed:checked")].map(x=>x.value);
  if(!eds.length){ alert("エディションを選択してください"); return; }
  const markets=[...new Set(eds.flatMap(k=>EDITIONS[k].markets))];
  const artistId=el("artistId").value.trim();
  const recentN=parseInt(el("albumRecent").value||"48",10);
  const oldRatio=parseFloat(el("oldAlbumRatio").value||"0.40");
  const maxTracks=parseInt(el("maxTracks").value||"9",10);
  const targetPool=parseInt(el("targetPool").value||"150",10);
  const minYear=2010;

  log(`=== FAST Build start editions=[${eds.join(",")}] recent=${recentN} oldRatio=${oldRatio} maxTracks<=${maxTracks} ===`);

  const groupsCsv="album,single,compilation,appears_on";
  const SCAN_MAX=200;
  const pickedMap=new Map();
  for(const m of markets){
    let all=albumCache.get(m); if(!all){ all=await scanArtistAlbums(artistId,m,groupsCsv,SCAN_MAX); albumCache.set(m,all); }
    const filtered=all.filter(a=>{
      const ep=isEP(a), single=isSingle(a);
      const tracks=(a.total_tracks||99) <= maxTracks;
      return (ep||single) && tracks;
    });
    const rec=filtered.slice(0, recentN);
    const old=oldRatio ? filtered.slice(-Math.round(recentN*oldRatio)) : [];
    log(`市場 ${m}: albums(all=${all.length}, afterType=${filtered.length}) ≤${maxTracks} → recent=${rec.length}, old=${old.length}`);
    [...rec,...old].forEach(a=>{
      if(!pickedMap.has(a.id)) pickedMap.set(a.id,{album:a,markets:new Set()});
      pickedMap.get(a.id).markets.add(m);
    });
  }
  const picked=[...pickedMap.values()];
  setProg(12,`albums ${picked.length}`);

  const collectIds=new Set();
  for(let i=0;i<picked.length;i++){
    const {album:a, markets:mkts}=picked[i];
    const tracks=await fetchAlbumTracks(a.id,a.name,a.release_date,[...mkts][0]||markets[0]);
    for(const t of tracks){
      if(!t?.id) continue;
      for(const m of mkts) markSeen(t.id,m);
      const seedOK=(t.artists||[]).some(x=>x?.id===artistId); if(!seedOK) continue;
      if(!isRemixOnlyTitle(t.name)) continue;
      if(yearFromDate(a.release_date)<minYear) continue;
      collectIds.add(t.id);
    }
    if(collectIds.size>=targetPool*3) break;
  }
  log(`アルバム全曲スキャン後: ${collectIds.size}曲`);

  if(collectIds.size<targetPool){
    const extra=await searchRemixesByArtist(artistId, markets, minYear);
    extra.forEach(id=>collectIds.add(id));
    log(`search fallback 収穫後: ${collectIds.size}曲`);
  }
  if(!collectIds.size){ log("候補0。条件を見直してください。"); return; }

  setProg(40,"details");
  const trackObjs=await fetchTracksBatched([...collectIds]);
  setProg(56,"features");
  const featsMap=await fetchFeaturesBatched(trackObjs.map(t=>t.id));
  const artistIds=new Set(); trackObjs.forEach(t=> (t.artists||[]).forEach(a=>a?.id&&artistIds.add(a.id)));
  setProg(70,"artists");
  const genresMap=await fetchArtistsGenresMapBatched([...artistIds]);

  function classifyBreaks(t){
    const byGenres=(t.artists||[]).some(a=>(genresMap.get(a.id)||[]).some(genreOK));
    const byTitle =breaksWord.test(t.name||"");
    const byAlbum =breaksWord.test(t.album?.name||"");
    const byLabel =breaksWord.test(t.album?.label||"");
    const bySeed  =(t.artists||[]).some(a=>a?.id===artistId);
    return byGenres||byTitle||byAlbum||byLabel||bySeed;
  }

  setProg(78,"filter");
  let base = trackObjs.map(t=>{ const f=featsMap.get(t.id)||{}; return {
    id:t.id, name:t.name, artists:t.artists||[], popularity:t.popularity||0, duration_ms:t.duration_ms||0,
    album:t.album||{}, features:{energy:f?.energy??0.58,valence:f?.valence??0.45,danceability:f?.danceability??0.60,tempo:f?.tempo??132}
  }; });

  const passCore = (t)=>{
    const a=t.album||{};
    if(yearFromDate(a.release_date) < 2010) return false;
    if(!isRemixOnlyTitle(t.name))          return false;
    const ep=isEP(a), single=isSingle(a);   if(!(ep||single)) return false;
    if((a.total_tracks||99) > maxTracks)    return false;
    return true;
  };

  let filtered = base.filter(t => passCore(t) && classifyBreaks(t));
  if(filtered.length < 120){
    log(`Breaks 判定を緩和: ${filtered.length}曲 → 再評価中…`);
    filtered = base.filter(passCore);
    log(`→ 緩和後: ${filtered.length}曲`);
  }

  const wPop=parseFloat(el("wPopularity").value||"0.55");
  const wRec=parseFloat(el("wRecent").value||"0.45");
  computeScores(filtered,wPop,wRec);
  const upper=Math.min(parseInt(el("targetPool").value||"150",10), filtered.length);
  trimmed=filtered.slice(0, upper);
  log(`Trim 完了：${trimmed.length}曲（ターゲット${upper}）`);
  setProg(90,`trimmed ${trimmed.length}`);

  ['btnTrim','btnBalance','btnBuildEditions','btnCommit','mbTrim','mbBalance','mbBuild','mbCommit'].forEach(id=>{
    const b=el(id); if(b) b.disabled=false;
  });
}

async function doTrim(){
  if(!trimmed.length) return alert("先に①収集を実行してください");
  const upper=Math.min(parseInt(el("targetPool").value||"150",10), trimmed.length);
  trimmed=trimmed.slice(0, upper);
  log(`Trim 再実行：${trimmed.length}曲`);
  setProg(92,"Trim done");
}

async function doBalance(){
  if(!trimmed.length) return alert("先に①収集/②Trimを実行してください");
  const wantN = Math.max(80, Math.min(parseInt(el("balancedSize").value||"150",10), trimmed.length));
  const pins  = {1:"0ueNjvhtXGDFkJQ5WBQ4mE",5:"63dYSEftdSYwMAFBNfQYsA",40:"3NQuIFfQPhTICaXGYe5dAt",60:"7ltcrdlVsXyU5HU9VCAj6P"};
  const pool  = eraBlendCands(trimmed, 0.40, Math.min(trimmed.length, wantN*2));
  finalSeq    = balancedOrder(pool, pins, wantN, {noAdjacent:true});
  log(`Balanced 生成：${finalSeq.length}曲（指定=${wantN} / old 40% mix）`);
  setProg(100,`Balanced ${wantN} ready`);
}

async function putPlaylist(name, desc, isPublic, uris, existingId=null){
  const maxRetry=Math.max(1, parseInt(el("maxRetry").value||"5",10));
  const me=await callSpotifyJSON("https://api.spotify.com/v1/me",{}, {tag:"/me",maxRetry}); const uid=me.id;
  let playlistId=existingId||null;
  if(playlistId){
    await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}`,{method:"PUT",body:JSON.stringify({name,description:desc,public:isPublic})},{tag:"PUT playlist",maxRetry,expectJSON:false});
  }else{
    const created=await callSpotifyJSON(`https://api.spotify.com/v1/users/${uid}/playlists`,{method:"POST",body:JSON.stringify({name,description:desc,public:isPublic})},{tag:"POST playlist",maxRetry});
    playlistId=created.id;
  }
  const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
  await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`,{method:"PUT",body:JSON.stringify({uris:chunks[0]||[]})},{tag:"PUT tracks",maxRetry,expectJSON:false});
  for(let i=1;i<chunks.length;i++) await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`,{method:"POST",body:JSON.stringify({uris:chunks[i]})},{tag:`POST tracks #${i+1}`,maxRetry});
  log(`完成: https://open.spotify.com/playlist/${playlistId}`);
}

function selectedEditions(){ return [...document.querySelectorAll(".ed:checked")].map(x=>x.value); }
function coverageOk(trackId, ed, relaxStep=0){
  const seen=trackSeenBy.get(trackId)||new Set();
  if(ed.anyOf){ return ed.anyOf.some(m=>seen.has(m)); }
  if(ed.needCount){ const c=ed.markets.reduce((n,m)=>n+(seen.has(m)?1:0),0); const need=Math.max(1, ed.needCount-relaxStep); return c>=need; }
  if(ed.needPct){ const total=ed.markets.length; const c=ed.markets.reduce((n,m)=>n+(seen.has(m)?1:0),0); const need=Math.max(1, Math.ceil(total*(ed.needPct-relaxStep*0.1))); return c>=need; }
  return true;
}

async function buildEditions(){
  if(!trimmed.length) return alert("先に①収集（できれば ②Trim / ③Balanced）を実行してください");
  const eds=selectedEditions(); if(!eds.length) return alert("エディションを選んでください");

  const base=(document.getElementById("plName").value||"TDCS – Breaks Remix Only").trim();
  const desc=(document.getElementById("plDesc").value||"Breaks/Breakbeat限定・2010+・Remixのみ・Pins固定").trim();
  const isPublic=document.getElementById("plPublic").value==="true";

  const wantN = (finalSeq&&finalSeq.length) ? finalSeq.length : Math.min(parseInt(el("balancedSize").value||"150",10), trimmed.length);
  const pins  = {1:"0ueNjvhtXGDFkJQ5WBQ4mE",5:"63dYSEftdSYwMAFBNfQYsA",40:"3NQuIFfQPhTICaXGYe5dAt",60:"7ltcrdlVsXyU5HU9VCAj6P"};

  for(const key of eds){
    const ed=EDITIONS[key];
    let keep=trimmed.filter(t=>coverageOk(t.id,ed,0));
    if(keep.length<wantN) keep=trimmed.filter(t=>coverageOk(t.id,ed,1));
    if(keep.length<wantN) keep=trimmed.filter(t=>coverageOk(t.id,ed,2));
    if(keep.length<wantN) keep=trimmed;

    const seq = (finalSeq&&finalSeq.length)
      ? balancedOrder(keep, pins, wantN, {noAdjacent:true})
      : balancedOrder(keep, pins, Math.min(wantN, keep.length), {noAdjacent:true});

    const uris=seq.map(t=>`spotify:track:${t.id}`);
    const name=`${base} (${wantN})${ed.suffix}`;
    log(`Edition ${key}: ${seq.length}曲を反映`);
    await putPlaylist(name, `${desc} ${ed.suffix}`, isPublic, uris, null);
  }
  alert("UK/US/EU/World の作成が完了しました。");
}

/*** ここから：ファイル取り込み版（CSV/XLSX → 130曲×4 → 既存ドラフトへ上書き） ***/
function getPlaylistId(input){
  const v=(input||"").trim();
  const m=v.match(/playlist\/([A-Za-z0-9]+)/);
  return m?m[1]:v;
}
function csvParse(text){
  const rows=[]; let i=0, cur="", inQ=false, row=[];
  while(i<text.length){
    const ch=text[i];
    if(ch==='\"'){ if(inQ && text[i+1]==='\"'){ cur+='\"'; i++; } else { inQ=!inQ; } }
    else if(ch===',' && !inQ){ row.push(cur); cur=""; }
    else if((ch==='\n' || ch==='\r') && !inQ){
      if(ch==='\r' && text[i+1]==='\n') i++;
      row.push(cur); rows.push(row); row=[]; cur="";
    }else{ cur+=ch; }
    i++;
  }
  if(cur.length||row.length) { row.push(cur); rows.push(row); }
  const header=rows.shift().map(h=>h.trim());
  return rows.map(r=>Object.fromEntries(header.map((h,idx)=>[h,(r[idx]??"").trim()])));
}
async function readFileAny(file){
  if(!file) throw new Error("ファイル未選択");
  const buf=await file.arrayBuffer();
  const name=(file.name||"").toLowerCase();
  if((name.endsWith(".xlsx")||name.endsWith(".xls")) && window.XLSX && XLSX.read){
    const wb=XLSX.read(buf,{type:"array"});
    const ws=wb.Sheets[wb.SheetNames[0]];
    return XLSX.utils.sheet_to_json(ws,{defval:""});
  }else{
    const text=new TextDecoder("utf-8").decode(buf);
    return csvParse(text);
  }
}
const low = s => (s||"").toString().toLowerCase();
const normISRC = s => low(s).replace(/\s|-/g,"").toUpperCase();
const normTitle = s => low(s).replace(/[\s\-\(\)\[\]\{\}_]+/g," ").trim();

function detectCols(rows){
  const heads = Object.keys(rows[0]||{});
  const find = (alts)=> heads.find(h => alts.some(a=> low(h).includes(a)));
  return {
    TITLE:  find(["track title","title","track name","original file name"])||heads[0],
    ARTIST: find(["track primary artists","primary artists","artists","artist"]),
    ALBUM:  find(["album title","release name","album"]),
    FORMAT: find(["album format","format"]),
    ISRC:   find(["isrc"]),
    UPC:    find(["upc"]),
    DATE:   find(["original release date","release date","date"]),
    GENRE:  find(["track main genre","main genre","genre"]),
    SUBGEN: find(["track main subgenre","main subgenre","sub-genre","subgenre"]),
    REMIX:  find(["remixer"])
  };
}
const remixRe=/\bremix(ed)?\b/i, mixOnlyRe=/\b(?:dj\s*)?mix\b/i;
const breaksRe=/\b(breaks?|break[-\s]?beat|big\s*beat|nu[-\s]*breaks?|electro[-\s]*breaks?|progressive\s*breaks?|funky[-\s]*breaks?|psy[-\s]*breaks?|acid\s*breaks?)\b/i;
function isRemixOnly(row,C){
  const t=row[C.TITLE]||"", r=row[C.REMIX]||"";
  const hasRemix = remixRe.test(t)||!!r;
  const hasMix   = mixOnlyRe.test(t);
  return hasRemix && !(hasMix && !/remix/i.test(t));
}
function isBreaks(row,C){
  const g=`${row[C.GENRE]||""} ${row[C.SUBGEN]||""}`, t=row[C.TITLE]||"", a=row[C.ALBUM]||"";
  return breaksRe.test(g)||breaksRe.test(t)||breaksRe.test(a);
}
function yearOK(row,C){
  const d=((row[C.DATE]||"")+"").slice(0,10);
  const y= parseInt(d.slice(0,4),10);
  return !isNaN(y)? y>=2010 : true;
}
function bucketByRecency(rows,C){
  const ms=rows.map(r=>Date.parse((r[C.DATE]||"")+"")||null).filter(Boolean);
  const min=Math.min(...ms), max=Math.max(...ms);
  return r=>{
    const t=Date.parse((r[C.DATE]||"")+"")||((min+max)/2);
    const z=(t-min)/Math.max(1,(max-min));
    return z;
  };
}
function styleBonus(row,C,region){
  const g=low(`${row[C.GENRE]||""} ${row[C.SUBGEN]||""}`);
  if(region==="EU"   && /(electro|tech|industrial|progressive)/.test(g)) return 0.05;
  if(region==="UK"   && /(rave|nu\s*break|breakbeat)/.test(g))           return 0.05;
  if(region==="US"   && /(electro|bass|funky)/.test(g))                   return 0.05;
  if(region==="WORLD"&& /(melod|psy)/.test(g))                            return 0.03;
  return 0;
}
function remixerTag(row,C){
  const r=(row[C.REMIX]||"").trim().toLowerCase();
  if(r) return r;
  const m=(row[C.TITLE]||"").match(/\((.+?)\s+remix\)/i);
  return m? m[1].trim().toLowerCase() : "";
}
function buildMetricScore(metrics){
  const cols = Object.keys(metrics[0]||{});
  const isSaveRate = c => /save/i.test(c) && /(rate|率)/i.test(c);
  const isPlays    = c => /(play|再生)/i.test(c) && !/rate/i.test(c);
  const srCols=cols.filter(isSaveRate), plCols=cols.filter(isPlays);
  const zminmax = arr=>{
    const v=arr.map(x=>Number(x)).filter(x=>!isNaN(x));
    if(v.length<3) return arr.map(()=>0.5);
    const mn=Math.min(...v), mx=Math.max(...v);
    if(mx===mn) return arr.map(()=>0.5);
    return arr.map(x=> isNaN(Number(x))?0.5 : (Number(x)-mn)/(mx-mn));
  };
  const srAvg = srCols.length ? metrics.map(r=> {
    const zs = srCols.map(c=>zminmax(metrics.map(rr=>rr[c])) );
    const i  = metrics.indexOf(r);
    return zs.map(z=>z[i]).reduce((a,b)=>a+b,0)/zs.length;
  }) : metrics.map(()=>0.5);
  const plAvg = plCols.length ? metrics.map(r=> {
    const zs = plCols.map(c=>zminmax(metrics.map(rr=>rr[c])) );
    const i  = metrics.indexOf(r);
    return zs.map(z=>z[i]).reduce((a,b)=>a+b,0)/zs.length;
  }) : metrics.map(()=>0.5);
  return srAvg.map((v,i)=> 0.55*v + 0.45*plAvg[i]);
}

async function fetchDraftPinIds(playlistId){
  const pins=[];
  if(!playlistId) return pins;
  try{
    let url=`https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100&offset=0`;
    while(url && pins.length<150){
      const d=await callSpotifyJSON(url,{}, {tag:`get pins ${playlistId}`});
      (d.items||[]).forEach(it=>{ const id=it?.track?.id; if(id) pins.push(id); });
      url=d.next||null;
    }
  }catch(_){}
  return [...new Set(pins)].slice(0,40); // ピンは最大40曲まで
}

async function buildFromFiles(){
  try{
    const fCsv=el('fileSourceCsv').files[0];
    const fMet=el('fileMetrics').files[0];
    if(!fCsv||!fMet){ alert("CSVと分析データの両方を選んでください"); return; }
    log("ファイル読込中…");
    const [src, met] = await Promise.all([readFileAny(fCsv), readFileAny(fMet)]);
    if(!src.length){ throw new Error("ソースCSVが空です"); }
    const C = detectCols(src);

    // 1) フィルタ
    let pool = src.filter(r=> isRemixOnly(r,C) && isBreaks(r,C) && yearOK(r,C));
    if(pool.length<130) pool = src.filter(r=> isRemixOnly(r,C) && yearOK(r,C));
    log(`候補 ${pool.length} 件`);

    // 2) 指標結合（ISRC→タイトル）
    const metByISRC=new Map(), metByTitle=new Map();
    const mHeads=Object.keys(met[0]||{});
    const mISRC = mHeads.find(h=> /isrc/i.test(h));
    const mTitle= mHeads[0];
    met.forEach(r=>{
      if(mISRC && r[mISRC]) metByISRC.set(normISRC(r[mISRC]), r);
      if(mTitle && r[mTitle]) metByTitle.set(normTitle(r[mTitle]), r);
    });

    const metricRows = pool.map(r=>{
      const kISRC = C.ISRC && r[C.ISRC] ? metByISRC.get(normISRC(r[C.ISRC])) : null;
      const kTitle= metByTitle.get(normTitle(r[C.TITLE]||"")) || null;
      return kISRC || kTitle || {};
    });
    const metricScore = buildMetricScore(metricRows);
    const recF = bucketByRecency(pool, C);
    const rec = pool.map(r=> recF(r));
    const balanced = metricScore.map((v,i)=> 0.55*v + 0.45*rec[i]);

    // 3) per-release cap=1（Single/EPのみ制限）
    const formatIs = s=> /^(single|ep|e\.p\.|eps)$/i.test((s||"")+"");
    const capKey = r => (C.UPC && r[C.UPC]) ? r[C.UPC] : (r[C.ALBUM]||"");
    const scored = pool.map((r,i)=> ({row:r, score:balanced[i]}));
    const singles = scored.filter(x=> formatIs(x.row[C.FORMAT]));
    const albums  = scored.filter(x=> !formatIs(x.row[C.FORMAT]));
    const keepSingles = [...new Map(singles
        .sort((a,b)=>b.score-a.score)
        .map(x=> [capKey(x.row), x])
    ).values()];
    const capped = keepSingles.concat(albums).sort((a,b)=>b.score-a.score);

    // 4) 地域別スコア + “ど定番Core 65” + 残り
    const regions=["EU","UK","US","WORLD"];
    const byRegion = {};
    for(const reg of regions){
      const withBias = capped.map(x=>{
        const bias = styleBonus(x.row, C, reg);
        return {...x, scoreReg: x.score + bias};
      }).sort((a,b)=>b.scoreReg-a.scoreReg);
      const core65 = new Set(withBias.slice(0,65).map(x=>x.row));
      const seenRemix=new Set();
      const rest = [];
      for(const x of withBias){
        if(core65.has(x.row)) continue;
        const tag = remixerTag(x.row,C);
        if(seenRemix.has(tag)) { if(Math.random()<0.5) continue; }
        seenRemix.add(tag);
        rest.push(x.row);
        if(rest.length>=220) break;
      }
      const pick = [...core65, ...rest].slice(0, 220);
      byRegion[reg] = pick;
    }

    // 5) ドラフトのピンを取得（あれば優先）
    const pinInputs={ EU:el('plEU').value, UK:el('plUK').value, US:el('plUS').value, WORLD:el('plWORLD').value };
    const pinIds = {};
    for(const reg of regions){
      const pid=getPlaylistId(pinInputs[reg]);
      pinIds[reg] = pid? await fetchDraftPinIds(pid) : [];
      if(pinIds[reg].length) log(`${reg}: 現行ドラフトから PIN ${pinIds[reg].length} 曲`);
    }

    // 6) Spotify検索でURI解決（ISRC→タイトルfallback）
    async function searchOne(row){
      const isrc = C.ISRC && row[C.ISRC] ? normISRC(row[C.ISRC]) : "";
      if(isrc){
        try{
          const q=`isrc:${encodeURIComponent(isrc)}`;
          const d=await callSpotifyJSON(`https://api.spotify.com/v1/search?type=track&limit=1&q=${q}`,{}, {tag:"search:isrc"});
          const t=d?.tracks?.items?.[0]; if(t&&t.uri) return t;
        }catch(_){}
      }
      const title=(row[C.TITLE]||"").replace(/\s+/g," ").trim();
      const artist=(row[C.ARTIST]||"").replace(/\s+/g," ").trim();
      const qParts=[];
      if(title) qParts.push(`track:"${title}"`);
      if(artist) qParts.push(`artist:"${artist}"`);
      qParts.push("remix");
      qParts.push("year:2010-2035");
      const q=encodeURIComponent(qParts.join(" "));
      const d=await callSpotifyJSON(`https://api.spotify.com/v1/search?type=track&limit=3&q=${q}`,{}, {tag:"search:title"});
      const items=d?.tracks?.items||[];
      items.sort((a,b)=>{
        const as = (a.name+" "+a.artists.map(x=>x.name).join(" ")).toLowerCase();
        const bs = (b.name+" "+b.artists.map(x=>x.name).join(" ")).toLowerCase();
        const ar = +(as.includes("remix"));
        const br = +(bs.includes("remix"));
        return br-ar;
      });
      return items[0]||null;
    }

    // 7) 各リージョン: 解決→features→並べ（リミキサー連続禁止、ピン尊重）
    const editionURIs={}, editionIDs={};
    for(const reg of regions){
      log(`URI解決中: ${reg}`);
      const rows = byRegion[reg];
      const resolved=[];
      for(const r of rows){
        try{ const t=await searchOne(r); if(t) resolved.push(t); }catch(_){}
        if(resolved.length>=190) break;
      }
      const ids = [...new Set(resolved.map(t=>t.id))].slice(0,200);
      // ピンIDと突合（解決済みの中に存在する分だけ）
      const draftPins = (pinIds[reg]||[]).filter(id=> ids.includes(id)).slice(0,40);

      const featsMap = new Map();
      for(let i=0;i<ids.length;i+=100){
        const part=ids.slice(i,i+100);
        try{
          const f=await callSpotifyJSON(`https://api.spotify.com/v1/audio-features?ids=${part.join(",")}`,{}, {tag:"features"});
          (f.audio_features||[]).forEach((x,j)=>{ if(x) featsMap.set(part[j],x); });
        }catch(_){}
      }
      const energy = id => (featsMap.get(id)?.energy ?? 0.58);
      const sortedE = ids.map(energy).sort((a,b)=>a-b);
      const q1=sortedE[Math.floor(sortedE.length*0.25)]||0.25;
      const q2=sortedE[Math.floor(sortedE.length*0.50)]||0.50;
      const q3=sortedE[Math.floor(sortedE.length*0.75)]||0.75;
      const bucket = e => e<=q1?0: e<=q2?1: e<=q3?2:3;

      // ピン位置（Core寄り）— ドラフトピンが優先、足りなければ上位から補完
      const pinsPos=[1,5,20,40,65,90,110,130];
      const pinIdsResolved = draftPins.length ? draftPins
        : ids.slice(0, Math.min(8, Math.floor(130*0.5/8)*8 || 8));

      const pinSet=new Set(pinIdsResolved);
      const bins=[[],[],[],[]];
      resolved.forEach(t=>{
        if(pinSet.has(t.id)) return;
        bins[bucket(energy(t.id))].push(t);
      });
      bins.forEach(b=>b.sort((a,b)=> (b.popularity||0)-(a.popularity||0)));

      const seq=new Array(130).fill(null);
      // ピン配置（解決順のまま）
      for(let i=0;i<Math.min(pinIdsResolved.length,pinsPos.length);i++){
        const id=pinIdsResolved[i];
        const t=resolved.find(x=>x.id===id);
        if(t) seq[pinsPos[i]-1]=t;
      }
      function remixTagOf(t){
        const name=(t?.name||"")+" "+(t?.artists?.map(x=>x.name).join(" ")||"");
        const m=name.match(/\((.+?)\s+remix\)/i);
        return m? m[1].toLowerCase() : "";
      }
      function pick(prev){
        const prevTag=prev?remixTagOf(prev):"";
        for(let r=0;r<4;r++){
          const bi=r;
          const arr=bins[bi];
          for(let i=0;i<arr.length;i++){
            const t=arr[i], tag=remixTagOf(t);
            if(prevTag && tag && prevTag===tag) continue;
            arr.splice(i,1);
            return t;
          }
        }
        for(let bi=0;bi<4;bi++){
          if(bins[bi].length) return bins[bi].shift();
        }
        return null;
      }
      for(let i=0;i<130;i++){
        if(seq[i]) continue;
        const prev=i?seq[i-1]:null;
        const t=pick(prev);
        if(!t) break;
        seq[i]=t;
      }
      const final=seq.filter(Boolean).slice(0,130);
      editionURIs[reg]=final.map(t=>`spotify:track:${t.id}`);
      editionIDs[reg]=final.map(t=>t.id);
      log(`${reg} 完成: ${final.length} 曲`);
    }

    // 保存
    window.__editionURIs = editionURIs;
    el('btnUpdateFromFiles').disabled=false;
    alert("OK：4エディションの最終候補を作りました。『各版を既存Playlistに上書き』を押してください。");
  }catch(e){
    log("ファイル処理エラー: "+(e.message||e));
    alert("エラー: "+(e.message||e));
  }
}

async function updateFromFiles(){
  if(!window.__editionURIs){ alert("先に『ファイルから最終版』を作ってください"); return; }
  const map={
    EU:   getPlaylistId(el('plEU').value),
    UK:   getPlaylistId(el('plUK').value),
    US:   getPlaylistId(el('plUS').value),
    WORLD:getPlaylistId(el('plWORLD').value)
  };
  for(const reg of Object.keys(map)){
    const pid=map[reg]; if(!pid) continue;
    const uris = window.__editionURIs[reg]||[];
    if(!uris.length){ log(`${reg}: 楽曲0`); continue; }
    log(`${reg}: ${uris.length}曲を ${pid} へ反映中…`);
    const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
    await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${pid}/tracks`,{method:"PUT",body:JSON.stringify({uris:chunks[0]||[]})},{tag:`PUT ${reg}`,expectJSON:false});
    for(let i=1;i<chunks.length;i++){
      await callSpotifyJSON(`https://api.spotify.com/v1/playlists/${pid}/tracks`,{method:"POST",body:JSON.stringify({uris:chunks[i]})},{tag:`POST ${reg} #${i+1}`});
    }
    log(`${reg}: 反映完了`);
  }
  alert("4エディション上書き完了！");
}

/*** クリック委任（PC用ボタンとモバイルドック連動） + 緊急系 ***/
document.addEventListener('click', async (e)=>{
  const btn=e.target.closest('button, a.btn'); if(!btn) return;
  const id=btn.id||btn.getAttribute('href')||'(no-id)'; log(`▶ click: ${id}`);
  if(btn.tagName==='A') return;
  e.preventDefault();
  try{
    switch(id){
      case 'mbFast': return void el('btnFast').click();
      case 'mbTrim': return void el('btnTrim').click();
      case 'mbBalance': return void el('btnBalance').click();
      case 'mbBuild': return void el('btnBuildEditions').click();
      case 'mbCommit': return void el('btnCommit').click();
      case 'btnMe': {
        try{ const me=await callSpotifyJSON('https://api.spotify.com/v1/me',{}, {tag:'/me'}); el('hudUser').textContent=`${me.display_name||'(no name)'} / ${me.id}`; }
        catch(err){ alert('Spotify 接続が必要です'); log('エラー: '+(err.message||err)); }
        break;
      }
      case 'btnSignOut': {
        try{ ['sp_access_token','sp_expires_at','sp_refresh_token','sp_scope','sp_token_type'].forEach(k=>sessionStorage.removeItem(k)); renderStatus(); log('保存トークンを削除しました'); }
        catch(err){ log('エラー: '+(err.message||err)); }
        break;
      }
      case 'btnFast': await doFastBuild(); break;
      case 'btnTrim': await doTrim(); break;
      case 'btnBalance': await doBalance(); break;
      case 'btnBuildEditions': await buildEditions(); break;
      case 'btnCommit': {
        const list=(finalSeq&&finalSeq.length)?finalSeq:trimmed;
        if(!list||!list.length) { alert('②Trim または ③Balanced を実行してください'); return; }
        const name=(el('plName').value || ((finalSeq&&finalSeq.length)?'TDCS – Breaks Remix Only (Balanced)':'TDCS – Breaks Remix Only (Trim)')).trim();
        const desc=(el('plDesc').value || ((finalSeq&&finalSeq.length)?'Breaks/Breakbeat限定・2010+・Remixのみ・Pins固定・Balanced':'Breaks/Breakbeat限定・2010+・Remixのみ・Trim')).trim();
        const isPublic=el('plPublic').value==='true';
        const existing=el('existingId').value.trim()||null;
        const uris=list.map(t=>`spotify:track:${t.id}`);
        await putPlaylist(name, desc, isPublic, uris, existing);
        break;
      }
      case 'btnBuildFromFiles': await buildFromFiles(); break;
      case 'btnUpdateFromFiles': await updateFromFiles(); break;
      case 'btnRepair': {
        try{
          ['sp_access_token','sp_expires_at','sp_refresh_token','sp_scope','sp_token_type'].forEach(k=>sessionStorage.removeItem(k));
          renderStatus(); log('🔧 緊急リセット: トークン類をクリアしました');
          alert('リセット完了。必要なら Connect してください。');
        }catch(err){ log('エラー: '+(err.message||err)); }
        break;
      }
    }
  }catch(err){ log('エラー: '+(err.message||err)); }
});

/*** 起動 ***/
(function boot(){
  log(`✅ index loaded: ${location.href}`);
  renderStatus();
  try{ if (window.matchMedia('(max-width: 720px)').matches) el('logBox').open=false; }catch(_){}
  const mirror=()=>['mbTrim','mbBalance','mbBuild','mbCommit'].forEach((id,i)=>{
    const src=['btnTrim','btnBalance','btnBuildEditions','btnCommit'][i];
    const s=el(src), d=el(id); if(s && d) d.disabled=s.disabled;
  });
  const mo=new MutationObserver(mirror);
  ['btnTrim','btnBalance','btnBuildEditions','btnCommit'].forEach(id=>{
    const b=el(id); if(!b) return;
    mo.observe(b,{attributes:true,attributeFilter:['disabled']});
  });
})();
</script>
</body>
</html>
