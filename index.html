<!doctype html>
<html lang="ja"><head>
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TDCS Editions Builder — 4×130 / 被りOK満数化（from_token無/403耐性/TDCS限定）</title>
<style>
:root{--bg:#0b1220;--fg:#cfe3ff}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;max-width:1180px;margin:32px auto;padding:0 12px}
h1{margin:0 0 8px}
fieldset{border:1px solid #ddd;border-radius:10px;padding:14px;margin:14px 0}
label{display:block;margin:6px 0}
input[type="text"],input[type="number"],select{width:100%;max-width:760px;padding:6px 8px;border:1px solid #ccc;border-radius:6px}
input[type="file"]{margin:4px 0}
button{padding:9px 12px;border:1px solid #bbb;border-radius:8px;background:#fff;cursor:pointer;margin:6px 8px 0 0}
button:disabled{opacity:.5;cursor:not-allowed}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
small.hint{color:#666}
#log{white-space:pre-wrap;background:var(--bg);color:var(--fg);padding:12px;border-radius:8px;min-height:280px;max-height:540px;overflow:auto}
#progWrap{position:relative;height:12px;background:#e6eaf2;border-radius:6px;overflow:hidden;margin:6px 0}
#progBar{height:100%;width:0%;background:#4a90e2;transition:width .2s ease}
#progLine{font-variant-numeric:tabular-nums;margin:4px 0 0 0;color:#333}
.hidden{display:none}
</style>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<h1>TDCS Editions Builder — 自動補充で 4×130（被りOK／バランス分配）</h1>
<p id="status">未接続</p>
<div>
  <button id="btnConnect">Spotifyにサインイン</button>
  <button id="btnReset">初期化（保存トークン削除）</button>
  <button id="btnCheck">接続チェック</button>
</div>

<fieldset>
  <legend>固定</legend>
  <div class="grid2">
    <label>CLIENT_ID <input type="text" value="1fd6350fcf4945a0b3ddffa2d5730d4e" disabled></label>
    <label>REDIRECT_URI <input type="text" value="https://npr2025.github.io/spotify-auth/callback.html" disabled></label>
  </div>
</fieldset>

<fieldset>
  <legend>設定（4リスト）</legend>
  <div class="grid2">
    <label>UK <input id="plUK" type="text" value="https://open.spotify.com/playlist/6wrsoYUr3IagrMW7zlwaIS"></label>
    <label>US <input id="plUS" type="text" value="https://open.spotify.com/playlist/6pv3J4odtKELYRIwoiZHhe"></label>
    <label>EU <input id="plEU" type="text" value="https://open.spotify.com/playlist/4VadrmkpMeXK813mkhWGwV"></label>
    <label>WORLD <input id="plWORLD" type="text" value="https://open.spotify.com/playlist/5y1UWtrBjYjHpReuAsnFMR"></label>
  </div>
  <div class="grid3">
    <label>API間隔(ms) <input id="gap" type="number" value="1200"></label>
    <label>各エディション出力数 <input id="finalN" type="number" value="130"></label>
    <label>人気の重み（SaveRate側）<input id="wPopularity" type="number" step="0.01" value="0.55"></label>
  </div>
  <div class="grid3">
    <label>UKプリセット
      <select id="presetUK"><option>waves</option><option selected>rise</option><option>drop</option><option>dj</option></select>
    </label>
    <label>USプリセット
      <select id="presetUS"><option selected>rise</option><option>waves</option><option>drop</option><option>dj</option></select>
    </label>
    <label>EUプリセット
      <select id="presetEU"><option selected>waves</option><option>rise</option><option>drop</option><option>dj</option></select>
    </label>
  </div>

  <label>主要マーケット（優先順・カンマ区切り）
    <input id="markets" type="text" value="AU,NZ,US,GB,ES,NL">
  </label>
  <small class="hint">例: AU,NZ,US,GB,ES,NL（左ほど優先）。未入力時の既定もこれ。</small>

  <div class="grid3">
    <label>同リミキサー最小間隔（曲）<input id="gapRemixer" type="number" value="3"></label>
    <label>同アーティスト最小間隔（曲）<input id="gapArtist" type="number" value="4"></label>
    <label><input id="appendDate" type="checkbox" checked> 新規名に日付（YYYY-MM-DD）</label>
  </div>

  <div>
    <label><input id="fastMode" type="checkbox" checked> 高速モード（検索マーケット最小化／早期終了）</label>
  </div>

  <div>
    <label><input id="allowCrossDupes" type="checkbox" checked> エディション間の相互非重複をオフ（＝各バージョンで被りOK）</label>
    <label><input id="allowRepeatFill"  type="checkbox" checked> 不足時は版内リピートで満数化（直前曲は避ける）</label>
  </div>

  <div>
    <label><input id="doUpdate" type="checkbox" checked> 既存4リストを上書き</label>
    <label><input id="doCreate" type="checkbox" checked> 同内容で新規4リストも作成（公開）</label>
    <label>新規リスト名の接頭辞 <input id="newPrefix" type="text" value="TDCS Editions"></label>
  </div>
  <small class="hint">※同じ録音（URI/ISRC/ベース曲名＋先頭アーティストID）は候補プール内ではユニーク化。ただし**版内リピート**は満数化のために許可（直前同一は回避）。TDCS（The Darrow Chem Syndicate）以外は除外。</small>
</fieldset>

<fieldset>
  <legend>ファイル</legend>
  <label>ソースCSV（任意）<input id="fileSource" type="file" accept=".csv"></label>
  <label>分析（Excel .xlsx / CSV）<input id="fileAnalytics" type="file" accept=".xlsx,.csv"></label>
  <small class="hint">列は自動検出。Exact→Fuzzy→Spotify検索→（TDCSの）Top/新譜/ディスコグ全件で自動補充。</small>
</fieldset>

<fieldset>
  <legend>進捗</legend>
  <div id="progWrap" class="hidden"><div id="progBar"></div></div>
  <div id="progLine">0% — 待機中</div>
</fieldset>

<fieldset>
  <legend>ログ</legend>
  <pre id="log">Booting…</pre>
</fieldset>

<div>
  <button id="btnExportXlsx" disabled>エクスポート（XLSX）</button>
  <button id="btnExportCsv"  disabled>エクスポート（CSV）</button>
</div>

<script>
/* ====== 例外 ====== */
window.onerror=(m,src,lin,col,err)=>{ const el=document.getElementById("log"); el.textContent+=(el.textContent?"\n":"")+"💥 ScriptError: "+m+" @"+lin+":"+col; console.error(err||m); };
window.addEventListener("unhandledrejection",(e)=>{ const el=document.getElementById("log"); el.textContent+=(el.textContent?"\n":"")+"💥 PromiseRejection: "+(e.reason&&e.reason.message?e.reason.message:String(e.reason)); console.error(e.reason); });

/* ====== 固定 ====== */
const FORCED_ARTIST_IDS=["55fvQ5I2IZUfcFT2DV02T3"]; // The Darrow Chem Syndicate
const zws=/[\u200B-\u200D\uFEFF]/g;
const CLIENT_ID="1fd6350fcf4945a0b3ddffa2d5730d4e".replace(zws,"").trim();
const REDIRECT_URI="https://npr2025.github.io/spotify-auth/callback.html".replace(zws,"").trim();
const SCOPES="playlist-modify-public playlist-modify-private ugc-image-upload";
const LS={acc:"sp_access_token",ref:"sp_refresh_token",exp:"sp_token_exp",ver:"sp_code_verifier"};

/* ====== DOM/UTIL ====== */
const $=(id)=>document.getElementById(id);
const log=(s)=>{const el=$("log"); el.textContent+=(el.textContent?"\n":"")+s; el.scrollTop=el.scrollHeight;}
const progress=(p,msg)=>{ $("progWrap").classList.remove("hidden"); $("progBar").style.width=Math.max(0,Math.min(100,p))+"%"; if(msg) $("progLine").textContent=Math.round(p)+"% — "+msg; }
const subProgress=(i,t,s,e,l)=>{ const f=t?i/t:0; progress(s+(e-s)*f,`${l} (${i}/${t})`); }
const sleep=(ms)=>new Promise(r=>setTimeout(r,ms));
const num=(x)=>{const s=String(x==null?0:x).replace(/[ %,，]/g,""); const v=parseFloat(s); return isFinite(v)?v:0;}
const round4=(x)=> (typeof x==="number"&&isFinite(x))?Math.round(x*10000)/10000:"";

/* ====== Auth ====== */
const isAuthed=()=> !!localStorage.getItem(LS.acc) && Date.now() < (+localStorage.getItem(LS.exp)||0)-5000;
function setStatus(){ $("status").textContent=isAuthed()?"接続中（OK）":"未接続"; if(isAuthed() && _pending) resolveAndWrite(_pending); }
async function startAuth(){
  // PKCE
  let v=""; const u8=new Uint8Array(64); crypto.getRandomValues(u8); for(let i=0;i<u8.length;i++) v+=String.fromCharCode(97+(u8[i]%26));
  localStorage.setItem(LS.ver,v);
  const h=new Uint8Array(await crypto.subtle.digest("SHA-256",new TextEncoder().encode(v)));
  let b=""; for(const x of h) b+=String.fromCharCode(x);
  const ch=btoa(b).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"");
  const u=new URL("https://accounts.spotify.com/authorize");
  u.searchParams.set("response_type","code"); u.searchParams.set("client_id",CLIENT_ID);
  u.searchParams.set("redirect_uri",REDIRECT_URI);
  u.searchParams.set("code_challenge_method","S256"); u.searchParams.set("code_challenge",ch);
  u.searchParams.set("scope",SCOPES);
  location.href=u.toString();
}
async function refreshTokenIfNeeded(){
  const exp=+(localStorage.getItem(LS.exp)||0);
  if(Date.now()<exp-5000) return;
  const rt=localStorage.getItem(LS.ref); if(!rt) return;
  const body=new URLSearchParams(); body.set("grant_type","refresh_token"); body.set("refresh_token",rt); body.set("client_id",CLIENT_ID);
  const r=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!r.ok){ log("⚠️ refresh失敗 "+r.status); return; }
  const j=await r.json();
  localStorage.setItem(LS.acc,j.access_token); localStorage.setItem(LS.exp,String(Date.now()+j.expires_in*1000));
  if(j.refresh_token) localStorage.setItem(LS.ref,j.refresh_token);
}
async function spFetch(path,method="GET",body=null){
  await refreshTokenIfNeeded();
  const gap=+($("gap").value||1200); await sleep(gap);
  for(let a=0;a<5;a++){
    const init={method,headers:{"Authorization":"Bearer "+localStorage.getItem(LS.acc),"Content-Type":"application/json"}};
    if(body) init.body=JSON.stringify(body);
    const r=await fetch("https://api.spotify.com"+path,init);
    if(r.status===401){ await refreshTokenIfNeeded(); continue; }
    if(r.status===429){ const ra=+(r.headers.get("Retry-After")||2); log("⏳429→"+ra+"s待機"); await sleep(ra*1000); continue; }
    if(!r.ok){
      const t=await r.text();
      if(r.status===403 && method==="GET"){ log(`⚠️ 403 GET ${path.slice(0,60)} … 続行`); return null; }
      throw new Error(`Spotify ${r.status}: ${(t||"").slice(0,200)} @ ${path}`);
    }
    if(r.status===204) return null;
    return await r.json();
  }
  throw new Error("Spotify API max retries");
}
let _me=null; async function getMe(){ if(_me) return _me; _me=await spFetch("/v1/me","GET"); return _me; }

/* ====== マーケット ====== */
function getMarkets(){
  const raw=($("markets")?.value||"").toUpperCase();
  const arr=raw.split(",").map(s=>s.trim()).filter(Boolean);
  const out=arr.length?arr:["AU","NZ","US","GB","ES","NL"];
  return Array.from(new Set(out));
}

/* ====== ファイル ====== */
let sourceRows=[], analyticsRows=[];
function readCSV(file){return new Promise((res,rej)=>Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>res(r.data),error:rej}));}
async function readXLSX_allSheets(file){
  const buf=await file.arrayBuffer(); const wb=XLSX.read(buf,{type:"array"}); let rows=[],details=[];
  for(const n of wb.SheetNames){ const js=XLSX.utils.sheet_to_json(wb.Sheets[n],{defval:""}); for(const r of js) r.__sheet=n; rows=rows.concat(js); details.push(n+":"+js.length); }
  return {rows,details};
}
async function loadFiles(){
  $("log").textContent=""; progress(3,"ファイル読み込み…");
  if($("fileSource").files.length){ sourceRows=await readCSV($("fileSource").files[0]); log("✅ ソース: "+sourceRows.length+" 行"); }
  const f=$("fileAnalytics").files[0];
  if((f.name||"").toLowerCase().endsWith(".xlsx")){ const r=await readXLSX_allSheets(f); analyticsRows=r.rows; log("✅ 分析: XLSX 合計 "+analyticsRows.length+" 行 ["+r.details.join(", ")+"]"); }
  else{ analyticsRows=await readCSV(f); log("✅ 分析: CSV "+analyticsRows.length+" 行"); }
  progress(8,"読み込み完了"); await runAnalysis();
}

/* ====== 正規化・列推定 ====== */
const ISRC_RE=/^[A-Z]{2}-?[A-Z0-9]{3}-?\d{2}-?\d{5}$/i;
const NFKC=(s)=>String(s||"").normalize("NFKC");
const rmMarks=(s)=>NFKC(s).normalize("NFD").replace(/[\u0300-\u036f]/g,"");
const norm=(s)=>rmMarks(s).toLowerCase().replace(/[‐-‒–—−]/g,"-").replace(/[‘’‚‛“”„‟"]/g," ").replace(/[()［］\[\]{}【】]/g," ").replace(/&/g," and ").replace(/\s+/g," ").trim();
const tokensTitle=(s)=>{s=norm(s).replace(/ - /g," ").replace(/\((.*?)\)/g," $1 ").replace(/\[(.*?)\]/g," $1 "); const arr=s.split(" "); const stop=new Set(["feat","featuring","ft","vs","and","&","the","a","an","mix","remix","edit","version","vip","dub","club","radio","extended","original","instrumental","clean","dirty"]); const set={},out=[]; for(const w of arr){ if(w && !stop.has(w)){ if(!set[w]){set[w]=1;out.push(w);} } } return out; }
function setJaccard(A,B){let inter=0,sa={},sb={}; A.forEach(x=>sa[x]=1); B.forEach(x=>sb[x]=1); for(const x in sa){ if(sb[x]) inter++; } const ua=Object.keys(sa).length+Object.keys(sb).length-inter; return ua?inter/ua:0; }
function canonVersion(s){
  s=norm(s); const pairs=[["original mix","original"],["orig mix","original"],["radio edit","radio"],["extended mix","extended"],["club mix","club"]];
  pairs.forEach(([a,b])=>s=s.replace(a,b));
  const kinds=[],seen={}; const add=k=>{if(k&&!seen[k]){kinds.push(k);seen[k]=1;}}
  if(/original/.test(s))add("original"); if(/radio/.test(s))add("radio"); if(/extended/.test(s))add("extended");
  if(/instrumental/.test(s))add("instrumental"); if(/acoustic/.test(s))add("acoustic"); if(/vip/.test(s))add("vip");
  if(/dub/.test(s))add("dub"); if(/club/.test(s))add("club"); if(/remix|rmx/.test(s))add("remix");
  const rem=s.replace(/\b(original|radio|extended|instrumental|acoustic|vip|dub|club|remix|mix|edit)\b/g," ").trim();
  return {kinds, remTok:tokensTitle(rem)};
}
const extractTrackId=(raw)=>{const s=String(raw||"").trim(); if(!s) return ""; let m=s.match(/spotify:track:([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/open\.spotify\.com\/track\/([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/\/track\/([A-Za-z0-9]{22})(?:\?|$)/); if(m) return m[1]; m=s.match(/^([A-Za-z0-9]{22})$/); if(m) return m[1]; return ""; }
function extractArtistIds(raw){
  if(raw==null) return []; const s=String(raw); const parts=s.split(/[,;\/|]+|\s{2,}/g); const ids=[],has={};
  const push=(id)=>{ if(id && !has[id]){ids.push(id);has[id]=1;} }
  for(const p0 of parts){
    const p=(p0||"").trim(); if(!p) continue;
    let m=p.match(/spotify:artist:([A-Za-z0-9]{22})/); if(m){push(m[1]); continue;}
    m=p.match(/open\.spotify\.com\/artist\/([A-Za-z0-9]{22})/); if(m){push(m[1]); continue;}
    m=p.match(/\b([A-Za-z0-9]{22})\b/); if(m){push(m[1]); continue;}
  }
  return ids;
}
function columns(rows){const s={},out=[]; for(let i=0;i<Math.min(400,rows.length);i++){ for(const k of Object.keys(rows[i])) if(!s[k]){s[k]=1; out.push(k);} } return out;}
function pickByName(cols,pref){ const L=cols.map(c=>[c,norm(c)]); for(const p of pref){const n=norm(p); const hit=L.find(([,m])=>m===n||m.includes(n)); if(hit) return hit[0];} return ""; }
function bestColOrEmpty(cols,scorer,min=0.15){let best=null,bs=-1; for(const c of cols){const sc=scorer(c); if(sc>bs){bs=sc; best=c;}} return (bs>=min)?best:"";}
function pickSourceColumns(rows){
  const cols=columns(rows);
  const scId=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<1200;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(/spotify:track:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/track\/[A-Za-z0-9]{22}/.test(v)||/^[A-Za-z0-9]{22}$/.test(v))m++;} return n?m/n:0;}
  const scIsrc=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<2000;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(ISRC_RE.test(v))m++;} return n?m/n:0;}
  const scAid=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<1500;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(/spotify:artist:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/artist\/[A-Za-z0-9]{22}/.test(v)||/\b([A-Za-z0-9]{22})\b/.test(v))m++;} return n?m/n:0;}
  return {
    idCol:bestColOrEmpty(cols,scId,0.20),
    isrcCol:bestColOrEmpty(cols,scIsrc,0.20),
    artistIdCol:bestColOrEmpty(cols,scAid,0.20),
    nameCol:pickByName(cols,["track title","track_name","title","曲名","タイトル"])||cols[0]||"",
    verCol: pickByName(cols,["track version","version","バージョン"]),
    artistCol:pickByName(cols,["track primary artists","primary artists","artists","artist","アーティスト"])||cols[0]||"",
    remixCol: pickByName(cols,["remixer","remixers","リミキサー"])
  };
}
function pickAnalyticColumns(rows){
  const cols=columns(rows);
  const scId=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<1200;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(/spotify:track:[A-Za-z0-9]{22}/.test(v)||/open\.spotify\.com\/track\/[A-Za-z0-9]{22}/.test(v)||/^[A-Za-z0-9]{22}$/.test(v))m++;} return n?m/n:0;}
  const scIsrc=c=>{let m=0,n=0; for(let i=0;i<rows.length&&i<2000;i++){const v=String(rows[i][c]||""); if(!v)continue; n++; if(ISRC_RE.test(v))m++;} return n?m/n:0;}
  const idCol=bestColOrEmpty(cols,scId,0.20)||pickByName(cols,["spotify_uri","track_uri","uri","url"]);
  const isrcCol=bestColOrEmpty(cols,scIsrc,0.20)||pickByName(cols,["isrc","isrc_code"]);
  function pickText(pref){const cand=cols.filter(c=>/title|name|曲名|artist|アーティスト/i.test(c)); return cand[0]||pickByName(cols,pref)||cols[0]||"";}
  return { idCol,isrcCol,nameCol:pickText(["title","track_name","曲名"]),artistCol:pickText(["artist","artists","アーティスト"]),
    p24:pickByName(cols,["plays_24h","p24","streams24","24h"]), p7:pickByName(cols,["plays_7d","p7","streams7","7d"]), p28:pickByName(cols,["plays_28d","p28","streams28","28d"]),
    s24:pickByName(cols,["save_rate_24h","sr24","save24"]), s7:pickByName(cols,["save_rate_7d","sr7","save7"]), s28:pickByName(cols,["save_rate_28d","sr28","save28"]),
    uk:pickByName(cols,["uk","available_uk","英国"]), us:pickByName(cols,["us","available_us","米国","アメリカ"]), eu:pickByName(cols,["eu","available_eu","欧州","ヨーロッパ"]), wo:pickByName(cols,["world","available_world","global","全世界"]) };
}

/* ====== TDCS判定 ====== */
function _hasTDCSOnArtists(arr){
  if(!Array.isArray(arr)) return false;
  return arr.some(a=>{
    const n=(a&&a.name)||"";
    return (a&&FORCED_ARTIST_IDS.includes(a.id))
        || /darrow\s*chem\s*syndicate/i.test(n)
        || /\bTDCS\b/i.test(n);
  });
}
function hasTDCSTrackObj(t){
  if(!t) return false;
  return _hasTDCSOnArtists(t.artists)
      || _hasTDCSOnArtists(t.album && t.album.artists)
      || /darrow\s*chem\s*syndicate|\bTDCS\b/i.test(t.name||"");
}

/* ====== 突合・スコア ====== */
function buildSourceIndex(cfg){
  if(!sourceRows.length) return {idxExact:new Map(),blob:[]};
  const idxExact=new Map(), blob=[]; let hasAid=0;
  for(const r of sourceRows){
    const id=cfg.idCol?extractTrackId(r[cfg.idCol]):"";
    const isrc=cfg.isrcCol?String(r[cfg.isrcCol]||"").trim().toUpperCase():"";
    const t=String(cfg.nameCol? r[cfg.nameCol] : "").trim(), v=String(cfg.verCol? r[cfg.verCol] : "").trim();
    const disp=(!v||/original\s*mix/i.test(v))?t:(t+" - "+v);
    const ttok=tokensTitle(disp);
    const vinfo=canonVersion(v+" "+String(cfg.remixCol? r[cfg.remixCol] : "" ));
    const aids=cfg.artistIdCol?extractArtistIds(r[cfg.artistIdCol]):[];
    if(aids.length) hasAid++;
    if(id) idxExact.set("ID:"+id,r);
    if(isrc) idxExact.set("ISRC:"+isrc,r);
    if(disp) idxExact.set("NM:"+norm(disp),r);
    blob.push({r,disp,ttok,vinfo,artistIds:aids});
  }
  log("🎯 アーティストID付き行: "+hasAid+" / "+sourceRows.length);
  return {idxExact, blob};
}
function parseAnalysisTitle(a,anCfg){
  const name=String(a[anCfg.nameCol]||""); const art=String(anCfg.artistCol? (a[anCfg.artistCol]||"") : "");
  return {disp:name+" "+art, ttok:tokensTitle(name+" "+art), vinfo:canonVersion(name)};
}
function fuzzyBest(sourceBlob,an){
  let best=null, tw=an.vinfo.kinds.length?0.75:0.85, vw=1-tw;
  for(const s of sourceBlob){
    const ts=setJaccard(an.ttok,s.ttok);
    const vk=setJaccard(an.vinfo.kinds,s.vinfo.kinds);
    const vr=setJaccard(an.vinfo.remTok,s.vinfo.remTok);
    const ver=0.6*vk+0.4*vr;
    const sc=tw*ts+vw*ver;
    if(!best || sc>best.sc) best={s:s,sc:sc};
  }
  return best;
}
function autoMatch(srcIdx,anCfg,onTick){
  const idA=anCfg.idCol, isrcA=anCfg.isrcCol;
  let thr=0.86, rows=[], diag=null, total=analyticsRows.length;
  for(;thr>=0.72;thr-=0.02){
    rows=[]; diag={exact:0,fuzzy:0,none:0};
    for(let j=0;j<analyticsRows.length;j++){
      const a=analyticsRows[j]; if(onTick&&((j+1)%20===0||j+1===total)) onTick(j+1,total);
      const id=idA?extractTrackId(a[idA]):"";
      const isc=isrcA?String(a[anCfg.isrcCol]||"").trim().toUpperCase():"";
      const an=parseAnalysisTitle(a,anCfg);
      let pick=null, mode="exact", score=1;
      if(id && srcIdx.idxExact.has("ID:"+id)) pick=srcIdx.idxExact.get("ID:"+id);
      else if(isc && srcIdx.idxExact.has("ISRC:"+isc)) pick=srcIdx.idxExact.get("ISRC:"+isc);
      else if(srcIdx.idxExact.has("NM:"+norm(an.disp))) pick=srcIdx.idxExact.get("NM:"+norm(an.disp));
      if(!pick){
        const b=fuzzyBest(srcIdx.blob,an);
        if(b && b.sc>=thr){ pick=b.s.r; mode="fuzzy"; score=b.sc; }
      }
      if(pick) rows.push({a,s:pick,_mode:mode,_score:score}); else diag.none++;
      if(pick && mode==="exact") diag.exact++; else if(pick) diag.fuzzy++;
    }
    if(rows.length/Math.max(1,total)>=0.5) break;
  }
  return {rows,thr,diag};
}
function computeScores(rows,anCfg){
  const p24=anCfg.p24,p7=anCfg.p7,p28=anCfg.p28,s24=anCfg.s24,s7=anCfg.s7,s28=anCfg.s28;
  let max24=0,max7=0,max28=0; rows.forEach(r=>{max24=Math.max(max24,num(r.a[p24])); max7=Math.max(max7,num(r.a[p7])); max28=Math.max(max28,num(r.a[p28]));});
  rows.forEach(r=>{
    const sr24=num(r.a[s24])/100, sr7=num(r.a[s7])/100, sr28=num(r.a[s28])/100;
    const pl24=max24?num(r.a[p24])/max24:0, pl7=max7?num(r.a[p7])/max7:0, pl28=max28?num(r.a[p28])/max28:0;
    const w=[0.5,0.3,0.2], wp=+($("wPopularity").value||0.55);
    r.score = wp*(w[0]*sr24+w[1]*sr7+w[2]*sr28) + (1-wp)*(w[0]*pl24+w[1]*pl7+w[2]*pl28);
  });
  rows.sort((a,b)=>(b.score||0)-(a.score||0)); return rows;
}
function buildItemFromMatch(m,srcCols,anCols){
  const t=String(srcCols.nameCol? m.s[srcCols.nameCol] : "").trim() || String(m.a[anCols.nameCol]||"").trim();
  const v=String(srcCols.verCol?  m.s[srcCols.verCol]  : "").trim();
  return {
    id: srcCols.idCol?extractTrackId(m.s[srcCols.idCol]):"",
    isrc: srcCols.isrcCol?String(m.s[srcCols.isrcCol]||"").toUpperCase():"",
    name: (!v||/original\s*mix/i.test(v))?t:(t+" - "+v),
    artist: String(srcCols.artistCol? m.s[srcCols.artistCol] : (m.a[anCols.artistCol]||"")),
    remixer: String(srcCols.remixCol? m.s[srcCols.remixCol] : ""),
    artistIds: FORCED_ARTIST_IDS.slice(0),
    flags:{ uk:anCols.uk?!!m.a[anCols.uk]:false, us:anCols.us?!!m.a[anCols.us]:false, eu:anCols.eu?!!m.a[anCols.eu]:false, wo:anCols.wo?!!m.a[anCols.wo]:false },
    score:m.score, _mode:m._mode, _score:m._score, a:m.a, s:m.s
  };
}
function buildItemsFromAnalyticsOnly(anCols){
  const out=[];
  for(const a of analyticsRows){
    const name=String(a[anCols.nameCol]||"").trim(); if(!name) continue;
    out.push({ id:extractTrackId(a[anCols.idCol]), isrc:String(a[anCols.isrcCol]||"").toUpperCase(),
      name, artist:String(a[anCols.artistCol]||"").trim(), remixer:"", artistIds:FORCED_ARTIST_IDS.slice(0),
      flags:{wo:true,uk:false,us:false,eu:false}, score:0.0001, _mode:"fallback", _score:1, a, s:null});
  }
  return out;
}

/* ====== 収集（TDCSのみ） ====== */
const keyOf=(it)=>{ const title=String(it.name||""); const artist=String(it.artist||""); const v=canonVersion(title); const base=(title.split(/\s+-\s+/)[0]||title); return norm(base+"|"+v.kinds.sort().join("+")+"|"+artist); }
function dedupeByMeta(list){
  const seen={}, seenId={}, seenIsrc={}, out=[]; let dropU=0,dropI=0,dropK=0;
  for(const it of list){
    if(it.id && seenId[it.id]){dropU++;continue;}
    if(it.isrc && seenIsrc[it.isrc]){dropI++;continue;}
    const k=keyOf(it); if(seen[k]){dropK++;continue;}
    out.push(it); if(it.id)seenId[it.id]=1; if(it.isrc)seenIsrc[it.isrc]=1; seen[k]=1;
  }
  log(`🧹 重複除去（候補）: 入${list.length}→残${out.length} [ID:${dropU},ISRC:${dropI},Key:${dropK}]`);
  return out;
}
async function gatherArtistIds(){ return FORCED_ARTIST_IDS.slice(0); }
async function fetchTopTracksByArtist(aid,market){ const r=await spFetch("/v1/artists/"+aid+"/top-tracks?market="+market,"GET"); return (r&&r.tracks)||[]; }
async function fetchAllArtistAlbums(aid, market){
  let out=[], seen=new Set(), groups="album,single,appears_on,compilation"; let offset=0, limit=50;
  while(true){
    const r=await spFetch(`/v1/artists/${aid}/albums?include_groups=${groups}&limit=${limit}&offset=${offset}&market=${market}`,"GET");
    const arr=(r&&r.items)||[]; for(const al of arr){ if(!seen.has(al.id)){ seen.add(al.id); out.push(al);} }
    if(!arr || arr.length<limit) break; offset+=limit;
  }
  return out;
}
async function fetchAllAlbumTracks(albumId, market){
  let out=[], offset=0, limit=50;
  while(true){
    const r=await spFetch(`/v1/albums/${albumId}/tracks?limit=${limit}&offset=${offset}&market=${market}`,"GET");
    const arr=(r&&r.items)||[]; out=out.concat(arr||[]);
    if(!arr || arr.length<limit) break; offset+=limit;
  }
  return out;
}
const itemFromTrackObj=(t,aid)=>({ id:t.id||"", isrc:"", name:t.name||"", artist:(t.artists&&t.artists[0]&&t.artists[0].name)||"", remixer:"", artistIds:aid?[aid]:[], flags:{wo:true}, score:0.0001, _mode:"seed" });

async function buildExtraFromArtists(artistIds,label){
  const mkts=getMarkets(); let out=[], done=0, total=artistIds.length*mkts.length;
  for(const aid of artistIds){
    for(const m of mkts){
      try{
        log(`…top/new 収集中: ${m} (${++done}/${total})`);
        const ts=await fetchTopTracksByArtist(aid,m); (ts||[]).forEach(t=>out.push(itemFromTrackObj(t,aid)));
        const al=await spFetch(`/v1/artists/${aid}/albums?include_groups=single,album&limit=20&market=${m}`,"GET");
        const albums=(al&&al.items)||[]; log(`…アルバム${albums.length}件: ${m}`);
        for(const a of albums.slice(0,6)){ const tr=await fetchAllAlbumTracks(a.id,m); (tr||[]).slice(0,6).forEach(t=>out.push(itemFromTrackObj(t,aid))); }
      }catch(e){ log(`⚠️ top/new ${m}: ${(e.message||e).toString().slice(0,120)}`); }
    }
  }
  log(`➕ 補充(${label}): +${out.length}`); return out;
}
const _artistNameCache=new Map();
async function getArtistName(aid){ if(_artistNameCache.has(aid)) return _artistNameCache.get(aid); const r=await spFetch("/v1/artists/"+aid,"GET"); const n=(r&&r.name)||""; _artistNameCache.set(aid,n); return n; }
async function buildExtraFromSearchArtist(artistIds,label,targetCount,currentCount){
  const fast = $("fastMode") && $("fastMode").checked;
  const base = getMarkets();
  const mkts = fast ? base : Array.from(new Set(base.concat(["DE","FR","IT","PT","IE"])));
  const MAX_PAGES = fast ? 4 : 12;
  let out=[];
  for(const aid of artistIds){
    const name=await getArtistName(aid);
    for(const m of mkts){
      try{
        for(let p=0;p<MAX_PAGES; p++){
          const q = `artist:"${name}"`;
          const r = await spFetch(`/v1/search?q=${encodeURIComponent(q)}&type=track&limit=50&offset=${p*50}&market=${m}`,"GET");
          const items=(r&&r.tracks&&r.tracks.items)||[];
          for(const t of items){ if(t && hasTDCSTrackObj(t)) out.push(itemFromTrackObj(t,aid)); }
          if(currentCount + out.length >= targetCount) break;
          if(!items || items.length<50) break;
        }
      }catch(e){ log(`⚠️ search ${m}: ${(e.message||e).toString().slice(0,120)}`); }
      if(currentCount + out.length >= targetCount) break;
    }
    if(currentCount + out.length >= targetCount) break;
  }
  log(`➕ 補充(search): +${out.length}`); return out;
}
async function buildExtraFromArtistsDeep(artistIds,label,targetCount,currentCount){
  const fast = $("fastMode") && $("fastMode").checked;
  const base = getMarkets();
  const mkts = fast ? base : Array.from(new Set(base.concat(["DE","FR","IT","PT","IE"])));
  const MAX_ALBUMS = fast ? 30 : 120;
  const MAX_TRACKS_PER_ALBUM = fast ? 3 : 10;
  let out=[];
  outer: for(const aid of artistIds){
    for(const m of mkts){
      log(`…discog 収集中: ${m} (累計${out.length})`);
      try{
        const albums = await fetchAllArtistAlbums(aid,m);
        for(let i=0;i<Math.min(MAX_ALBUMS, albums.length); i++){
          const tr = await fetchAllAlbumTracks(albums[i].id,m);
          for(const t of tr.slice(0, MAX_TRACKS_PER_ALBUM)){ if(hasTDCSTrackObj(t)) out.push(itemFromTrackObj(t,aid)); }
          if(currentCount + out.length >= targetCount) break outer;
        }
      }catch(e){ log(`⚠️ discog ${m}: ${(e.message||e).toString().slice(0,120)}`); }
    }
  }
  log(`➕ 補充(${label}): +${out.length}`); return out;
}
async function buildCandidatePool(primaryItems,anCols,finalN){
  let pool = dedupeByMeta(primaryItems);
  const needHard=finalN*4, targetSoft=needHard+80;
  log(`📦 候補プール開始: ${pool.length} / 目標 ${targetSoft}`);
  if(pool.length < targetSoft){
    const extraA = buildItemsFromAnalyticsOnly(anCols).sort((a,b)=>(b.score||0)-(a.score||0));
    pool = dedupeByMeta(pool.concat(extraA));
    log(`➕ 補充(analytics only): ${pool.length}`);
  }
  if(pool.length < targetSoft){
    const artistIds = await gatherArtistIds();
    log("🧲 収集ArtistID: "+artistIds.length);
    const extraB = await buildExtraFromArtists(artistIds,"top+new");
    pool = dedupeByMeta(pool.concat(extraB));
    log(`➕ 補充(top/new): ${pool.length}`);
  }
  if(pool.length < needHard){
    const artistIds = await gatherArtistIds();
    const extraS = await buildExtraFromSearchArtist(artistIds,"search", needHard, pool.length);
    pool = dedupeByMeta(pool.concat(extraS));
    log(`➕ 補充(search merged): ${pool.length}`);
  }
  if(pool.length < needHard){
    const artistIds = await gatherArtistIds();
    const extraC = await buildExtraFromArtistsDeep(artistIds,"discog", needHard, pool.length);
    pool = dedupeByMeta(pool.concat(extraC));
    log(`➕ 補充(discog): ${pool.length}`);
  }
  return pool.slice(0, Math.max(targetSoft, needHard));
}

/* ====== URI解決（TDCS限定） ====== */
const _isrcCache=new Map(); const _nameCache=new Map();
const isrcVariants=(s)=>{ s=String(s||"").trim(); if(!s) return []; const up=s.toUpperCase(); const no=up.replace(/-/g,""); const hy=up.indexOf("-")>=0?up:up.replace(/^(.{2})(.{3})(.{2})(.{5})$/,"$1-$2-$3-$4"); const set={},arr=[]; [up,no,hy].forEach(v=>{if(!set[v]){set[v]=1;arr.push(v);}}); return arr; }
const topArtistName=(a)=>{const s=String(a||""); const m=s.split(/,|;|&| with | feat\.? | featuring | ft\.? /i); return (m[0]||"").trim();}
function makeQueries(it){
  const q=[], full=String(it.name||"").trim(), base=(full.split(/\s+-\s+/)[0]||full), art=topArtistName(it.artist||"");
  if(it.isrc){ for(const v of isrcVariants(it.isrc)) q.push({q:"isrc:"+v,type:"isrc"}); }
  if(art){ q.push({q:`track:"${base}" artist:"${art}"`,type:"field"}); if(full!==base) q.push({q:`track:"${full}" artist:"${art}"`,type:"field"}); }
  q.push({q:`"${base}" ${art||""}`,type:"free"});
  q.push({q:base,type:"free"}); if(full!==base) q.push({q:full,type:"free"});
  return q;
}
async function searchOnce(q,m){ const r=await spFetch(`/v1/search?q=${encodeURIComponent(q)}&type=track&limit=10&market=${m}`,"GET"); return (r&&r.tracks&&r.tracks.items)?r.tracks.items:[]; }
function scoreCandidate(item,cand){
  const ct=cand.name+(cand.version?(" - "+cand.version):"");
  const t1=setJaccard(tokensTitle(item.name),tokensTitle(ct));
  const t2=setJaccard(tokensTitle((item.name.split(/\s+-\s+/)[0]||item.name)),tokensTitle(ct));
  const title=Math.max(t1,t2);
  const vi=canonVersion(item.name), vc=canonVersion(ct);
  const ver=0.6*setJaccard(vi.kinds,vc.kinds)+0.4*setJaccard(vi.remTok,vc.remTok);
  return 0.80*title+0.20*ver;
}
async function resolveUriOneStrict(it){
  if(it.id && it.id.length===22) return "spotify:track:"+it.id;
  if(it.isrc){ for(const v of isrcVariants(it.isrc)){ if(_isrcCache.has(v)) return _isrcCache.get(v); } }
  const full=String(it.name||"").trim();
  const baseTitle=(full.split(/\s+-\s+/)[0]||full);
  const art=topArtistName(it.artist||"");
  const keyNM=(baseTitle+"|"+art).toLowerCase();
  if(_nameCache.has(keyNM)) return _nameCache.get(keyNM);

  const fast = $("fastMode") && $("fastMode").checked;
  const base = getMarkets(); 
  const mkts = fast ? base : Array.from(new Set(base.concat(["DE","FR","IT","PT","IE"])));
  const qs   = makeQueries(it);
  const MAX_QUERIES = fast ? 6 : 10;

  let best=null;
  outer:
  for(const q of qs.slice(0,MAX_QUERIES)){
    for(const m of mkts){
      let items=[]; try{ items=await searchOnce(q.q,m) }catch(_){}
      for(const t of items){
        if(!hasTDCSTrackObj(t)) continue; // TDCS以外は候補にしない
        const sc = scoreCandidate(it,t) + 0.18; // TDCSボーナス
        if(!best || sc>best.sc) best={sc,cand:t};
        if(sc>=0.88) break outer;
      }
    }
  }
  if(best && best.cand && best.cand.id){
    const uri="spotify:track:"+best.cand.id;
    if(it.isrc) for(const v of isrcVariants(it.isrc)) _isrcCache.set(v,uri);
    _nameCache.set(keyNM,uri);
    return uri;
  }
  return "";
}
async function toUrisResolved(items,onTick){
  const aligned=new Array(items.length); let ok=0, total=items.length;
  for(let i=0;i<items.length;i++){
    const u=await resolveUriOneStrict(items[i]); if(u){aligned[i]=u; ok++;}
    if(onTick && (((i+1)%25)===0 || i+1===total)) onTick(i+1,total,ok);
  }
  log("🔗 URI解決: "+ok+"/"+total);
  return {aligned};
}

/* ====== 詳細・録音ユニーク ====== */
async function fetchTrackDetailsByUris(uris){
  const ids=[], map=new Map();
  for(const u of uris){ if(u) ids.push(u.replace("spotify:track:","")); }
  for(let i=0;i<ids.length;i+=50){
    const slice=ids.slice(i,i+50); if(!slice.length) continue;
    const r=await spFetch("/v1/tracks?ids="+slice.join(","),"GET");
    const arr=(r&&r.tracks)||[]; for(const t of arr){ if(t&&t.id) map.set("spotify:track:"+t.id,t); }
  }
  return map;
}
const baseTitle=(s)=>{s=String(s||""); const m=s.split(/\s+-\s+/); return (m[0]||"").trim();}
function dedupeByRecording(items,alignedUris,tracksMap,strictMarket){
  const seenUri={}, seenIsrc={}, seenBase={}, outItems=[], outUris=[];
  let dropU=0,dropI=0,dropB=0, dropNotTDCS=0, dropNoMarket=0;
  const mkts = getMarkets();
  for(let i=0;i<alignedUris.length;i++){
    const u=alignedUris[i]; if(!u) continue;
    const tr=tracksMap.get(u);
    const okTDCS = hasTDCSTrackObj(tr);
    if(!okTDCS){ dropNotTDCS++; continue; }
    let okMarket=true;
    if(tr && Array.isArray(tr.available_markets) && mkts.length){
      okMarket = mkts.some(m=>tr.available_markets.includes(m));
    }
    if(strictMarket && !okMarket){ dropNoMarket++; continue; }
    if(seenUri[u]){dropU++; continue;}
    const isrc=(tr&&tr.external_ids&&tr.external_ids.isrc)?String(tr.external_ids.isrc).toUpperCase():"";
    if(isrc && seenIsrc[isrc]){dropI++; continue;}
    const base = tr ? (norm(baseTitle(tr.name))+"｜"+((tr.artists&&tr.artists[0]&&tr.artists[0].id)||""))
                    : (norm(baseTitle(items[i]&&items[i].name))+"｜"+(items[i]&&items[i].artist||""));
    if(seenBase[base]){dropB++; continue;}
    seenUri[u]=1; if(isrc) seenIsrc[isrc]=1; seenBase[base]=1;
    outItems.push(items[i]); outUris.push(u);
  }
  log(`🧽 レコーディング重複除去: -URI:${dropU} -ISRC:${dropI} -Base:${dropB} -非TDCS:${dropNotTDCS} -不可地域:${dropNoMarket}`);
  return {items:outItems, uris:outUris};
}

/* ====== 特徴量・順序 ====== */
async function fetchAudioFeaturesByUris(uris){
  const ids=[], feats=new Map(); for(const u of uris){ if(u) ids.push(u.replace("spotify:track:","")); }
  for(let i=0;i<ids.length;i+=100){
    const slice=ids.slice(i,i+100); if(!slice.length) continue;
    const r=await spFetch("/v1/audio-features?ids="+slice.join(","),"GET");
    const arr=(r&&r.audio_features)||[]; for(const f of arr){ if(f&&f.id) feats.set("spotify:track:"+f.id,f); }
  }
  return feats;
}
const camelot=(key,mode)=>({num:[8,3,10,5,0,7,2,9,4,11,6,1][(key||0)%12],isMinor:mode===0});
const keyDistance=(a,b)=>{ if(!a||!b||a.key==null||b.key==null) return 2; const A=camelot(a.key,a.mode), B=camelot(b.key,b.mode); let d=Math.abs(A.num-B.num); d=Math.min(d,12-d); let pen=d/6; if(A.isMinor!==B.isMinor) pen+=0.4; return pen; }
function nextCost(a,b,preset){
  const dTempo=(a&&b&&a.tempo&&b.tempo)?Math.min(1,Math.abs(a.tempo-b.tempo)/16):0.5;
  const dKey=keyDistance(a,b); const dEner=(a&&b)?Math.abs((a.energy||0)-(b.energy||0)):0.5;
  const dVal=(a&&b)?Math.abs((a.valence||0)-(b.valence||0)):0.5;
  if(preset==="dj")   return 0.45*dTempo+0.35*dKey+0.15*dEner+0.05*dVal;
  if(preset==="rise") return 0.35*dTempo+0.20*dKey+0.35*dEner+0.10*dVal;
  if(preset==="drop") return 0.35*dTempo+0.20*dKey+0.35*dEner+0.10*dVal;
  return               0.40*dTempo+0.25*dKey+0.25*dEner+0.10*dVal;
}
function orderFlow(items,featMap,preset,gapA,gapR,seed){
  function lcg(s){let x=0;for(let i=0;i<s.length;i++)x=(x*131+s.charCodeAt(i))>>>0; return ()=>{x=(1103515245*x+12345)>>>0; return (x/0xFFFFFFFF);} }
  const rnd=lcg(seed||"ed");
  let pool=items.slice(0).sort((a,b)=>(b.score||0)-(a.score||0));
  const skip=Math.min(3,Math.floor(rnd()*5)); if(pool.length>skip) pool=pool.slice(skip).concat(pool.slice(0,skip));
  if(pool.length===0) return [];
  const seq=[pool.shift()]; const lastSeen={remixer:{},artist:{}};
  const mark=(it,i)=>{ lastSeen.remixer[String(it.remixer||"").toLowerCase()]=i; lastSeen.artist[String(it.artist||"").toLowerCase()]=i; }
  mark(seq[0],0);
  while(pool.length){
    const prev=seq[seq.length-1]; let bestIdx=0, best=1e9;
    for(let i=0;i<Math.min(50,pool.length);i++){
      const cand=pool[i], fa=featMap.get(cand.uri)||{}, fb=featMap.get(prev.uri)||{};
      let cost=nextCost(fb,fa,preset);
      const rm=String(cand.remixer||"").toLowerCase(), ar=String(cand.artist||"").toLowerCase();
      const iR=(lastSeen.remixer[rm]!=null?lastSeen.remixer[rm]:-999), iA=(lastSeen.artist[ar]!=null?lastSeen.artist[ar]:-999);
      const idx=seq.length;
      if(idx-iR < (gapR||3)) cost+=0.8;
      if(idx-iA < (gapA||4)) cost+=0.6;
      cost*=1+(i*0.002);
      if(cost<best){best=cost; bestIdx=i;}
    }
    const pick=pool.splice(bestIdx,1)[0]; seq.push(pick); mark(pick,seq.length-1);
  }
  return seq;
}

/* ====== 分配（相互非重複オプション） ====== */
const edCfg=()=>[
  {name:"UK",    pref:"uk", fallback:["wo","us","eu"], preset:($("presetUK").value||"waves"), gapA:+($("gapArtist").value||4), gapR:+($("gapRemixer").value||3), seed:"UK"},
  {name:"US",    pref:"us", fallback:["wo","uk","eu"], preset:($("presetUS").value||"rise"),  gapA:+($("gapArtist").value||4), gapR:+($("gapRemixer").value||3), seed:"US"},
  {name:"EU",    pref:"eu", fallback:["wo","uk","us"], preset:($("presetEU").value||"waves"), gapA:+($("gapArtist").value||4), gapR:+($("gapRemixer").value||3), seed:"EU"},
  {name:"WORLD", pref:"wo", fallback:["uk","us","eu"], preset:"dj",                             gapA:+($("gapArtist").value||4), gapR:+($("gapRemixer").value||3), seed:"WORLD"}
];
function edScoreBias(item,feat,edName){
  const base=item.score||0, e=(feat&&feat.energy)||0, v=(feat&&feat.valence)||0;
  if(edName==="US")   return base + 0.10*e + 0.03*v;
  if(edName==="UK")   return base + 0.06*e + 0.05*v;
  if(edName==="EU")   return base + 0.02*e + 0.08*(1-Math.abs(v-0.5));
  if(edName==="WORLD")return base + 0.05*(1-Math.abs(e-0.6));
  return base;
}
function buildEditionSetsRoundRobin(candidates, feats, finalN){
  const allowCrossDupes = $("allowCrossDupes").checked;
  const usedGlobal=new Set(), packs={UK:[],US:[],EU:[],WORLD:[]};
  const cfgs=edCfg();
  const poolFor=(ed)=>{
    const pref=candidates.filter(x=> (allowCrossDupes || !usedGlobal.has(x.uri)) && x.flags && x.flags[ed.pref]);
    const fb=candidates.filter(x=> (allowCrossDupes || !usedGlobal.has(x.uri)) && x.flags && ed.fallback.some(k=>x.flags[k]));
    const rest=candidates.filter(x=> (allowCrossDupes || !usedGlobal.has(x.uri)) && (!x.flags || (!x.flags.uk&&!x.flags.us&&!x.flags.eu&&!x.flags.wo)));
    const pool=pref.concat(fb).concat(rest);
    pool.sort((a,b)=> (edScoreBias(b,feats.get(b.uri)||{},ed.name))-(edScoreBias(a,feats.get(a.uri)||{},ed.name)));
    return pool;
  }
  const queues={}; cfgs.forEach(ed=>queues[ed.name]=poolFor(ed));
  const filled={UK:0,US:0,EU:0,WORLD:0}; let done=0, guard=0;
  while(done<4 && guard<20000){
    guard++;
    for(const ed of cfgs){
      if(filled[ed.name] >= finalN) continue;
      let q=queues[ed.name], pick=null;
      for(let i=0;i<q.length;i++){ const x=q[i]; if(allowCrossDupes || !usedGlobal.has(x.uri)){ pick=q.splice(i,1)[0]; break; } }
      if(!pick){ queues[ed.name]=poolFor(ed); q=queues[ed.name];
        for(let i=0;i<q.length;i++){ const x=q[i]; if(allowCrossDupes || !usedGlobal.has(x.uri)){ pick=q.splice(i,1)[0]; break; } }
      }
      if(pick){ packs[ed.name].push(pick); if(!allowCrossDupes) usedGlobal.add(pick.uri); filled[ed.name]++; }
    }
    done = (filled.UK>=finalN) + (filled.US>=finalN) + (filled.EU>=finalN) + (filled.WORLD>=finalN);
    if(Object.values(filled).reduce((a,b)=>a+b,0) >= finalN*4) break;
    if(queues.UK.length+queues.US.length+queues.EU.length+queues.WORLD.length===0) break;
  }
  log("⚖️ 分配(初期): UK="+packs.UK.length+", US="+packs.US.length+", EU="+packs.EU.length+", WORLD="+packs.WORLD.length);
  return packs;
}

/* ====== 不足穴埋め（版内リピート可） ====== */
function topUpWithRepeats(packs, candidates, feats, finalN){
  const allowRepeatFill = $("allowRepeatFill").checked;
  if(!allowRepeatFill) return packs;

  const eds=["UK","US","EU","WORLD"];
  for(const ed of eds){
    const need = finalN - packs[ed].length;
    if(need<=0) continue;

    // 補充プール：まずその版に入った曲、次に全候補（順序バイアス適用）
    const biasSort=(arr)=>arr.slice(0).sort((a,b)=>
      (edScoreBias(b,feats.get(b.uri)||{},ed))-(edScoreBias(a,feats.get(a.uri)||{},ed)));
    const seeds = packs[ed].length ? biasSort(packs[ed]) : biasSort(candidates.filter(x=>!!x.uri));

    if(seeds.length===0){ log(`⚠️ ${ed}: シード0 → 補充不能`); continue; }

    // 直前同一URI回避しつつ回転
    let k=0;
    while(packs[ed].length < finalN){
      const cand = seeds[k % seeds.length];
      const last = packs[ed][packs[ed].length-1];
      if(!last || last.uri !== cand.uri){
        packs[ed].push(cand);
      }else{
        // 直前と同一なら次候補
        k++;
        continue;
      }
      k++;
      if(k>100000){ log(`⚠️ ${ed}: 補充ループガード`); break; }
    }
    log(`➕ 補填(リピート): ${ed} → ${packs[ed].length}/${finalN}`);
  }
  return packs;
}

/* ====== 書き込み & エクスポート ====== */
const extractPlaylistId=(s)=>{s=String(s||""); let m=s.match(/playlist\/([A-Za-z0-9]{22})/); if(m) return m[1]; m=s.match(/^([A-Za-z0-9]{22})$/); if(m) return m[1]; return ""; }
async function replacePlaylist(pid,uris){
  const chunks=[]; for(let i=0;i<uris.length;i+=100) chunks.push(uris.slice(i,i+100));
  if(!chunks.length) chunks.push([]);
  await spFetch("/v1/playlists/"+pid+"/tracks","PUT",{uris:chunks[0]}); log("🧹 置換: "+chunks[0].length+"件");
  for(let k=1;k<chunks.length;k++){ await spFetch(`/v1/playlists/${pid}/tracks`,"POST",{uris:chunks[k]}); log("➕ 追加: "+chunks[k].length+"件"); }
}
async function createPlaylistAndFill(name,desc,isPublic,uris){
  const me=await getMe();
  const pl=await spFetch("/v1/users/"+encodeURIComponent(me.id)+"/playlists","POST",{name,description:desc,public:true});
  const pid=(pl&&pl.id)?pl.id:""; await replacePlaylist(pid,uris); return pid;
}
let _exportData=null; const enableExportButtons=(on)=>{ $("btnExportXlsx").disabled=!on; $("btnExportCsv").disabled=!on; }
function exportXlsx(){
  if(!_exportData){log("ℹ️ データなし");return;}
  const wb=XLSX.utils.book_new();
  const add=(name,key)=>{ const ws=XLSX.utils.json_to_sheet(_exportData[key],{header:["position","edition","title","artist","remixer","isrc","source_id","source_sheet","match_mode","match_score","spotify_uri","score","tempo","energy","valence","key","mode"]}); XLSX.utils.book_append_sheet(wb,ws,name); }
  add("UK","uk"); add("US","us"); add("EU","eu"); add("WORLD","wo");
  XLSX.writeFile(wb,"editions_"+new Date().toISOString().slice(0,10)+".xlsx");
}
function exportCsv(){
  if(!_exportData){log("ℹ️ データなし");return;}
  const all=[].concat(_exportData.uk,_exportData.us,_exportData.eu,_exportData.wo);
  const H=["position","edition","title","artist","remixer","isrc","source_id","source_sheet","match_mode","match_score","spotify_uri","score","tempo","energy","valence","key","mode"];
  const esc=(v)=>'"'+String(v==null?"":v).replace(/"/g,'""')+'"';
  const rows=[H.join(",")]; for(const r of all){ rows.push(H.map(h=>esc(r[h])).join(",")); }
  const blob=new Blob([rows.join("\r\n")],{type:"text/csv;charset=utf-8"}); const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download="editions_"+new Date().toISOString().slice(0,10)+".csv"; document.body.appendChild(a); a.click(); a.remove();
}

/* ====== メイン ====== */
let _pending=null;
async function runAnalysis(){
  try{
    progress(10,"列検出…");
    const srcCols=sourceRows.length?pickSourceColumns(sourceRows):{idCol:"",isrcCol:"",artistIdCol:"",nameCol:"",verCol:"",artistCol:"",remixCol:""};
    const srcIdx=buildSourceIndex(srcCols);
    const anCols=pickAnalyticColumns(analyticsRows);

    progress(28,"突合（Exact→Fuzzy）…");
    const match=autoMatch(srcIdx,anCols,(i,t)=>subProgress(i,t,28,50,"突合中"));
    log(`🔎 診断: exact=${match.diag.exact}, fuzzy=${match.diag.fuzzy}, 未一致=${match.diag.none}, 採用=${match.rows.length}/${analyticsRows.length}, しきい値=${match.thr.toFixed(2)}`);

    progress(51,"候補整形→スコア…");
    let items=[];
    if(match.rows.length){
      const scored=computeScores(match.rows,anCols);
      items=scored.map(m=>buildItemFromMatch(m,srcCols,anCols));
    }else{
      items=buildItemsFromAnalyticsOnly(anCols).sort((a,b)=>(b.score||0)-(a.score||0));
    }

    progress(56,"候補プール拡張（TDCSのみ）…");
    const finalN=+($("finalN").value||130);
    const pool=await buildCandidatePool(items,anCols,finalN);

    progress(64,"URI解決（TDCS限定・回数制限）…");
    const res=await toUrisResolved(pool,(i,t,ok)=>progress(64+(8*(i/t)),"URI解決 ("+i+"/"+t+")"));

    progress(72,"曲詳細→録音ユニーク（市場ゆるめ）…");
    const trackMap=await fetchTrackDetailsByUris(res.aligned.filter(Boolean));
    const usable=pool.map((it,idx)=>Object.assign({},it,{uri:res.aligned[idx]})).filter(x=>x.uri);
    let dedRec=dedupeByRecording(usable, usable.map(x=>x.uri), trackMap, /*strictMarket*/ false);

    // 必要数まで自動追加
    const needTotal = finalN*4;
    if (dedRec.uris.length < needTotal) {
      log(`🔁 追加補充: ${needTotal}まであと ${needTotal - dedRec.uris.length} 曲 — search→discog の順`);
      const artistIds = await gatherArtistIds();

      progress(73,"追加: search");
      const extraS = await buildExtraFromSearchArtist(artistIds, "search+", needTotal, dedRec.uris.length);
      const extraPool1 = dedupeByMeta(extraS);
      const res1 = await toUrisResolved(extraPool1, (i,t)=>progress(73+(2*(i/t)),"追加: search URI解決 ("+i+"/"+t+")"));
      const map1 = await fetchTrackDetailsByUris(res1.aligned.filter(Boolean));
      const usable1 = extraPool1.map((it,i)=>Object.assign({},it,{uri:res1.aligned[i]})).filter(x=>x.uri);
      let merged = dedupeByRecording({items:dedRec.items.concat(usable1), uris:dedRec.uris.concat(usable1.map(x=>x.uri))}.items, {items:dedRec.items.concat(usable1), uris:dedRec.uris.concat(usable1.map(x=>x.uri))}.uris, map1, /*strictMarket*/ false);

      if (merged.uris.length < needTotal) {
        progress(74,"追加: discog");
        const extraD = await buildExtraFromArtistsDeep(artistIds, "discog+", needTotal, merged.uris.length);
        const extraPool2 = dedupeByMeta(extraD);
        const res2 = await toUrisResolved(extraPool2, (i,t)=>progress(74+(2*(i/t)),"追加: discog URI解決 ("+i+"/"+t+")"));
        const mapAll = await fetchTrackDetailsByUris(res2.aligned.filter(Boolean));
        const usable2 = extraPool2.map((it,i)=>Object.assign({},it,{uri:res2.aligned[i]})).filter(x=>x.uri);
        const joined2 = { items: merged.items.concat(usable2), uris: merged.uris.concat(usable2.map(x=>x.uri)) };
        dedRec = dedupeByRecording(joined2.items, joined2.uris, mapAll, /*strictMarket*/ false);
      } else {
        dedRec = merged;
      }
      log(`📈 追加後ユニーク: ${dedRec.uris.length} 曲`);
    }

    // 十分集まっていれば最終段で市場厳密化
    const strictTry = dedupeByRecording(dedRec.items, dedRec.uris, trackMap, /*strictMarket*/ true);
    if (strictTry.uris.length >= needTotal) {
      dedRec = strictTry;
      log(`🌍 市場一致後ユニーク: ${dedRec.uris.length} 曲（strict適用）`);
    } else {
      log(`🌍 市場一致は保留: まずは曲数優先（${strictTry.uris.length}/${needTotal}）`);
    }

    progress(78,"Audio Features 取得…");
    let feats; try{ feats=await fetchAudioFeaturesByUris(dedRec.uris); }catch(e){ log("⚠️ audio-features 取得スキップ: "+(e.message||e)); feats=new Map(); }

    progress(84,"エディション分配（初期）…");
    let packs=buildEditionSetsRoundRobin(dedRec.items.map((it,i)=>Object.assign({},it,{uri:dedRec.uris[i]})), feats, finalN);

    // 不足は必ず埋める（版内リピート可）
    packs = topUpWithRepeats(packs, dedRec.items.map((it,i)=>Object.assign({},it,{uri:dedRec.uris[i]})), feats, finalN);

    progress(88,"曲順最適化…");
    const seqUK=orderFlow(packs.UK,feats,($("presetUK").value||"waves"),+($("gapArtist").value||4),+($("gapRemixer").value||3),"UK|"+new Date().toISOString().slice(0,10));
    const seqUS=orderFlow(packs.US,feats,($("presetUS").value||"rise"), +($("gapArtist").value||4),+($("gapRemixer").value||3),"US|"+new Date().toISOString().slice(0,10));
    const seqEU=orderFlow(packs.EU,feats,($("presetEU").value||"waves"),+($("gapArtist").value||4),+($("gapRemixer").value||3),"EU|"+new Date().toISOString().slice(0,10));
    const seqWO=orderFlow(packs.WORLD,feats,"dj",+($("gapArtist").value||4),+($("gapRemixer").value||3),"WORLD|"+new Date().toISOString().slice(0,10));

    function pack(items,edName){
      const out=[]; for(let i=0;i<items.length;i++){ const it=items[i], f=feats.get(it.uri)||{};
        out.push({position:i+1,edition:edName,title:it.name||"",artist:it.artist||"",remixer:it.remixer||"",isrc:it.isrc||"",source_id:it.id||"",source_sheet:(it.a&&it.a.__sheet)||"",match_mode:it._mode||"",match_score:round4(it._score||1),spotify_uri:it.uri,score:round4(it.score),tempo:round4(f.tempo),energy:round4(f.energy),valence:round4(f.valence),key:(f.key==null?"":f.key),mode:(f.mode==null?"":f.mode)});
      } return out;
    }
    _exportData={uk:pack(seqUK,"UK"),us:pack(seqUS,"US"),eu:pack(seqEU,"EU"),wo:pack(seqWO,"WORLD")};
    enableExportButtons(true);

    if(isAuthed()) await resolveAndWrite({UK:seqUK,US:seqUS,EU:seqEU,WORLD:seqWO});
    else { _pending={UK:seqUK,US:seqUS,EU:seqEU,WORLD:seqWO}; log("🔑 接続待ち：『Spotifyにサインイン』→『接続チェック』"); }
  }catch(e){
    log("⚠️ runAnalysis 続行可能エラー: "+(e.message||e));
    try{ if(_pending) await resolveAndWrite(_pending) }catch(_){}
    progress(100,"完了(一部スキップ)");
  }
}

async function resolveAndWrite(packs){
  try{
    if(!packs) packs=_pending; if(!packs){log("ℹ️ 続行データなし");return;}
    const toUris=(list)=>list.map(x=>x.uri);

    // 相互重複の計測（許容時は情報のみ）
    const allowCrossDupes = $("allowCrossDupes").checked;
    const all=[].concat(packs.UK,packs.US,packs.EU,packs.WORLD), uniq=new Set(); let dup=0;
    for(const x of all){ if(uniq.has(x.uri)) dup++; else uniq.add(x.uri); }
    log(`🔒 相互重複: ${dup} 件（${allowCrossDupes?"許容":"0が正常"}）`);

    const pidUK=extractPlaylistId($("plUK").value), pidUS=extractPlaylistId($("plUS").value), pidEU=extractPlaylistId($("plEU").value), pidWO=extractPlaylistId($("plWORLD").value);

    if($("doUpdate").checked){
      progress(90,"上書き: UK…"); await replacePlaylist(pidUK,toUris(packs.UK));
      progress(93,"上書き: US…"); await replacePlaylist(pidUS,toUris(packs.US));
      progress(95,"上書き: EU…"); await replacePlaylist(pidEU,toUris(packs.EU));
      progress(97,"上書き: WORLD…"); await replacePlaylist(pidWO,toUris(packs.WORLD));
      log("✅ 既存4リスト 上書き完了");
    }
    if($("doCreate").checked){
      progress(98,"新規作成…");
      const pre=($("newPrefix").value||"TDCS Editions").trim();
      const ds=$("appendDate").checked?(" "+new Date().toISOString().slice(0,10)):"";
      const pU=await createPlaylistAndFill(pre+" — UK"+ds,"Auto-created by TDCS Editions Builder",true,toUris(packs.UK));
      const pS=await createPlaylistAndFill(pre+" — US"+ds,"Auto-created by TDCS Editions Builder",true,toUris(packs.US));
      const pE=await createPlaylistAndFill(pre+" — EU"+ds,"Auto-created by TDCS Editions Builder",true,toUris(packs.EU));
      const pW=await createPlaylistAndFill(pre+" — WORLD"+ds,"Auto-created by TDCS Editions Builder",true,toUris(packs.WORLD));
      log("🆕 新規:\n  UK   → https://open.spotify.com/playlist/"+pU+"\n  US   → https://open.spotify.com/playlist/"+pS+"\n  EU   → https://open.spotify.com/playlist/"+pE+"\n  WORLD→ https://open.spotify.com/playlist/"+pW);
    }

    progress(100,"完了"); log("✅ 完了（TDCS限定／被りOK満数化／AU-NZ-US-GB-ES-NL優先／4×130）");
    _pending=null;
  }catch(e){ progress(100,"エラー"); log("💥 ERROR(resolveAndWrite): "+e.message); console.error(e); }
}

/* ====== イベント ====== */
$("btnConnect").onclick=startAuth;
$("btnReset").onclick=()=>{ for(const k in LS) localStorage.removeItem(LS[k]); setStatus(); log("🧽 ローカルトークン削除"); };
$("btnCheck").onclick=async()=>{ try{ await refreshTokenIfNeeded(); const me=await spFetch("/v1/me","GET"); $("status").textContent="接続中（"+(me.display_name||me.id)+")"; log("✅ API確認 OK"); if(_pending) await resolveAndWrite(_pending); }catch(e){ log("⚠️ 接続エラー: "+e.message); } };
$("fileSource").addEventListener("change",()=>{ if($("fileAnalytics").files.length) loadFiles(); });
$("fileAnalytics").addEventListener("change",()=>{ if($("fileAnalytics").files.length) loadFiles(); });
$("btnExportXlsx").onclick=exportXlsx; $("btnExportCsv").onclick=exportCsv;
setStatus();
log("Ready. 読込→突合→TDCS補充(analytics/top/new/search/discog)→AU/NZ/US/GB/ES/NL優先URI解決→録音ユニーク(市場は最後に厳密)→分配→不足は版内リピートで満数→曲順→上書き/新規→CSV/XLSX。");
</script>
</body></html>
