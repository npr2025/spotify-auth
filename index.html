<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TDCS Primary Seek — Batch & Adaptive Cooldown Auditor</title>
<link rel="preconnect" href="https://accounts.spotify.com"/>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans JP';margin:2rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;margin-bottom:1rem}
  .row{display:flex;flex-wrap:wrap;gap:1rem;align-items:center}
  button{padding:.6rem 1rem;border-radius:8px;border:1px solid #999;background:#111;color:#fff;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=file]{border:1px dashed #bbb;padding:.75rem;border-radius:8px;background:#fafafa}
  code,.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace}
  .muted{color:#666}.ok{color:#0a7f29}.bad{color:#b00020}
  progress{width:100%;height:14px}
  table{border-collapse:collapse;width:100%}th,td{border:1px solid #eee;padding:.5rem;font-size:.9rem;text-align:left}
  .pill{display:inline-block;padding:.1rem .5rem;border:1px solid #ccc;border-radius:999px;font-size:.8rem;background:#f6f6f6}
  .small{font-size:.85rem}
</style>
</head>
<body>
<header class="card">
  <h1>TDCS Primary Seek — Batch & Adaptive Cooldown Auditor</h1>
  <div class="small muted">Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> | Redirect: <code>https://npr2025.github.io/spotify-auth/callback.html</code></div>
  <div class="row"><a href="./auth.html"><button>Spotifyに接続</button></a><span id="authStatus" class="muted">未接続</span></div>
</header>

<section class="card">
  <h2>CSV & 実行設定</h2>
  <div class="row">
    <input type="file" id="csvFile" accept=".csv"/>
    <label>最小間隔(ms)：<input id="minDelayMs" type="number" value="1800" step="50" style="width:7rem"></label>
    <label>最大バックオフ(ms)：<input id="maxBackoffMs" type="number" value="20000" step="500" style="width:7rem"></label>
    <label>最大リトライ：<input id="maxRetries" type="number" value="8" step="1" style="width:5rem"></label>
    <label>RPM上限：<input id="rpmCap" type="number" value="15" step="5" style="width:5rem"></label>
    <label>429連発クールダウン(ms)：<input id="cooldownMs" type="number" value="90000" step="5000" style="width:8rem"></label>
  </div>
  <div class="row">
    <label><input id="suspiciousOnly" type="checkbox" checked> 疑わしいものだけトラック走査（推奨）</label>
    <label><input id="scanAllTracks" type="checkbox"> 全アルバムでトラック走査（重い）</label>
    <button id="startBtn" disabled>監査スタート</button>
  </div>
  <div id="fileInfo" class="small muted"></div>
</section>

<section class="card">
  <h2>進捗 <span id="ratePill" class="pill">idle</span></h2>
  <progress id="prog" value="0" max="100"></progress>
  <div id="log" class="mono" style="white-space:pre-wrap;max-height:260px;overflow:auto"></div>
</section>

<section class="card">
  <h2>エクスポート</h2>
  <button id="downloadBtn" disabled>詳細CSVダウンロード</button>
  <div class="small muted">
    列: <code>spotify_url,UPC,Album title,Album version,Track title,album_type,album_artist_count,album_artists,album_artist_ids,tracks_total,tracks_with_tdcs,tracks_without_tdcs,track_artists_distinct,track_artists_distinct_ex_tdcs,album_all_track_artists,album_all_track_artists_ex_tdcs,tracks_multiple_primary_count,tracks_multiple_primary_ratio,per_track_primary_artists,per_track_non_tdcs_artists,detailed_reasons</code>
  </div>
</section>

<section class="card">
  <h2>プレビュー（10行）</h2>
  <table id="previewTbl"><thead></thead><tbody></tbody></table>
</section>

<script>
/*** CONFIG ***/
const TARGET_ARTIST_ID="55fvQ5I2IZUfcFT2DV02T3";

/*** UI utils ***/
const $=sel=>document.querySelector(sel);
function log(m){ const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function setRate(t){ $("#ratePill").textContent=t; }
function setAuthStatus(ok,txt){ const el=$("#authStatus"); el.textContent=txt; el.className=ok?'ok':'bad'; }
function token(){ const raw=localStorage.getItem('sp_token'); if(!raw) return null; try{const o=JSON.parse(raw); if(Date.now()<o.expires_at) return o.access_token;}catch{} return null;}
function rowsToCSV(rows){ if(!rows.length) return ''; const H=Object.keys(rows[0]); const esc=v=>(v==null?'':'"'+String(v).replace(/"/g,'""')+'"'); return [H.map(esc).join(','),...rows.map(r=>H.map(h=>esc(r[h])).join(','))].join('\r\n');}
function setPreview(rows){ const thead=$("#previewTbl thead"), tbody=$("#previewTbl tbody"); thead.innerHTML=''; tbody.innerHTML=''; const samp=rows.slice(0,10); if(!samp.length) return; const H=Object.keys(samp[0]); const tr=document.createElement('tr'); H.forEach(h=>{const th=document.createElement('th'); th.textContent=h; tr.appendChild(th)}); thead.appendChild(tr); samp.forEach(r=>{const trb=document.createElement('tr'); H.forEach(h=>{const td=document.createElement('td'); td.textContent=(r[h]==null?'':r[h]); trb.appendChild(td)}); tbody.appendChild(trb)})}

/*** Rate-limited fetch with adaptive cooldown ***/
let lastCall=0, consec429=0, globalCooldownUntil=0;
async function api(path, params={}){
  const tkn=token(); if(!tkn) throw new Error('No token');
  let minDelay=+$("#minDelayMs").value||1800;
  const maxBackoff=+$("#maxBackoffMs").value||20000;
  const maxRetries=+$("#maxRetries").value||8;
  let rpmCap=+$("#rpmCap").value||15;
  const cooldownBase=+$("#cooldownMs").value||90000;

  const perReqMs=Math.max(1000, Math.ceil(60000/Math.max(1,rpmCap)));
  let backoff=minDelay, attempt=0;

  while(true){
    attempt++;

    // global cooldown window
    const now=Date.now();
    if(now<globalCooldownUntil){
      const wait=globalCooldownUntil-now; setRate('GLOBAL cooldown '+wait+'ms'); await new Promise(r=>setTimeout(r,wait));
    }

    // rpm gate
    const wait=Math.max(0, lastCall+perReqMs - Date.now());
    if(wait>0){ setRate('rpm gate '+wait+'ms'); await new Promise(r=>setTimeout(r,wait)); }
    lastCall=Date.now();

    // build URL
    const url=new URL('https://api.spotify.com'+path);
    Object.entries(params).forEach(([k,v])=> v!=null && url.searchParams.set(k,v));

    let res, text;
    try{
      res=await fetch(url,{headers:{Authorization:'Bearer '+tkn}});
      text=await res.text();
    }catch(e){
      if(attempt>maxRetries) throw new Error('Network error after retries: '+(e.message||e));
      const delay=Math.min(backoff, maxBackoff);
      log('net err → '+delay+'ms'); await new Promise(r=>setTimeout(r,delay)); backoff=Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    if(res.ok && res.status!==429){
      consec429=0;
      const left=minDelay-(Date.now()-lastCall); if(left>0){ setRate('throttle '+left+'ms'); await new Promise(r=>setTimeout(r,left)); }
      setRate('ok');
      try{return JSON.parse(text);}catch{return text;}
    }

    // parse body
    let body; try{ body=JSON.parse(text);}catch{ body=text;}

    if(res.status===429){
      consec429++;
      const ra=parseFloat(res.headers.get('Retry-After')||'0'); // sec
      let delay = ra? ra*1000 : backoff;

      // Adaptive: after 3+ consecutive 429 without RA, halve RPM cap & raise minDelay, and apply global cooldown
      if(consec429>=3 && !ra){
        rpmCap = Math.max(5, Math.floor(rpmCap*0.7));
        $("#rpmCap").value = rpmCap;
        minDelay = Math.min(maxBackoff, Math.floor(minDelay*1.25));
        $("#minDelayMs").value = minDelay;
        const hard = Math.max(delay, cooldownBase);
        globalCooldownUntil = Date.now() + hard;
        log(`429 x${consec429} → rpmCap=${rpmCap}, minDelay=${minDelay}ms, HARD cooldown ${hard}ms`);
        setRate('429 HARD cooldown '+hard+'ms');
        await new Promise(r=>setTimeout(r, hard));
      }else{
        log('429 backoff '+delay+'ms');
        setRate('429 wait '+delay+'ms');
        await new Promise(r=>setTimeout(r, delay));
      }
      backoff=Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    if(res.status>=500 && res.status<600){
      if(attempt>maxRetries) throw new Error('HTTP '+res.status+' after '+attempt+' attempts');
      const delay=Math.min(backoff, maxBackoff);
      log(res.status+' → retry '+delay+'ms'); setRate(res.status+' wait '+delay+'ms');
      await new Promise(r=>setTimeout(r, delay)); backoff=Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    throw new Error('HTTP '+res.status+': '+(typeof body==='string'?body:JSON.stringify(body)));
  }
}

/*** CSV col detection ***/
function detectCols(header){
  const lc=header.map(h=>String(h||'').toLowerCase());
  const pick=(...c)=>{ for(const x of c){ const i=lc.indexOf(String(x).toLowerCase()); if(i>-1) return header[i]; } return null; };
  return { url: pick('spotify_url','url','link'),
           upc: pick('upc','UPC'),
           isrc: pick('isrc','ISRC'),
           album: pick('album title','album'),
           version: pick('album version','version'),
           track: pick('track title','track') };
}
function parseSpotifyUrl(u){ try{ const m=u.match(/open\.spotify\.com\/(album|track)\/([A-Za-z0-9]+)/); if(m) return {type:m[1], id:m[2]}; }catch(e){} return null; }

/*** caches ***/
const upcCache=new Map(), isrcCache=new Map(), albumAuditCache=new Map();

/*** search helpers ***/
async function findByUPC(upc){
  if(!upc) return null; if(upcCache.has(upc)) return upcCache.get(upc);
  const res=await api('/v1/search',{q:'upc:'+upc, type:'album', limit:1});
  let out=null; if(res.albums?.items?.length){ const a=res.albums.items[0]; out={albumId:a.id, url:a.external_urls.spotify}; }
  upcCache.set(upc,out); return out;
}
async function findByISRC(isrc){
  if(!isrc) return null; if(isrcCache.has(isrc)) return isrcCache.get(isrc);
  const res=await api('/v1/search',{q:'isrc:'+isrc, type:'track', limit:1});
  let out=null; if(res.tracks?.items?.length){ const t=res.tracks.items[0]; out={trackId:t.id, albumId:t.album.id, url:t.external_urls.spotify, albumUrl:t.album.external_urls.spotify}; }
  isrcCache.set(isrc,out); return out;
}
async function findByText(row,cols){
  const parts=[]; if(cols.album && row[cols.album]) parts.push('album:"'+String(row[cols.album]).trim()+'"');
  parts.push('artist:"The Darrow Chem Syndicate"'); if(cols.version && row[cols.version]) parts.push('"'+String(row[cols.version]).trim()+'"');
  const res=await api('/v1/search',{q:parts.join(' '), type:'album', limit:1});
  if(res.albums?.items?.length){ const a=res.albums.items[0]; return {albumId:a.id, url:a.external_urls.spotify}; }
  return null;
}

/*** batch album metadata ***/
async function batchGetAlbums(ids){
  const chunks=[]; for(let i=0;i<ids.length;i+=20) chunks.push(ids.slice(i,i+20));
  const meta=new Map();
  for(const ch of chunks){
    const res=await api('/v1/albums',{ids:ch.join(',')});
    (res.albums||[]).forEach(a=>{
      meta.set(a.id,{ album_type:a.album_type, album_artists:(a.artists||[]).map(x=>({id:x.id,name:x.name})) });
    });
  }
  return meta;
}

/*** fetch album tracks (once) ***/
async function getAlbumTracksDetail(albumId){
  if(albumAuditCache.has(albumId)) return albumAuditCache.get(albumId);
  // first get metadata (may already exist via batch)
  let meta = null;
  const aMeta = await api('/v1/albums/'+albumId);
  meta = { album_type:aMeta.album_type, album_artists:(aMeta.artists||[]).map(x=>({id:x.id,name:x.name})) };

  let items=[], offset=0, limit=50, page;
  do{
    page=await api(`/v1/albums/${albumId}/tracks`,{limit, offset});
    items=items.concat(page.items||[]); offset+=limit;
  }while(page && page.next);

  const setAllIds=new Set(), setNonTdcsIds=new Set();
  const setAllNames=new Set(), setNonTdcsNames=new Set();
  let tracksWithTDCS=0, tracksWithoutTDCS=0, multiPrimary=0;
  const trackNames=[], trackArtistNamesPerTrack=[];

  (items||[]).forEach(tr=>{
    const ids=(tr.artists||[]).map(ar=>ar.id);
    const names=(tr.artists||[]).map(ar=>ar.name);
    if(ids.includes(TARGET_ARTIST_ID)) tracksWithTDCS++; else tracksWithoutTDCS++;
    if(ids.length>1) multiPrimary++;
    ids.forEach(id=> setAllIds.add(id));
    names.forEach((nm,ix)=>{ const id=ids[ix]; if(nm) setAllNames.add(nm); if(id!==TARGET_ARTIST_ID){ setNonTdcsIds.add(id); if(nm) setNonTdcsNames.add(nm); }});
    trackNames.push(tr.name||''); trackArtistNamesPerTrack.push(names);
  });

  const out={
    album_type: meta.album_type,
    album_artists: meta.album_artists,
    tracks_total:(items||[]).length,
    tracks_with_tdcs, tracks_without_tdcs,
    track_artists_count:setAllIds.size,
    track_artists_count_ex_tdcs:setNonTdcsIds.size,
    all_track_artist_names:Array.from(setAllNames),
    all_track_artist_names_ex_tdcs:Array.from(setNonTdcsNames),
    tracks_multiple_primary_count:multiPrimary,
    tracks_multiple_primary_ratio: ((items?.length||0)>0? multiPrimary/(items.length):0),
    trackNames, trackArtistNamesPerTrack
  };
  albumAuditCache.set(albumId,out); return out;
}

/*** reason builder ***/
function buildReasons(a){
  const NON_TDCS_UNIQUE_THRESHOLD=4, MULTI_PRIMARY_TRACKS_THRESHOLD=0.4;
  const rs=[];
  if(!a) return ['album fetch failed'];
  const isComp=a.album_type && a.album_type.toLowerCase()==='compilation';
  if(isComp) rs.push('album_type=compilation');
  if((a.album_artists||[]).length>1) rs.push('multiple album artists: '+(a.album_artists||[]).length);
  if((a.tracks_without_tdcs||0)>0) rs.push(`tracks without TDCS primary: ${a.tracks_without_tdcs}/${a.tracks_total||0}`);
  if((a.track_artists_count_ex_tdcs||0)>=NON_TDCS_UNIQUE_THRESHOLD) rs.push(`many distinct non-TDCS track artists: ~${a.track_artists_count_ex_tdcs}`);
  if((a.tracks_multiple_primary_ratio||0)>=MULTI_PRIMARY_TRACKS_THRESHOLD){
    const pct=Math.round(a.tracks_multiple_primary_ratio*100);
    rs.push(`many tracks with multiple primary artists: ${a.tracks_multiple_primary_count}/${a.tracks_total} (~${pct}%)`);
  }
  if(!rs.length) rs.push('no strong compilation indicators');
  return rs;
}

/*** main ***/
let _rows=[], _cols={}, _out=[];
$("#csvFile").addEventListener('change', ev=>{
  const f=ev.target.files[0]; if(!f) return;
  $("#fileInfo").textContent = `${f.name} / ${(f.size/1024).toFixed(1)} KB`;
  Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{
    _rows=res.data||[]; _cols=detectCols(res.meta.fields||[]);
    $("#startBtn").disabled=false;
    log('CSV loaded: '+_rows.length+' rows');
    log('Detected columns: '+JSON.stringify(_cols));
  }});
});

$("#startBtn").addEventListener('click', runAudit);

async function runAudit(){
  if(!token()){ alert('先にSpotify認証'); return; }
  const prog=$("#prog"); prog.max=_rows.length;

  // 1) resolve to album IDs (dedup keys)
  const keyToAlbum=new Map(), albumIdsSet=new Set();
  function keyForRow(row){
    if(_cols.url && row[_cols.url]){ const u=String(row[_cols.url]).trim(); const p=parseSpotifyUrl(u); if(p) return (p.type==='album'?'album:':'track:')+p.id; }
    if(_cols.upc && row[_cols.upc]) return 'upc:'+String(row[_cols.upc]).trim();
    if(_cols.isrc && row[_cols.isrc]) return 'isrc:'+String(row[_cols.isrc]).trim();
    const a=(_cols.album&&row[_cols.album])? String(row[_cols.album]).trim() : '';
    const v=(_cols.version&&row[_cols.version])? String(row[_cols.version]).trim() : '';
    return 'text:'+a+'|'+v;
  }
  const uniqueKeys=[]; const seen=new Set();
  for(const row of _rows){ const k=keyForRow(row); if(!seen.has(k)){seen.add(k); uniqueKeys.push(k);} }
  log('Unique keys: '+uniqueKeys.length);

  // resolve each key to album id (search/track lookup minimized)
  for(const k of uniqueKeys){
    try{
      let albumId=null, url='';
      if(k.startsWith('album:')){ albumId=k.split(':')[1]; url='https://open.spotify.com/album/'+albumId; }
      else if(k.startsWith('track:')){ const trackId=k.split(':')[1]; const tr=await api('/v1/tracks/'+trackId); albumId=tr.album.id; url=tr.album.external_urls.spotify; }
      else if(k.startsWith('upc:')){ const r=await findByUPC(k.slice(4)); if(r){albumId=r.albumId; url=r.url;} }
      else if(k.startsWith('isrc:')){ const r=await findByISRC(k.slice(5)); if(r){albumId=r.albumId; url=r.albumUrl||r.url;} }
      else { const [a,v]=k.slice(5).split('|'); const dummy={}; dummy[_cols.album]=a; dummy[_cols.version]=v; const r=await findByText(dummy,_cols); if(r){albumId=r.albumId; url=r.url;} }
      if(albumId){ keyToAlbum.set(k,{albumId,url}); albumIdsSet.add(albumId); }
    }catch(e){ log('Resolve err: '+k+' → '+(e.message||e)); }
  }

  const albumIds=[...albumIdsSet];
  log('Unique albums to audit: '+albumIds.length);

  // 2) batch-get album metadata
  const metaMap = await batchGetAlbums(albumIds);

  // decide which albums need track scan
  const suspiciousOnly = $("#suspiciousOnly").checked && !$("#scanAllTracks").checked;
  const needTracks=new Set();
  for(const id of albumIds){
    const m=metaMap.get(id);
    if(!m){ needTracks.add(id); continue; } // unknown → scan
    const albumArtists=(m.album_artists||[]).map(x=>x.id);
    const isCompilation = (m.album_type||'').toLowerCase()==='compilation';
    const tdcsOnly = (albumArtists.length===1 && albumArtists[0]===TARGET_ARTIST_ID);
    if($("#scanAllTracks").checked){ needTracks.add(id); }
    else if(!suspiciousOnly){ needTracks.add(id); }
    else {
      // “疑わしいものだけ”＝TDCS単独のアルバムはトラック走査（track多人数で倒れる可能性が高い）
      // compilationや複数Album Artistはメタだけで理由が立つので走査省略
      if(tdcsOnly) needTracks.add(id);
    }
  }

  // 3) fetch tracks only for selected albums
  for(const id of needTracks){ await getAlbumTracksDetail(id); }

  // 4) build result per row
  _out=[];
  for(let i=0;i<_rows.length;i++){
    const row=_rows[i];
    let albumId='', spotifyUrl='';
    const k = (function(){
      if(_cols.url && row[_cols.url]){ const u=String(row[_cols.url]).trim(); const p=parseSpotifyUrl(u); if(p) return (p.type==='album'?'album:':'track:')+p.id; }
      if(_cols.upc && row[_cols.upc]) return 'upc:'+String(row[_cols.upc]).trim();
      if(_cols.isrc && row[_cols.isrc]) return 'isrc:'+String(row[_cols.isrc]).trim();
      const a=(_cols.album&&row[_cols.album])? String(row[_cols.album]).trim() : '';
      const v=(_cols.version&&row[_cols.version])? String(row[_cols.version]).trim() : '';
      return 'text:'+a+'|'+v;
    })();
    const res=keyToAlbum.get(k);
    if(res){ albumId=res.albumId; spotifyUrl=res.url; }

    let a=null;
    if(albumId){
      a = albumAuditCache.get(albumId);
      if(!a){
        const m=metaMap.get(albumId) || {album_type:'',album_artists:[]};
        a = {
          album_type: m.album_type||'',
          album_artists: m.album_artists||[],
          tracks_total: '', tracks_with_tdcs:'', tracks_without_tdcs:'',
          track_artists_count:'', track_artists_count_ex_tdcs:'',
          all_track_artist_names:[], all_track_artist_names_ex_tdcs:[],
          tracks_multiple_primary_count:'', tracks_multiple_primary_ratio:'', trackNames:[], trackArtistNamesPerTrack:[]
        };
      }
    }
    const reasons = buildReasons(a);

    // per-track strings
    let perTrackPrimary='', perTrackNonTdcs='';
    if(a && a.trackArtistNamesPerTrack){
      for(let j=0;j<a.trackArtistNamesPerTrack.length;j++){
        const list=a.trackArtistNamesPerTrack[j]||[];
        const non=list.filter(nm => (a.all_track_artist_names_ex_tdcs||[]).includes(nm));
        perTrackPrimary += `${a.trackNames[j]||''} — ${list.join(' ; ')} | `;
        perTrackNonTdcs += `${a.trackNames[j]||''} — ${non.join(' ; ')} | `;
      }
      perTrackPrimary=perTrackPrimary.replace(/\s\|\s$/,'');
      perTrackNonTdcs=perTrackNonTdcs.replace(/\s\|\s$/,'');
    }

    _out.push(Object.assign({}, row, {
      spotify_url: spotifyUrl || (row.spotify_url||''),
      spotify_album_id: albumId || '',
      album_type: a? a.album_type : '',
      album_artist_count: a? (a.album_artists||[]).length : '',
      album_artists: a? (a.album_artists||[]).map(x=>x.name).join(' ; ') : '',
      album_artist_ids: a? (a.album_artists||[]).map(x=>x.id).join(' ; ') : '',
      tracks_total: a? a.tracks_total : '',
      tracks_with_tdcs: a? a.tracks_with_tdcs : '',
      tracks_without_tdcs: a? a.tracks_without_tdcs : '',
      track_artists_distinct: a? a.track_artists_count : '',
      track_artists_distinct_ex_tdcs: a? a.track_artists_count_ex_tdcs : '',
      album_all_track_artists: a? (a.all_track_artist_names||[]).join(' ; ') : '',
      album_all_track_artists_ex_tdcs: a? (a.all_track_artist_names_ex_tdcs||[]).join(' ; ') : '',
      tracks_multiple_primary_count: a? a.tracks_multiple_primary_count : '',
      tracks_multiple_primary_ratio: a? a.tracks_multiple_primary_ratio : '',
      per_track_primary_artists: perTrackPrimary,
      per_track_non_tdcs_artists: perTrackNonTdcs,
      detailed_reasons: reasons.join(' | ')
    }));

    prog.value=i+1;
  }

  const csv=rowsToCSV(_out);
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8'});
  const url=URL.createObjectURL(blob);
  const btn=$("#downloadBtn");
  btn.onclick=()=>{ const a=document.createElement('a'); a.href=url; a.download='spotify_compilation_reasons_detailed.csv'; document.body.appendChild(a); a.click(); a.remove(); };
  btn.disabled=false;
  setPreview(_out);
  log('Done.');
}

/*** init ***/
(function(){
  const t=token(); setAuthStatus(!!t, t?'トークンOK（有効）':'未接続');
})();
</script>
</body>
</html>
