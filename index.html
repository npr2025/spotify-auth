<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>TDCS Primary Seek – Compilation Reason Auditor (Detailed)</title>
  <link rel="preconnect" href="https://accounts.spotify.com"/>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans JP'; margin: 2rem; }
    header { margin-bottom: 1rem; }
    h1 { font-size: 1.35rem; margin: 0 0 .25rem; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 1rem; margin-bottom: 1rem; }
    .row { display: flex; gap: 1rem; flex-wrap: wrap; align-items: center; }
    button { padding: .6rem 1rem; border-radius: 8px; border: 1px solid #999; background: #111; color: #fff; cursor: pointer; }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    input[type=file] { border: 1px dashed #bbb; padding: .75rem; border-radius: 8px; background: #fafafa; }
    code,.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono','Courier New', monospace; }
    .muted { color: #666; }
    .ok { color: #0a7f29; }
    .bad { color: #b00020; }
    progress { width: 100%; height: 14px; }
    table { border-collapse: collapse; width: 100%; }
    th,td { border: 1px solid #eee; padding: .5rem; text-align: left; font-size: .9rem; }
    .small { font-size: .88rem; }
    .pill { display:inline-block; padding:.1rem .5rem; border:1px solid #ccc; border-radius:999px; font-size:.8rem; background:#f6f6f6; }
  </style>
</head>
<body>
<header>
  <h1>TDCS Primary Seek – Compilation Reason Auditor</h1>
  <div class="muted small">
    Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> |
    Redirect URI: <code>https://npr2025.github.io/spotify-auth/callback.html</code>
  </div>
</header>

<section class="card">
  <h2>1) 接続</h2>
  <div class="row">
    <a href="./auth.html"><button>Spotifyに接続</button></a>
    <div id="authStatus" class="muted">未接続</div>
  </div>
  <div class="small muted">※ PKCEで取得したトークンは localStorage に保存されます（キー: <code>sp_token</code>）。</div>
</section>

<section class="card">
  <h2>2) CSVをアップロード</h2>
  <p class="muted small">対応列（自動検出）：<code>spotify_url</code> / <code>UPC</code> / <code>ISRC</code> / <code>Album title</code> / <code>Album version</code> / <code>Track title</code></p>
  <div class="row">
    <input type="file" id="csvFile" accept=".csv"/>
    <label>最小間隔(ms)：<input type="number" id="minDelayMs" value="700" min="0" step="50" style="width:7rem;"/></label>
    <label>最大バックオフ(ms)：<input type="number" id="maxBackoffMs" value="10000" min="500" step="500" style="width:7rem;"/></label>
    <label>最大リトライ：<input type="number" id="maxRetries" value="7" min="0" step="1" style="width:5rem;"/></label>
    <button id="startBtn" disabled>詳細監査スタート</button>
  </div>
  <div id="fileInfo" class="small muted"></div>
</section>

<section class="card">
  <h2>進捗 <span id="ratePill" class="pill">idle</span></h2>
  <progress id="prog" value="0" max="100"></progress>
  <div id="log" class="small mono" style="white-space:pre-wrap; max-height:260px; overflow:auto;"></div>
</section>

<section class="card">
  <h2>エクスポート</h2>
  <div class="row">
    <button id="downloadDetailedBtn" disabled>詳細CSVをダウンロード</button>
  </div>
  <div class="small muted">
    主要出力列：<code>
      spotify_url, UPC, Album title, Album version, Track title, album_type, album_artist_count,
      album_artists, album_artist_ids, tracks_total, tracks_with_tdcs, tracks_without_tdcs,
      track_artists_distinct, track_artists_distinct_ex_tdcs,
      album_all_track_artists, album_all_track_artists_ex_tdcs,
      tracks_multiple_primary_count, tracks_multiple_primary_ratio,
      per_track_primary_artists, per_track_non_tdcs_artists,
      detailed_reasons
    </code>
  </div>
</section>

<section class="card">
  <h2>最新の結果（サンプル10行）</h2>
  <table id="previewTbl"><thead></thead><tbody></tbody></table>
</section>

<script>
/* =================== 設定 =================== */
const TARGET_ARTIST_ID = "55fvQ5I2IZUfcFT2DV02T3"; // The Darrow Chem Syndicate
// しきい値（必要なら調整）
const NON_TDCS_UNIQUE_THRESHOLD = 4;     // TDCS以外のユニーク人数がこの値以上で警告
const MULTI_PRIMARY_TRACKS_THRESHOLD = 0.4; // 複数プライマリー曲の比率がこの値以上で警告

/* ================ ユーティリティ ================ */
function log(msg){ const el=document.getElementById('log'); el.textContent+=msg+"\n"; el.scrollTop=el.scrollHeight; }
function setAuthStatus(ok, text){ const el=document.getElementById('authStatus'); el.textContent=text; el.className = ok ? 'ok' : 'bad'; }
function setRate(text){ document.getElementById('ratePill').textContent=text; }
function getStoredToken(){
  const raw = localStorage.getItem('sp_token');
  if(!raw) return null;
  try{ const obj=JSON.parse(raw); if(Date.now()<obj.expires_at) return obj; }catch(e){}
  return null;
}
function detectCols(header){
  const lc=header.map(h=>String(h||'').toLowerCase());
  function pick(...c){ for(const x of c){ const i=lc.indexOf(String(x).toLowerCase()); if(i>-1) return header[i]; } return null; }
  return { url: pick('spotify_url','url','link'),
           upc: pick('upc','UPC'),
           isrc: pick('isrc','ISRC'),
           album: pick('album title','album'),
           version: pick('album version','version'),
           track: pick('track title','track') };
}
function parseSpotifyUrl(u){
  try{ const m=u.match(/open\.spotify\.com\/(album|track)\/([A-Za-z0-9]+)/); if(m) return {type:m[1], id:m[2]}; }catch(e){}
  return null;
}
function rowsToCSV(rows){
  if(!rows.length) return '';
  const header=Object.keys(rows[0]);
  const esc=v=> (v==null?'':'"'+String(v).replace(/"/g,'""')+'"');
  return [header.map(esc).join(','), ...rows.map(r=> header.map(h=>esc(r[h])).join(','))].join('\r\n');
}
function setPreview(rows){
  const tblh=document.querySelector('#previewTbl thead');
  const tblb=document.querySelector('#previewTbl tbody');
  tblh.innerHTML=''; tblb.innerHTML='';
  const sample=rows.slice(0,10);
  if(!sample.length) return;
  const header=Object.keys(sample[0]);
  const trh=document.createElement('tr');
  header.forEach(h=>{ const th=document.createElement('th'); th.textContent=h; trh.appendChild(th); });
  tblh.appendChild(trh);
  sample.forEach(r=>{ const tr=document.createElement('tr'); header.forEach(h=>{ const td=document.createElement('td'); td.textContent=(r[h]==null?'':r[h]); tr.appendChild(td); }); tblb.appendChild(tr); });
}

/* ============== レート制御つきAPI ============== */
async function api(path, token, params={}, opt={}){
  const minDelay = opt.minDelayMs ?? (parseInt(document.getElementById('minDelayMs').value,10) || 700);
  const maxBackoff = opt.maxBackoffMs ?? (parseInt(document.getElementById('maxBackoffMs').value,10) || 10000);
  const maxRetries = opt.maxRetries ?? (parseInt(document.getElementById('maxRetries').value,10) || 7);
  let backoff = minDelay;
  let attempt = 0;

  while(true){
    attempt++;
    const url=new URL('https://api.spotify.com'+path);
    Object.entries(params).forEach(([k,v])=> v!=null && url.searchParams.set(k,v));

    let res, ok=false, text="";
    const t0=Date.now();
    try{
      res = await fetch(url.toString(), { headers:{'Authorization':'Bearer '+token}});
      ok = res.ok;
      text = await res.text();
    }catch(e){
      if(attempt>maxRetries) throw new Error('Network error after retries: '+(e?.message||e));
      const jitter = Math.random()*200;
      const delay = Math.min(backoff + jitter, maxBackoff);
      setRate('net err → wait '+Math.floor(delay)+'ms');
      log('Network error, retry in '+Math.floor(delay)+'ms');
      await new Promise(r=>setTimeout(r, delay));
      backoff = Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    if(ok && res.status!==429){
      const left = Math.max(minDelay - (Date.now()-t0), 0);
      if(left>0){ setRate('throttle '+left+'ms'); await new Promise(r=>setTimeout(r,left)); }
      setRate('ok');
      try { return JSON.parse(text); } catch { return text; }
    }

    let body;
    try{ body = JSON.parse(text); }catch{ body = text; }

    if(res.status===429){
      const ra = parseFloat(res.headers.get('Retry-After')||'0'); // sec
      const delay = Math.max(minDelay, ra ? ra*1000 : backoff);
      setRate('429 → wait '+Math.floor(delay)+'ms');
      log('429 backoff '+Math.floor(delay)+'ms'+(ra?` (Retry-After=${ra}s)`:''));
      await new Promise(r=>setTimeout(r, delay));
      backoff = Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    if(res.status>=500 && res.status<600){
      if(attempt>maxRetries) throw new Error('HTTP '+res.status+' after '+attempt+' attempts: '+(text||''));
      const jitter = Math.random()*300;
      const delay = Math.min(backoff + jitter, maxBackoff);
      setRate(res.status+' → wait '+Math.floor(delay)+'ms');
      log(res.status+' retry in '+Math.floor(delay)+'ms');
      await new Promise(r=>setTimeout(r, delay));
      backoff = Math.min(Math.floor(backoff*1.6), maxBackoff);
      continue;
    }

    throw new Error('HTTP '+res.status+': '+(typeof body==='string'? body : JSON.stringify(body)));
  }
}

/* ================= キャッシュ ================= */
const upcCache=new Map();
const isrcCache=new Map();
const albumAuditCache=new Map();

/* ============== 検索＆監査ロジック ============== */
function detectColsInCSV(header){ return detectCols(header); }

async function findByUPC(upc, token){
  if(!upc) return null;
  if(upcCache.has(upc)) return upcCache.get(upc);
  const q='upc:'+upc;
  const res=await api('/v1/search', token, {q, type:'album', limit:1});
  let out=null;
  if(res.albums?.items?.length){ const a=res.albums.items[0]; out={albumId:a.id, url:a.external_urls.spotify}; }
  upcCache.set(upc,out); return out;
}
async function findByISRC(isrc, token){
  if(!isrc) return null;
  if(isrcCache.has(isrc)) return isrcCache.get(isrc);
  const q='isrc:'+isrc;
  const res=await api('/v1/search', token, {q, type:'track', limit:1});
  let out=null;
  if(res.tracks?.items?.length){ const t=res.tracks.items[0]; out={trackId:t.id, albumId:t.album.id, url:t.external_urls.spotify, albumUrl:t.album.external_urls.spotify}; }
  isrcCache.set(isrc,out); return out;
}
async function findByText(row, cols, token){
  const parts=[];
  if(cols.album && row[cols.album]) parts.push('album:"'+String(row[cols.album]).trim()+'"');
  parts.push('artist:"The Darrow Chem Syndicate"');
  if(cols.version && row[cols.version]) parts.push('"'+String(row[cols.version]).trim()+'"');
  const q=parts.join(' ');
  const res=await api('/v1/search', token, {q, type:'album', limit:1});
  if(res.albums?.items?.length){ const a=res.albums.items[0]; return {albumId:a.id, url:a.external_urls.spotify}; }
  return null;
}

async function auditAlbum(albumId, token){
  if(!albumId) return null;
  if(albumAuditCache.has(albumId)) return albumAuditCache.get(albumId);

  const a=await api('/v1/albums/'+albumId, token);

  // tracks with paging
  let items=[], offset=0, limit=50, page;
  do{
    page = await api('/v1/albums/'+albumId+'/tracks', token, {limit, offset});
    items = items.concat(page.items||[]);
    offset += limit;
  } while(page && page.next);

  // collect artists
  const trackArtistIdsPerTrack = [];
  const trackArtistNamesPerTrack = [];
  const trackNames = [];

  const setAllIds = new Set();
  const setAllNonTdcsIds = new Set();
  const setAllNames = new Set();
  const setAllNonTdcsNames = new Set();

  let tracksWithTDCS = 0, tracksWithoutTDCS = 0, multiPrimaryCount = 0;

  (items||[]).forEach(tr=>{
    const ids = (tr.artists||[]).map(ar=>ar.id);
    const names = (tr.artists||[]).map(ar=>ar.name);
    const hasTDCS = ids.includes(TARGET_ARTIST_ID);
    if(hasTDCS) tracksWithTDCS++; else tracksWithoutTDCS++;
    if(ids.length>1) multiPrimaryCount++;

    trackNames.push(tr.name||'');
    trackArtistIdsPerTrack.push(ids);
    trackArtistNamesPerTrack.push(names);

    ids.forEach(id=> setAllIds.add(id));
    names.forEach((nm,idx)=>{
      const id = ids[idx];
      if(nm) setAllNames.add(nm);
      if(id !== TARGET_ARTIST_ID && nm) setAllNonTdcsNames.add(nm);
      if(id !== TARGET_ARTIST_ID) setAllNonTdcsIds.add(id);
    });
  });

  const out = {
    album_type: a.album_type,
    album_artists: (a.artists||[]).map(x=>({id:x.id,name:x.name})),
    tracks_total: (items||[]).length,
    tracks_with_tdcs: tracksWithTDCS,
    tracks_without_tdcs: tracksWithoutTDCS,
    track_artists_count: setAllIds.size,
    track_artists_count_ex_tdcs: setAllNonTdcsIds.size,
    all_track_artist_names: Array.from(setAllNames),
    all_track_artist_names_ex_tdcs: Array.from(setAllNonTdcsNames),
    tracks_multiple_primary_count: multiPrimaryCount,
    tracks_multiple_primary_ratio: (items?.length? (multiPrimaryCount/items.length):0),
    trackNames, trackArtistNamesPerTrack
  };

  albumAuditCache.set(albumId, out);
  return out;
}

function buildReasonsDetailed(aRes){
  const reasons = [];
  if(!aRes) return ['album fetch failed'];

  const isCompilation = aRes.album_type && aRes.album_type.toLowerCase()==='compilation';
  if(isCompilation) reasons.push('album_type=compilation');

  if(aRes.album_artists && aRes.album_artists.length>1){
    reasons.push('multiple album artists: '+aRes.album_artists.length);
  }

  if((aRes.tracks_without_tdcs||0) > 0){
    reasons.push(`tracks without TDCS primary: ${aRes.tracks_without_tdcs}/${aRes.tracks_total||0}`);
  }

  if((aRes.track_artists_count_ex_tdcs||0) >= NON_TDCS_UNIQUE_THRESHOLD){
    reasons.push(`many distinct non-TDCS track artists: ~${aRes.track_artists_count_ex_tdcs}`);
  }

  if((aRes.tracks_multiple_primary_ratio||0) >= MULTI_PRIMARY_TRACKS_THRESHOLD){
    const pct = Math.round((aRes.tracks_multiple_primary_ratio)*100);
    reasons.push(`many tracks with multiple primary artists: ${aRes.tracks_multiple_primary_count}/${aRes.tracks_total} (~${pct}%)`);
  }

  if(!reasons.length) reasons.push('no strong compilation indicators');
  return reasons;
}

/* ================== 実行フロー ================== */
let _rows=[], _cols={}, _out=[];

document.getElementById('csvFile').addEventListener('change', (ev)=>{
  const file=ev.target.files[0]; if(!file) return;
  document.getElementById('fileInfo').textContent = file.name+' / '+(file.size/1024).toFixed(1)+' KB';
  Papa.parse(file, { header:true, skipEmptyLines:true, complete:(res)=>{
    _rows = res.data; _cols = detectColsInCSV(res.meta.fields||[]);
    document.getElementById('startBtn').disabled=false;
    log('CSV loaded: '+_rows.length+' rows');
    log('Detected columns: '+JSON.stringify(_cols));
  }});
});

document.getElementById('startBtn').addEventListener('click', runAudit);

async function runAudit(){
  const tokenObj=getStoredToken(); if(!tokenObj){ alert('先に Spotify に接続してください。'); return; }
  const token=tokenObj.access_token;
  const prog=document.getElementById('prog'); prog.max=_rows.length;
  _out = [];

  for(let i=0;i<_rows.length;i++){
    const row=_rows[i];
    try{
      let albumId=null, resolvedUrl='', foundVia='';

      // 1) URL
      if(_cols.url && row[_cols.url]){
        const pu=parseSpotifyUrl(String(row[_cols.url]).trim());
        if(pu){
          foundVia='url';
          if(pu.type==='album'){ albumId=pu.id; resolvedUrl='https://open.spotify.com/album/'+pu.id; }
          else if(pu.type==='track'){
            const tr=await api('/v1/tracks/'+pu.id, token);
            albumId=tr.album.id; resolvedUrl=tr.album.external_urls.spotify;
          }
        }
      }
      // 2) UPC
      if(!albumId && _cols.upc && row[_cols.upc]){
        const r=await findByUPC(String(row[_cols.upc]).trim(), token);
        if(r){ albumId=r.albumId; resolvedUrl=r.url; foundVia='upc'; }
      }
      // 3) ISRC
      if(!albumId && _cols.isrc && row[_cols.isrc]){
        const r=await findByISRC(String(row[_cols.isrc]).trim(), token);
        if(r){ albumId=r.albumId; resolvedUrl=r.albumUrl || r.url; foundVia='isrc'; }
      }
      // 4) text
      if(!albumId){
        const r=await findByText(row, _cols, token);
        if(r){ albumId=r.albumId; resolvedUrl=r.url; foundVia='search'; }
      }

      let aRes=null; let rowOut=null;
      if(albumId){
        aRes=await auditAlbum(albumId, token);
        const reasons = buildReasonsDetailed(aRes);

        // per-track columns: "Track — A ; B" / "Track — (non-TDCS only)"
        const perTrackPrimary = [];
        const perTrackNonTDCS = [];
        const names = aRes.trackArtistNamesPerTrack || [];
        const tnames = aRes.trackNames || [];
        for(let k=0;k<names.length;k++){
          const list = names[k] || [];
          const non = list.filter(nm => nm && !aRes.all_track_artist_names_ex_tdcs ? false : (nm && aRes.all_track_artist_names_ex_tdcs.includes(nm)));
          perTrackPrimary.push(`${tnames[k]||''} — ${list.join(' ; ')}`);
          const nonList = list.filter(nm => (aRes.all_track_artist_names_ex_tdcs||[]).includes(nm));
          perTrackNonTDCS.push(`${tnames[k]||''} — ${nonList.join(' ; ')}`);
        }

        rowOut = Object.assign({}, row, {
          spotify_found_via: foundVia,
          spotify_album_id: albumId,
          spotify_url: resolvedUrl,
          album_type: aRes.album_type || '',
          album_artist_count: (aRes.album_artists||[]).length,
          album_artists: (aRes.album_artists||[]).map(x=>x.name).join(' ; '),
          album_artist_ids: (aRes.album_artists||[]).map(x=>x.id).join(' ; '),
          tracks_total: aRes.tracks_total || 0,
          tracks_with_tdcs: aRes.tracks_with_tdcs || 0,
          tracks_without_tdcs: aRes.tracks_without_tdcs || 0,
          track_artists_distinct: aRes.track_artists_count || 0,
          track_artists_distinct_ex_tdcs: aRes.track_artists_count_ex_tdcs || 0,
          album_all_track_artists: (aRes.all_track_artist_names||[]).join(' ; '),
          album_all_track_artists_ex_tdcs: (aRes.all_track_artist_names_ex_tdcs||[]).join(' ; '),
          tracks_multiple_primary_count: aRes.tracks_multiple_primary_count || 0,
          tracks_multiple_primary_ratio: aRes.tracks_multiple_primary_ratio || 0,
          per_track_primary_artists: perTrackPrimary.join(' | '),
          per_track_non_tdcs_artists: perTrackNonTDCS.join(' | '),
          detailed_reasons: reasons.join(' | ')
        });
      } else {
        rowOut = Object.assign({}, row, { error: 'not found in Spotify (URL/UPC/ISRC/search failed)' });
      }
      _out.push(rowOut);
    }catch(e){
      log(`Row ${i+1}: ERROR -> ${e.message||e}`);
      _out.push(Object.assign({}, row, { error: String(e.message||e) }));
    }
    prog.value = i+1;
  }

  // export
  const csv = rowsToCSV(_out);
  const blob = new Blob([csv], { type:'text/csv;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const btn = document.getElementById('downloadDetailedBtn');
  btn.onclick = ()=>{ const a=document.createElement('a'); a.href=url; a.download='spotify_compilation_reasons_detailed.csv'; document.body.appendChild(a); a.click(); a.remove(); };
  btn.disabled=false;
  setPreview(_out);
  log('Done.');
}

/* =============== 起動時 =============== */
(function init(){
  const tok=getStoredToken();
  if(tok) setAuthStatus(true,'トークンOK（有効）'); else setAuthStatus(false,'未接続');
})();
</script>
</body>
</html>
