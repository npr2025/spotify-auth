<script>
// === HOTFIX vS-EDL-01: click委任 + 緊急リセット + 強制実行 ===

// 1) クリック委任（個別のaddEventListenerが失敗しても拾う）
document.addEventListener('click', async (e) => {
  const btn = e.target.closest('button, a.btn');
  if (!btn) return;

  // ログ強制表示
  const id = btn.id || btn.getAttribute('href') || '(no-id)';
  try { log(`▶ click: ${id}`); } catch(_) { /* logがまだ無ければ無視 */ }

  // 既存のa.btnのデフォ動作は通す（Sign inリンクなど）
  if (btn.tagName === 'A') return;

  // ボタンごとの強制実行（既存のバインドが死んでてもここで動く）
  e.preventDefault();
  switch (btn.id) {
    case 'btnMe':
      try { const me = await callSpotifyJSON('https://api.spotify.com/v1/me', {}, {tag:'/me'}); log(`/me OK: ${me.display_name||'(no name)'} / ${me.id}`); }
      catch(err){ alert('サインインが必要です'); log('エラー: '+(err.message||err)); }
      break;
    case 'btnSignOut':
      try { Object.values(K).forEach(k=>sessionStorage.removeItem(k)); log('保存トークンを削除しました。'); renderStatus(); }
      catch(err){ log('エラー: '+(err.message||err)); }
      break;
    case 'btnFast':
      try { await doFastBuild(); } catch(err){ log('エラー: '+(err.message||err)); }
      break;
    case 'btnTrim':
      try { await doTrim(); } catch(err){ log('エラー: '+(err.message||err)); }
      break;
    case 'btnBalance':
      try { await doBalance(); } catch(err){ log('エラー: '+(err.message||err)); }
      break;
    case 'btnBuildEditions':
      try { await buildEditions(); } catch(err){ log('エラー: '+(err.message||err)); alert('エラー: '+(err.message||err)); }
      break;
    case 'btnCommit':
      try {
        if (!window.final100 || !final100.length) { alert('③Balanced を先に実行してください'); return; }
        const name=(el('plName').value||'TDCS – Breaks Remix Only 100 (2010+)').trim();
        const desc=(el('plDesc').value||'Breaks/Breakbeat限定・2010+・Remixのみ・Pins固定・バランス配置').trim();
        const isPublic=el('plPublic').value==='true';
        const existing=el('existingId').value.trim()||null;
        await putPlaylist(name, desc, isPublic, final100.map(t=>`spotify:track:${t.id}`), existing);
      } catch(err){ log('エラー: '+(err.message||err)); alert('エラー: '+(err.message||err)); }
      break;
    case 'btnRepair': // 下の(2)で追加する緊急ボタン
      try {
        localStorage.removeItem('sp_build_lock_v1');
        sessionStorage.removeItem(K.access);
        sessionStorage.removeItem(K.expAt);
        sessionStorage.removeItem(K.refresh);
        sessionStorage.removeItem(K.scope);
        log('🔧 緊急リセット: ロックとトークンをクリアしました');
        renderStatus();
        alert('リセット完了。必要なら Sign in し直してください。');
      } catch(err){ log('エラー: '+(err.message||err)); }
      break;
  }
});

// 2) 画面に「緊急リセット」ボタンを追加（見失っても大丈夫なように動的追加）
(function addRepairButton(){
  try{
    if (!document.getElementById('btnRepair')) {
      const holder = document.querySelector('fieldset legend')?.parentElement || document.body;
      const b = document.createElement('button');
      b.id = 'btnRepair'; b.textContent = '🔧 緊急リセット（ロック/トークンクリア）';
      b.style.marginLeft = '8px';
      holder.querySelector('.progress')?.appendChild(b) || holder.appendChild(b);
    }
  }catch(_){}
})();

// 3) ビルドロックが残っていたら自動解放（2分待ちを避ける）
try{
  const raw = localStorage.getItem('sp_build_lock_v1');
  if (raw) {
    const obj = JSON.parse(raw);
    const tooOld = !obj || (Date.now() - (obj.ts||0) > 30*1000); // 30秒で古いとみなす（従来は120秒）
    if (tooOld) localStorage.removeItem('sp_build_lock_v1');
  }
}catch(_){}

// 4) 初回に「DOM Ready」ログを強制表示（バインド確認用）
try{ log('✅ HOTFIX wired: DOM ready & click-delegate active'); }catch(_){}
</script>
