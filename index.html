<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TDCS Editions Builder — v10.18 (Chrome)</title>
<style>
:root{--bg:#0b1220;--fg:#cfe3ff;--muted:#7da2d6}
*{box-sizing:border-box}
body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:var(--fg);
     max-width:1180px;margin:28px auto;padding:0 12px}
h1{margin:0 0 6px;font-size:20px}
.small{opacity:.85;font-size:12px}
.row{display:flex;gap:12px;flex-wrap:wrap;margin:8px 0}
.card{border:1px solid #1c2a47;border-radius:12px;padding:14px}
.btn{padding:9px 12px;border:1px solid #4a6aa3;border-radius:8px;background:#12213e;color:var(--fg);
     cursor:pointer}
.btn[disabled]{opacity:.45;cursor:not-allowed}
input[type=text]{width:100%;padding:9px 10px;border:1px solid #2b3c63;border-radius:8px;background:#0e172c;color:var(--fg)}
label{display:flex;align-items:center;gap:8px}
pre#log{white-space:pre-wrap;background:#091125;color:var(--fg);padding:12px;border-radius:10px;min-height:160px}
kbd{background:#203054;border:1px solid #3a4f7c;border-radius:6px;padding:1px 6px}
.badge{display:inline-block;margin-left:8px;padding:2px 8px;border:1px solid #3e5c97;border-radius:999px;font-size:11px;background:#0f1e38}
.flex1{flex:1}
hr{border:none;border-top:1px solid #1c2a47;margin:12px 0}
</style>
</head>
<body>
<h1>TDCS Editions Builder — v10.18 <span class="badge">Chrome tuned</span></h1>
<p class="small">同一タブ遷移 / PKCE(S256→PLAIN) / state=client_id 封入 / code_verifier 三重保存 / Booting…対策 済み</p>

<div class="row">
  <div class="card flex1">
    <h3>1) 接続</h3>
    <div class="row">
      <button id="signin" class="btn" disabled>Sign in (S256 → auto)</button>
      <a id="signinPlain" class="btn" href="#" aria-disabled="true">Sign in (PLAIN 手動)</a>
      <button id="check" class="btn">接続チェック</button>
      <button id="logout" class="btn">リセット/ログアウト</button>
    </div>
    <div class="small">必要スコープ: <code>playlist-modify-private</code>, <code>playlist-modify-public</code></div>
  </div>

  <div class="card flex1">
    <h3>2) パラメータ</h3>
    <div class="row">
      <div class="flex1">
        <label>テンプレPL（固定20の取得元）
          <input id="templatePlId" type="text" placeholder="Spotify Playlist ID（例: 37i9dQZF1DX1）">
        </label>
      </div>
      <div class="flex1">
        <label>作成するプレイリスト名
          <input id="targetPlName" type="text" placeholder="例: TDCS Beatport 150 v10.18">
        </label>
      </div>
    </div>
    <div class="row">
      <label><input id="excludeLP" type="checkbox" checked> LP(≧7曲) 除外（固定20は除外対象外）</label>
      <label><input id="distHigh" type="checkbox"> 分散強化 HIGH（catNoCap=1 / 窓幅拡大）</label>
      <label><input id="seedToday" type="checkbox" checked> 日時シード（Asia/Tokyo）</label>
    </div>
  </div>
</div>

<div class="card">
  <h3>3) 実行</h3>
  <div class="row">
    <button id="runAuto" class="btn">①Auto（候補＋固定20→分散→150→PL作成）</button>
    <button id="runCsvOnly" class="btn">②CSV Only（CSV候補＋固定20→分散→150→PL）</button>
  </div>
  <div class="row">
    <input id="csvFile" type="file" accept=".csv" class="flex1">
  </div>
  <pre id="log">Booting…</pre>
</div>

<script>
/*** ====== 設定（ここをあなたの環境に合わせる） ====== ***/
const CLIENT_ID = "<YOUR_SPOTIFY_CLIENT_ID>"; // 例: "d3f0...abcd"
const REDIRECT_URI = location.origin + location.pathname.replace(/\/[^/]*$/, '') + "/callback.html"; // 同一ディレクトリ
const SCOPES = ["playlist-modify-private","playlist-modify-public"]; // 必要最小限
const ACCOUNTS = "https://accounts.spotify.com";
const API_BASE  = "https://api.spotify.com/v1";

/*** ====== ユーティリティ ====== ***/
const $ = (sel) => document.querySelector(sel);
const log = (...a) => {
  const el = $("#log");
  el.textContent += (el.textContent ? "\n" : "") + a.map(v => (typeof v==="string"? v : JSON.stringify(v,null,2))).join(" ");
  el.scrollTop = el.scrollHeight;
};
const clearLog = () => { $("#log").textContent = ""; };

function b64url(bytes){
  let s = btoa(String.fromCharCode(...new Uint8Array(bytes)));
  return s.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
async function sha256(text){
  const enc = new TextEncoder().encode(text);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return b64url(buf);
}
function randStr(len=64){
  const bytes = new Uint8Array(len);
  crypto.getRandomValues(bytes);
  const alph = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
  let s=""; for (let i=0;i<len;i++) s+= alph[bytes[i]%alph.length];
  return s;
}
function setCookie(name, value, days=1){
  const d = new Date(); d.setTime(d.getTime()+days*864e5);
  document.cookie = `${name}=${encodeURIComponent(value)}; Expires=${d.toUTCString()}; Path=${location.pathname.replace(/\/[^/]*$/,'/')}; SameSite=Lax; Secure`;
}
function getCookie(name){
  return document.cookie.split('; ').reduce((a,c)=>{
    const [k,...v]=c.split('=');
    return k===name? decodeURIComponent(v.join('=')) : a;
  }, "");
}
function delCookie(name){
  document.cookie = `${name}=; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Path=${location.pathname.replace(/\/[^/]*$/,'/')}; SameSite=Lax; Secure`;
}

/*** ====== 認可 URL（PLAIN 仮設定→S256 に差し替え） ====== ***/
function buildAuthorizeURL({verifier, challengeMethod, challenge}){
  const url = new URL(ACCOUNTS + "/authorize");
  url.searchParams.set("client_id", CLIENT_ID);
  url.searchParams.set("response_type", "code");
  url.searchParams.set("redirect_uri", REDIRECT_URI);
  url.searchParams.set("scope", SCOPES.join(' '));
  // state に client_id を封入（nonce も併用）
  const stateObj = { client_id: CLIENT_ID, nonce: randStr(24), ts: Date.now() };
  url.searchParams.set("state", btoa(unescape(encodeURIComponent(JSON.stringify(stateObj)))));
  if (challengeMethod === "S256"){
    url.searchParams.set("code_challenge_method","S256");
    url.searchParams.set("code_challenge", challenge);
  } else {
    url.searchParams.set("code_challenge_method","plain");
    url.searchParams.set("code_challenge", verifier);
  }
  return url.toString();
}

/*** ====== 三重保存（sessionStorage > localStorage > cookie） ====== ***/
function saveVerifier(v){
  sessionStorage.setItem("code_verifier", v);
  localStorage.setItem("code_verifier", v);
  setCookie("code_verifier", v);
}
function loadVerifier(){
  return sessionStorage.getItem("code_verifier") ||
         localStorage.getItem("code_verifier")   ||
         getCookie("code_verifier")              || "";
}
function wipeVerifier(){
  sessionStorage.removeItem("code_verifier");
  localStorage.removeItem("code_verifier");
  delCookie("code_verifier");
}

/*** ====== トークン保存 ====== ***/
function saveToken(tok){
  sessionStorage.setItem("access_token", tok.access_token);
  if (tok.refresh_token) localStorage.setItem("refresh_token", tok.refresh_token); // PKCEでも返る場合あり
  const expAt = Date.now() + (tok.expires_in||3600)*1000 - 15000;
  sessionStorage.setItem("token_expires_at", String(expAt));
}
function getAccessToken(){
  const at = sessionStorage.getItem("access_token");
  const exp = Number(sessionStorage.getItem("token_expires_at")||0);
  if (!at) return null;
  if (Date.now()>exp) return null;
  return at;
}

/*** ====== API 呼び出し（429 バックオフ内蔵） ====== ***/
async function api(path, opt={}, attempt=0){
  const at = getAccessToken();
  if (!at) throw new Error("未接続（access_token がありません）");
  const url = path.startsWith("http")? path : API_BASE + path;
  const res = await fetch(url, {
    method: "GET",
    ...opt,
    headers: {
      "Authorization": `Bearer ${at}`,
      "Content-Type": "application/json",
      ...(opt.headers||{})
    }
  });
  if (res.status===429){
    const ra = Number(res.headers.get("Retry-After")||"0");
    const base = ra? (ra*1000) : (2000 * Math.pow(1.7, attempt));
    const jitter = base * (0.8 + Math.random()*0.4);
    log(`429 受信 → 待機 ${(jitter|0)}ms`);
    await new Promise(r=>setTimeout(r, jitter));
    return api(path, opt, attempt+1);
  }
  if (!res.ok){
    const text = await res.text();
    throw new Error(`API ${res.status}: ${text}`);
  }
  return res.json();
}

/*** ====== 接続チェック ====== ***/
async function checkConnected(){
  try{
    const me = await api("/me");
    log("接続中:", `${me.display_name||me.id} (${me.id})`);
    return me;
  }catch(e){
    log("未接続 or 失効:", e.message);
    return null;
  }
}

/*** ====== 固定20（テンプレPL）取得 ====== ***/
async function fetchTemplate20(playlistId){
  const fields = "items(track(uri,id,name,artists(name),album(id,album_type,total_tracks),external_ids(isrc)))";
  const obj = await api(`/playlists/${playlistId}/tracks?limit=20&fields=${encodeURIComponent(fields)}`);
  const list = obj.items
    .map(x => x.track)
    .filter(Boolean);
  log(`固定20 取得: ${list.length} 件`);
  return list;
}

/*** ====== 候補群の用意（Auto: アーティスト検索の雛形 / CSV: ユーザ投入） ====== ***/
// 簡易検索（あなたのアーティストや関連キーワードで拡張してOK）
async function fetchAutoCandidates(){
  const q = encodeURIComponent('"The Darrow Chem Syndicate" remix'); // 例
  const res = await api(`/search?q=${q}&type=track&limit=50`);
  const tracks = (res.tracks?.items||[]).map(t=>t);
  log(`Auto候補（検索）: ${tracks.length} 件`);
  return tracks;
}
// CSV 取り込み：列に ["uri"] or ["id"] or ["isrc"] があれば認識
async function fetchCsvCandidates(file){
  const text = await file.text();
  const rows = text.split(/\r?\n/).map(l=>l.split(/,|\t/));
  const header = rows.shift().map(s=>s.trim().toLowerCase());
  const idx = {
    uri: header.indexOf("uri"),
    id: header.indexOf("id"),
    isrc: header.indexOf("isrc"),
  };
  const want = [];
  for (const r of rows){
    if (!r.length) continue;
    if (idx.uri>=0 && r[idx.uri]) want.push({uri:r[idx.uri]});
    else if (idx.id>=0 && r[idx.id]) want.push({id:r[idx.id]});
    else if (idx.isrc>=0 && r[idx.isrc]) want.push({isrc:r[idx.isrc]});
  }
  log(`CSV候補 読み込み: ${want.length} 件`);
  // URI/ID はそのまま、ISRC は検索で解決
  const out = [];
  for (const w of want){
    try{
      if (w.uri) {
        const id = w.uri.split(':').pop();
        const t = await api(`/tracks/${id}`);
        out.push(t);
      } else if (w.id){
        const t = await api(`/tracks/${w.id}`);
        out.push(t);
      } else if (w.isrc){
        const res = await api(`/search?q=isrc:${encodeURIComponent(w.isrc)}&type=track&limit=1`);
        if (res.tracks?.items?.length) out.push(res.tracks.items[0]);
      }
    }catch(e){ log("CSV解決スキップ:", e.message); }
  }
  log(`CSV候補 解決: ${out.length} 件`);
  return out;
}

/*** ====== スコアリング & フィルタ ====== ***/
function keyFromTrack(t){
  const remix = (t.name||"").toLowerCase().includes("remix")? "R1" : "R0";
  const ar = (t.artists||[]).map(a=>a.name).join(",");
  const isrc = t.external_ids?.isrc || "";
  return `${t.uri||t.id}__${isrc}__${ar}__${remix}`;
}
function scoreTrack(t,{preferSingles=true, penalizeLong=true}){
  let s = 0;
  const album = t.album||{};
  const total = Number(album.total_tracks||0);
  const atype = (album.album_type||"").toLowerCase(); // album/single/compilation
  if (preferSingles){
    if (atype==="single" || total<=4) s += 3;
  }
  if (penalizeLong){
    if (total>=10) s -= 2;
  }
  // Remixブースト（仮）
  if ((t.name||"").toLowerCase().includes("remix")) s += 2;
  return s;
}
function isLP(t){ return (t.album?.total_tracks||0) >= 7; }

/*** ====== 型番/リミキサ分散 ====== ***/
// 簡易：曲名やアルバム名からカタログっぽいコードを抽出（実運用はあなたの規則で！）
function catNo(t){
  const src = [t.name, t.album?.name].filter(Boolean).join(" ");
  const m = src.match(/\b([A-Z]{2,5}\d{2,5})\b/);
  return m? m[1] : "";
}
function remixerTag(t){
  const m = (t.name||"").match(/\((.+?) Remix\)/i);
  return m? m[1].toLowerCase() : "";
}

/*** ====== ランキング→ユニーク化→分散→150到達 ====== ***/
function uniqByKey(list){
  const seen = new Set();
  const out = [];
  for (const t of list){
    const k = keyFromTrack(t);
    if (seen.has(k)) continue;
    seen.add(k);
    out.push(t);
  }
  return out;
}

function distribute(list,{distHigh=false}){
  const windowSize = distHigh? 8 : 5;
  const rrOut = [];
  const recentCats = [];
  const recentRems = [];
  for (const t of list){
    const c = catNo(t), r = remixerTag(t);
    const catHit = c && recentCats.includes(c);
    const remHit = r && recentRems.includes(r);
    if (catHit || remHit){
      // 軽めに後ろへ（窓幅で抑制）
      rrOut.push(t);
    } else {
      rrOut.unshift(t);
    }
    // 窓更新
    if (c){ recentCats.unshift(c); if (recentCats.length>windowSize) recentCats.pop(); }
    if (r){ recentRems.unshift(r); if (recentRems.length>windowSize) recentRems.pop(); }
  }
  return rrOut;
}

function ensure150(baseList, backfillList){
  const out = baseList.slice(0,150);
  let i=0;
  while (out.length<150 && i<backfillList.length){
    const t = backfillList[i++];
    if (!out.find(x=>x.uri===t.uri)) out.push(t);
  }
  return out;
}

/*** ====== プレイリスト作成 ====== ***/
async function createPlaylist(meId, name, uris){
  const pl = await api(`/users/${encodeURIComponent(meId)}/playlists`, {
    method:"POST",
    body: JSON.stringify({ name, description: "TDCS Editions Builder v10.18", public:false })
  });
  // Spotify API の仕様上 100件ずつ
  for (let i=0;i<uris.length;i+=100){
    const chunk = uris.slice(i,i+100);
    await api(`/playlists/${pl.id}/tracks`, { method:"POST", body: JSON.stringify({ uris: chunk }) });
  }
  return pl;
}

/*** ====== 乱択（同点ブレ＋日替わり） ====== ***/
function seededRandomize(list, useSeed=true){
  let seed = 1;
  if (useSeed){
    // Asia/Tokyo の日単位
    const now = new Date();
    const utc = now.getTime() + now.getTimezoneOffset()*60000;
    const jst = new Date(utc + 9*3600000);
    const ymd = `${jst.getFullYear()}-${jst.getMonth()+1}-${jst.getDate()}`;
    seed = [...ymd].reduce((a,c)=>a + c.charCodeAt(0), 0);
  }
  function rnd(){ seed = (seed*9301 + 49297) % 233280; return seed/233280; }
  return list.slice().sort(()=> rnd()-0.5);
}

/*** ====== 実行本体 ====== ***/
async function runCore({csvFile=null}={}){
  clearLog();
  const me = await checkConnected();
  if (!me) throw new Error("接続が必要です（Sign in を押してください）");

  const templateId = $("#templatePlId").value.trim();
  if (!templateId) throw new Error("テンプレPLの Playlist ID を入力してください");
  const targetName = $("#targetPlName").value.trim() || `TDCS Beatport 150 v10.18`;

  const fixed20 = await fetchTemplate20(templateId);

  let candidates = [];
  if (csvFile){
    candidates = await fetchCsvCandidates(csvFile);
  } else {
    candidates = await fetchAutoCandidates();
  }

  // 結合 → 固定20を先頭に温存
  const all = fixed20.concat(candidates);

  // LP 除外（固定20は除外対象外）
  const excludeLP = $("#excludeLP").checked;
  const filteredTail = candidates.filter(t => !excludeLP || !isLP(t));
  const joined = fixed20.concat(filteredTail);

  // スコアリング
  const scored = joined.map(t => ({t, s: scoreTrack(t,{preferSingles:true, penalizeLong:true})}));

  // 同点ブレ用の微乱数
  const useSeed = $("#seedToday").checked;
  for (const x of scored){ x.s += (Math.random()-0.5)*0.01; } // 微小

  // ランク → ユニーク（固定20は先頭固定のまま）
  const fixedKeys = new Set(fixed20.map(keyFromTrack));
  const tailSorted = seededRandomize(scored.filter(x => !fixedKeys.has(keyFromTrack(x.t))).sort((a,b)=>b.s-a.s).map(x=>x.t), useSeed);
  let uniq = uniqByKey(fixed20.concat(tailSorted));

  // 分散
  const distHigh = $("#distHigh").checked;
  uniq = distribute(uniq, {distHigh});

  // 150 到達保証（不足は候補集合でバックフィル）
  const final150 = ensure150(uniq, candidates);

  // URI 化
  const uris = final150.map(t => t.uri || `spotify:track:${t.id}`);

  log(`最終充足: ${uris.length}/150`);
  if (uris.length<150) log("警告: 150 に不足。候補の母集団を増やしてください。");

  // 作成
  const pl = await createPlaylist(me.id, targetName, uris);
  log(`プレイリスト作成 OK: ${pl.name} (${pl.id})`);
  log(`URL: ${pl.external_urls?.spotify || ("https://open.spotify.com/playlist/"+pl.id)}`);
}

/*** ====== window 公開（Booting…対策） ====== ***/
window.runAutoOnly = async () => {
  try{ await runCore({csvFile:null}); }catch(e){ log("エラー:", e.message); console.error(e); }
};
window.runCsvOnly = async () => {
  const f = $("#csvFile").files[0];
  if (!f){ log("CSVファイルを選択してください"); return; }
  try{ await runCore({csvFile:f}); }catch(e){ log("エラー:", e.message); console.error(e); }
};

/*** ====== 初期化：ボタン活性化 & 認可URL設定 ====== ***/
document.addEventListener("DOMContentLoaded", async () => {
  // まずは PLAIN 仮設定（crypto.subtle が遅延する Chrome でも即押下可）
  const verifierPlain = randStr(64);
  saveVerifier(verifierPlain);
  const plainURL = buildAuthorizeURL({verifier:verifierPlain, challengeMethod:"plain"});
  const signinBtn = $("#signin");
  const signinPlain = $("#signinPlain");
  signinBtn.disabled = false;
  signinPlain.setAttribute("href", plainURL);
  signinPlain.removeAttribute("aria-disabled");

  // S256 を計算して差し替え
  try{
    const challenge = await sha256(verifierPlain);
    const s256URL = buildAuthorizeURL({verifier:verifierPlain, challengeMethod:"S256", challenge});
    signinBtn.onclick = (e)=>{ e.preventDefault(); location.assign(s256URL); };
  }catch(e){
    log("S256生成失敗 → PLAIN を使用:", e.message);
    signinBtn.onclick = (e)=>{ e.preventDefault(); location.assign(plainURL); };
  }

  $("#check").onclick = async ()=>{ await checkConnected(); };
  $("#logout").onclick = ()=>{
    sessionStorage.clear(); wipeVerifier(); log("ローカルセッションをクリアしました");
  };
  $("#runAuto").onclick = ()=> window.runAutoOnly();
  $("#runCsvOnly").onclick = ()=> window.runCsvOnly();

  log("準備完了。Sign in → 接続チェック → 実行 の順でどうぞ。");
});
</script>
</body>
</html>
