<!doctype html>
<meta charset="utf-8"/>
<title>Spotify Primary Artist Auditor (PKCE)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP";margin:2rem;line-height:1.5}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;margin-bottom:1rem}
  label{display:block;margin:.5rem 0 .25rem}
  input,textarea,button{width:100%;padding:.6rem;border:1px solid #bbb;border-radius:8px}
  textarea{min-height:90px}
  button{cursor:pointer;background:#111;color:#fff;border:0;margin-top:.75rem}
  .row{display:flex;gap:1rem;flex-wrap:wrap}
  .row > *{flex:1 1 320px}
  .muted{color:#666}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .log{white-space:pre-wrap;background:#fafafa;border:1px dashed #ccc;padding:.75rem;border-radius:8px;max-height:260px;overflow:auto}
  .pill{display:inline-block;border:1px solid #ccc;border-radius:999px;padding:.2rem .6rem;margin-right:.4rem}
  small{display:block;margin-top:.25rem}
</style>

<div class="card">
  <h2>Spotify Primary Artist Auditor</h2>
  <p>アーティストIDまたはアルバムURLを指定して、<b>各トラックに“アルバムアーティスト以外のプライマリー”が入っていないか</b>を一括チェック → CSV出力します。</p>

  <div class="row">
    <div>
      <label>Client ID</label>
      <input id="clientId" placeholder="CLIENT_ID_HERE">
      <small class="muted">Spotify DeveloperのClient ID。</small>
    </div>
    <div>
      <label>Redirect URI</label>
      <input id="redirectUri" placeholder="REDIRECT_URI_HERE">
      <small class="muted">Developer Dashboardに登録したURIと厳密一致。</small>
    </div>
  </div>

  <div class="row">
    <div>
      <label>アーティストID（例：TDCS = <span class="mono">55fvQ5I2IZUfcFT2DV02T3</span>）</label>
      <input id="artistId" placeholder="55fvQ5I2IZUfcFT2DV02T3">
      <small class="muted">指定すると全アルバム/シングル/コンピを走査。下のアルバム入力より優先。</small>
    </div>
    <div>
      <label>アルバムURL/ID（改行区切り）</label>
      <textarea id="albumList" placeholder="https://open.spotify.com/album/06Yvg4vlPaVfnAWVwmJX27&#10;4aeD4BUM5mAA1v1hCp9irx"></textarea>
      <small class="muted">アーティストID未入力のときだけ使われます。</small>
    </div>
  </div>

  <label>走査オプション</label>
  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:.5rem;margin-bottom:.5rem">
    <label class="pill"><input type="checkbox" id="incAlbum" checked> album</label>
    <label class="pill"><input type="checkbox" id="incSingle" checked> single</label>
    <label class="pill"><input type="checkbox" id="incCompilation" checked> compilation</label>
  </div>

  <div class="row">
    <div>
      <label>期待アーティストID（カンマ区切り）</label>
      <input id="expectedIds" placeholder="例）55fvQ5I2IZUfcFT2DV02T3">
      <small class="muted">“このIDだけがプライマリーであるべき”という期待セット。合わなければフラグ。</small>
    </div>
    <div>
      <label>市場</label>
      <input id="market" value="JP">
      <small class="muted">market=JP など。</small>
    </div>
  </div>

  <div class="row">
    <div>
      <button id="loginBtn">Spotifyに接続（PKCE）</button>
      <small id="tokenInfo" class="muted"></small>
    </div>
    <div><button id="runBtn" disabled>実行 → CSVを作る</button></div>
  </div>
</div>

<div class="card">
  <h3>ログ</h3>
  <div id="log" class="log"></div>
</div>

<script>
const $ = s => document.querySelector(s);
const log = (m) => { const el=$("#log"); el.textContent += m + "\\n"; el.scrollTop=el.scrollHeight; };
const enc = (obj) => new URLSearchParams(obj).toString();
const LS = {
  get k(){ return "spotify_pkce_audit_v1"; },
  load(){ try{return JSON.parse(localStorage.getItem(this.k) || "{}");}catch{return {}}; },
  save(v){ localStorage.setItem(this.k, JSON.stringify(v)); }
};

function b64url(bytes){
  return btoa(String.fromCharCode(...new Uint8Array(bytes)))
    .replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
async function sha256(buf){ return crypto.subtle.digest("SHA-256", buf); }
function str2buf(s){
  return new TextEncoder().encode(s);
}

async function makePkce(){
  const code_verifier = b64url(crypto.getRandomValues(new Uint8Array(32)));
  const hash = await sha256(str2buf(code_verifier));
  const code_challenge = b64url(hash);
  return { code_verifier, code_challenge };
}

function idFromUrlOrId(s){
  if(!s) return "";
  s = s.trim();
  try { const u = new URL(s); const p=u.pathname.split("/"); return p[2]||s; }
  catch{ return s; }
}

function setTokenInfo(){
  const st = LS.load();
  if(st.access_token && st.expires_at){
    const sec = Math.max(0, Math.floor((st.expires_at - Date.now())/1000));
    $("#tokenInfo").textContent = `access_token: 有効（残り ${sec}s）`;
    $("#runBtn").disabled = false;
  }else{
    $("#tokenInfo").textContent = "access_token: なし";
    $("#runBtn").disabled = true;
  }
}

async function authorize(){
  const client_id = $("#clientId").value.trim();
  const redirect_uri = $("#redirectUri").value.trim();
  if(!client_id || !redirect_uri) { alert("Client ID と Redirect URI を入れてください。"); return; }

  const {code_verifier, code_challenge} = await makePkce();
  const state = b64url(crypto.getRandomValues(new Uint8Array(12)));
  const payload = LS.load();
  payload.client_id = client_id;
  payload.redirect_uri = redirect_uri;
  payload.code_verifier = code_verifier;
  payload.state = state;
  LS.save(payload);

  const authUrl = "https://accounts.spotify.com/authorize?" + enc({
    response_type: "code",
    client_id,
    code_challenge_method: "S256",
    code_challenge,
    redirect_uri,
    state,
    // scopes は不要（公開GETのみ）
    // scope: ""
  });
  location.assign(authUrl);
}

async function exchangeToken(){
  const params = new URLSearchParams(location.search);
  const code = params.get("code");
  const state = params.get("state");
  if(!code) return; // not returning from auth

  const st = LS.load();
  if(!st.code_verifier || !st.client_id || !st.redirect_uri || !st.state){
    log("PKCE情報が見つかりません。最初からやり直してください。");
    return;
  }
  if(state !== st.state){
    log("stateが一致しません。セキュリティ上、処理を中止します。");
    return;
  }

  log("トークン交換中…");
  const body = new URLSearchParams({
    grant_type: "authorization_code",
    code,
    redirect_uri: st.redirect_uri,
    client_id: st.client_id,
    code_verifier: st.code_verifier
  });

  const res = await fetch("https://accounts.spotify.com/api/token", {
    method: "POST",
    headers: {"Content-Type":"application/x-www-form-urlencoded"},
    body
  });
  const j = await res.json().catch(()=> ({}));
  if(!res.ok){
    log("トークン取得失敗: " + JSON.stringify(j));
    return;
  }

  st.access_token = j.access_token;
  st.refresh_token = j.refresh_token; // 返らない場合もある
  st.expires_at  = Date.now() + (j.expires_in*1000);
  LS.save(st);
  history.replaceState({}, "", st.redirect_uri); // URLをクリーンに
  log("トークン取得OK。");
  setTokenInfo();
}

async function refreshIfNeeded(){
  const st = LS.load();
  if(!st.access_token) return false;
  const left = st.expires_at - Date.now();
  if(left > 60000) return true; // 60秒以上残ってる

  if(!st.refresh_token){
    log("refresh_tokenが無いので再認証が必要です。");
    return false;
  }
  log("トークン更新中…");
  const body = new URLSearchParams({
    grant_type: "refresh_token",
    refresh_token: st.refresh_token,
    client_id: st.client_id
  });
  const res = await fetch("https://accounts.spotify.com/api/token", {
    method:"POST", headers:{"Content-Type":"application/x-www-form-urlencoded"}, body
  });
  const j = await res.json().catch(()=> ({}));
  if(!res.ok){
    log("更新失敗: " + JSON.stringify(j));
    return false;
  }
  st.access_token = j.access_token;
  if(j.refresh_token) st.refresh_token = j.refresh_token;
  st.expires_at = Date.now() + (j.expires_in*1000);
  LS.save(st);
  setTokenInfo();
  return true;
}

async function spGet(url){
  const st = LS.load();
  const ok = await refreshIfNeeded();
  if(!ok) throw new Error("access_tokenなし（再認証を実行してください）");
  const r = await fetch(url, { headers: { Authorization: "Bearer " + st.access_token }});
  if(!r.ok){
    const t = await r.text().catch(()=> "");
    throw new Error(`HTTP ${r.status} ${r.statusText}\\n${t}`);
  }
  return r.json();
}

async function spPaged(url, key="items"){
  let out=[], next=url;
  while(next){
    const j = await spGet(next);
    if(Array.isArray(j[key])) out.push(...j[key]);
    else if(Array.isArray(j.items)) out.push(...j.items);
    next = j.next;
    await new Promise(r=>setTimeout(r, 60));
  }
  return out;
}

function toCSVRow(arr){
  return arr.map(v=>{
    if(v==null) return "";
    const s=String(v);
    return (s.includes('"')||s.includes(",")||s.includes("\n"))? '"'+s.replace(/"/g,'""')+'"' : s;
  }).join(",");
}
function downloadCSV(rows, name){
  const blob = new Blob([rows.join("\n")], {type:"text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download=name; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

function setEq(a,b){ a=[...new Set(a)]; b=[...new Set(b)]; return a.length===b.length && a.every(x=>b.includes(x)); }

$("#loginBtn").addEventListener("click", authorize);

$("#runBtn").addEventListener("click", async ()=>{
  $("#runBtn").disabled = true;
  try{
    const market = $("#market").value || "JP";
    const artistId = $("#artistId").value.trim();
    const expected = ($("#expectedIds").value||"").split(",").map(s=>s.trim()).filter(Boolean);

    let albumIds = [];
    if(artistId){
      const groups = [
        $("#incAlbum").checked ? "album":null,
        $("#incSingle").checked ? "single":null,
        $("#incCompilation").checked ? "compilation":null
      ].filter(Boolean).join(",");
      log(`アーティスト ${artistId} のアルバム一覧取得（include_groups=${groups}）…`);
      const list = await spPaged(`https://api.spotify.com/v1/artists/${artistId}/albums?limit=50&include_groups=${groups}&market=${market}`);
      const seen = new Set();
      for(const a of list){ if(!seen.has(a.id)){ seen.add(a.id); albumIds.push(a.id); } }
      log(`→ ${albumIds.length}件`);
    }else{
      const raw = $("#albumList").value.trim();
      if(!raw) throw new Error("アーティストID か アルバムURL/ID を入力してください。");
      albumIds = raw.split(/\r?\n/).map(idFromUrlOrId).filter(Boolean);
    }

    const header = [
      "album_id","album_name","album_type","album_artists_ids","album_artists_names",
      "track_id","disc","track_number","track_name","duration_ms",
      "track_artists_ids","track_artists_names",
      "extra_artist_ids","extra_artist_names",
      "has_extra_artists","remix_in_title","expected_only","flag_suspected"
    ];
    const rows=[toCSVRow(header)];

    for(const aid of albumIds){
      log(`アルバム ${aid} 情報…`);
      const alb = await spGet(`https://api.spotify.com/v1/albums/${aid}?market=${market}`);
      const albumArtistIds = alb.artists.map(a=>a.id);
      const albumArtistNames = alb.artists.map(a=>a.name);
      const albumType = alb.album_type;

      const tracks = await spPaged(`https://api.spotify.com/v1/albums/${aid}/tracks?limit=50&market=${market}`);

      for(const t of tracks){
        const tIds = t.artists.map(a=>a.id);
        const tNames = t.artists.map(a=>a.name);
        const extraIds = tIds.filter(x=>!albumArtistIds.includes(x));
        const extraNames = t.artists.filter(a=>extraIds.includes(a.id)).map(a=>a.name);
        const remix = /\bremix\b/i.test(t.name);

        const expectedOnly = expected.length? setEq(tIds, expected) : null;
        const hasExtra = extraIds.length>0;
        // “プライマリーにRemixerが入った疑い”の簡易判定
        const suspected = hasExtra || (expected.length? !expectedOnly : false) || remix;

        rows.push(toCSVRow([
          alb.id, alb.name, albumType,
          albumArtistIds.join(";"), albumArtistNames.join(";"),
          t.id, t.disc_number, t.track_number, t.name, t.duration_ms,
          tIds.join(";"), tNames.join(";"),
          extraIds.join(";"), extraNames.join(";"),
          hasExtra, remix, expectedOnly, suspected
        ]));
      }
    }

    const filename = `spotify_primary_audit_${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}.csv`;
    downloadCSV(rows, filename);
    log(`完了。CSVをダウンロード → ${filename}`);
  }catch(e){
    console.error(e);
    log("ERROR: " + e.message);
  }finally{
    $("#runBtn").disabled = false;
  }
});

(function boot(){
  // 既定値の埋め込み（あなたの値に差し替えてOK）
  $("#clientId").value   = "CLIENT_ID_HERE";
  $("#redirectUri").value= "REDIRECT_URI_HERE";
  $("#artistId").value   = "55fvQ5I2IZUfcFT2DV02T3"; // TDCS

  exchangeToken().then(setTokenInfo);
  setInterval(setTokenInfo, 1000);
})();
</script>