<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TDCS Full Tracks Harvester — Ultra Safe v2 (UI v9)</title>
<link rel="preconnect" href="https://accounts.spotify.com"/>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root{
    --bg:#0b0d10; --card:#12161b; --muted:#9aa4af; --text:#e6edf3; --line:#1f2937;
    --acc:#4f46e5; --acc-2:#00b894; --warn:#f59e0b; --bad:#ef4444; --ok:#22c55e;
  }
  *{box-sizing:border-box}
  body{margin:0; background:var(--bg); color:var(--text); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans JP',sans-serif}
  header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg,rgba(18,22,27,.95),rgba(18,22,27,.85));backdrop-filter:blur(6px);border-bottom:1px solid var(--line)}
  .wrap{max-width:1100px;margin:0 auto;padding:18px}
  h1{margin:4px 0 10px;font-size:18px;font-weight:700}
  .row{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap}
  .pill{display:inline-flex;align-items:center;gap:.4rem;padding:.25rem .6rem;border:1px solid var(--line);border-radius:999px;font-size:12px;color:var(--muted)}
  .pill.ok{color:#0ad17a;border-color:#0ad17a26;background:#0ad17a14}
  .pill.bad{color:var(--bad);border-color:#ef444426;background:#ef444414}
  .pill.warn{color:var(--warn);border-color:#f59e0b26;background:#f59e0b14}
  .btn{padding:.65rem 1rem;border-radius:10px;border:1px solid #2b3340;background:#1a2230;color:#fff;cursor:pointer}
  .btn[disabled]{opacity:.5;cursor:not-allowed}
  .btn.primary{background:var(--acc);border-color:var(--acc)}
  .btn.ghost{background:#12161b;border-color:#2b3340}
  .btn.danger{background:#7f1d1d;border-color:#b91c1c}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:16px;margin:14px 0}
  .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:14px}
  .muted{color:var(--muted)}
  code,.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono','Courier New',monospace}
  details summary{cursor:pointer;color:#cbd5e1}
  .stepper{display:flex;gap:10px;align-items:center;margin:8px 0 0}
  .step{flex:1;display:flex;align-items:center;gap:.6rem;padding:.6rem;border:1px solid var(--line);border-radius:10px;background:#0f141a}
  .k{width:24px;height:24px;border-radius:6px;background:#111a;display:flex;align-items:center;justify-content:center;font-weight:700}
  .k.ok{background:#00b894}
  .k.wait{background:#f59e0b}
  .k.bad{background:#ef4444}
  .statusbar{position:sticky;bottom:0;z-index:5;background:linear-gradient(180deg,rgba(18,22,27,.85),rgba(18,22,27,.98));border-top:1px solid var(--line)}
  .log{white-space:pre-wrap;max-height:220px;overflow:auto;background:#0d1117;border:1px solid var(--line);border-radius:10px;padding:10px}
  progress{width:100%;height:10px}
  table{border-collapse:collapse;width:100%;font-size:12.5px}
  th,td{border:1px solid #1f2937;padding:.4rem .5rem;text-align:left;vertical-align:top}
  .banner{display:none;padding:.6rem .8rem;border-radius:10px;margin:8px 0;font-weight:600}
  .banner.bad{display:flex;background:#7f1d1d;color:#fff}
  .mini{font-size:12px}
  .kbd{border:1px solid var(--line);padding:.05rem .35rem;border-radius:6px;background:#0f141a}
  .stat{display:flex;gap:10px;flex-wrap:wrap}
  .stat .box{flex:1 0 160px;background:#0f141a;border:1px solid var(--line);border-radius:10px;padding:10px}
  .chip{display:inline-block;padding:.05rem .45rem;border:1px solid var(--line);border-radius:999px;margin:.05rem;font-size:12px}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row" style="justify-content:space-between">
      <div>
        <h1>TDCS Full Tracks Harvester — Ultra Safe v2</h1>
        <div class="muted mini">Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> / Redirect: <code>https://npr2025.github.io/spotify-auth/callback.html</code></div>
      </div>
      <div class="row">
        <a href="./auth.html?v=20250919-9"><button class="btn">Spotifyに接続</button></a>
        <button id="clearBtn" class="btn ghost">保存トークン削除</button>
        <span id="authStatus" class="pill">未接続</span>
      </div>
    </div>

    <!-- ステップ表示 -->
    <div class="stepper">
      <div class="step"><div id="s1" class="k">1</div><div><b>接続</b><div class="mini muted">トークン状態: <span id="tokState">-</span></div></div></div>
      <div class="step"><div id="s2" class="k">2</div><div><b>CSV</b><div class="mini muted"><span id="csvState">未読込</span></div></div></div>
      <div class="step"><div id="s3" class="k">3</div><div><b>クレンジング→出力</b><div class="mini muted">Various Artists 除外: <span id="vaState">ON</span></div></div></div>
    </div>
  </div>
</header>

<div class="wrap">
  <!-- 429バナー -->
  <div id="penaltyBanner" class="banner bad">RATE LIMIT: クールダウン中… 残り <span id="penaltyLeft">–</span>s</div>

  <!-- 状態チップ -->
  <div class="row">
    <span id="chipTok" class="pill">token: -</span>
    <span id="chipIdx" class="pill">catalog: -</span>
    <span id="chipCsv" class="pill">csv: -</span>
    <span id="chipRate" class="pill">rate: idle</span>
  </div>

  <!-- 左: 操作 / 右: プレビュー -->
  <div class="grid">
    <div>
      <section class="card">
        <h3>1) 入力と基本設定</h3>
        <div class="row" style="margin:.5rem 0 1rem">
          <input type="file" id="csvFile" accept=".csv" class="btn ghost" title="FUGA清書CSVなどを選択"/>
          <label class="mini muted">対応列: <code>spotify_url / UPC / ISRC / Album title / Album version / Track title</code></label>
        </div>

        <div class="row" style="gap:16px">
          <label class="mini"><input id="cleanUseUrl" type="checkbox" checked> URLで補完（track→album解決）</label>
          <label class="mini"><input id="excludeVA" type="checkbox" checked> Various Artists 全除外</label>
        </div>

        <details style="margin-top:10px">
          <summary>詳細設定</summary>
          <div class="row" style="margin-top:8px;gap:10px">
            <label>最小間隔(ms)：<input id="minDelayMs" type="number" value="3500" step="50" style="width:7rem"></label>
            <label>RPM上限：<input id="rpmCap" type="number" value="6" step="1" style="width:5rem"></label>
            <label>1時間予算：<input id="hourBudget" type="number" value="480" step="50" style="width:6rem"></label>
            <label>最大バックオフ(ms)：<input id="maxBackoffMs" type="number" value="30000" step="500" style="width:7rem"></label>
            <label>最大リトライ：<input id="maxRetries" type="number" value="6" step="1" style="width:5rem"></label>
            <label>429上限(ms)：<input id="cooldownCapMs" type="number" value="60000" step="5000" style="width:8rem"></label>
          </div>
          <div class="row" style="margin-top:6px;gap:10px">
            <label>albums?ids：<input id="albBatch" type="number" value="20" min="1" max="20" step="1" style="width:5rem"></label>
            <label>tracks?ids：<input id="trkBatch" type="number" value="40" min="1" max="50" step="1" style="width:5rem"></label>
            <label>ロングブレイク：<input id="longBreakEvery" type="number" value="160" step="10" style="width:5rem"> req / <input id="longBreakMs" type="number" value="240000" step="60000" style="width:7rem"> ms</label>
            <label class="mini"><input id="slowJitter" type="checkbox" checked> ジッターON</label>
            <label class="mini"><input id="strictNoSearch" type="checkbox" checked> search完全禁止</label>
          </div>
        </details>
      </section>

      <section class="card">
        <h3>2) カタログ・インデックス</h3>
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <button id="rebuildIdxBtn" class="btn ghost" title="全アルバムを取り直してキャッシュ更新">カタログ再取得</button>
            <span id="idxSource" class="muted mini">source: -</span>
          </div>
          <span id="indexPill" class="pill">idle</span>
        </div>
        <div id="indexLog" class="log mini" style="margin-top:8px"></div>
      </section>

      <section class="card">
        <h3>3) クレンジング → 書き出し</h3>
        <div class="row">
          <button id="cleanBtn" class="btn primary" disabled>Spotify配信ありだけ保存</button>
          <button id="cleanDroppedBtn" class="btn" disabled>落とした行を保存（理由付き）</button>
        </div>
        <div id="cleanStat" class="mini muted" style="margin-top:8px">-</div>

        <div class="stat" id="resultStats" style="display:none;margin-top:10px">
          <div class="box"><div class="mini muted">kept</div><div id="statKept" style="font-size:22px;font-weight:800">0</div></div>
          <div class="box"><div class="mini muted">dropped</div><div id="statDrop" style="font-size:22px;font-weight:800">0</div></div>
          <div class="box"><div class="mini muted">drop_reason 内訳</div><div id="reasonChips"></div></div>
        </div>
      </section>

      <section class="card">
        <h3>ログ / 進捗</h3>
        <div class="row" style="justify-content:space-between">
          <span id="ratePill" class="pill">idle</span>
          <progress id="prog" value="0" max="100" style="max-width:300px"></progress>
        </div>
        <div id="log" class="log" style="margin-top:8px"></div>
        <div class="row" style="margin-top:8px">
          <button id="startBtn" class="btn" disabled>（任意）収集を実行</button>
          <button id="pauseBtn" class="btn ghost" disabled>一時停止</button>
          <button id="resumeBtn" class="btn ghost" disabled>再開</button>
          <button id="clearChkBtn" class="btn danger">チェックポイント削除</button>
          <button id="diagBtn" class="btn ghost">接続診断</button>
        </div>
      </section>
    </div>

    <div>
      <section class="card">
        <h3>プレビュー（先頭10行）</h3>
        <div id="fileInfo" class="mini muted">CSV未読込</div>
        <table id="previewTbl"><thead></thead><tbody></tbody></table>
      </section>

      <section class="card">
        <h3>エクスポート</h3>
        <div class="row">
          <button id="downloadTracksBtn" class="btn" disabled>フルトラックCSV</button>
          <button id="downloadCheckpointBtn" class="btn" disabled>チェックポイントCSV</button>
        </div>
      </section>
    </div>
  </div>
</div>

<!-- フッター状態バー -->
<div class="statusbar">
  <div class="wrap row" style="justify-content:space-between">
    <div class="mini muted">Tips: 429が出たら自動で最大60秒だけ待機します。上の赤バナーに残秒が出ます。</div>
    <div class="row mini muted">
      <span>トークン: <span id="tokLeft">–</span></span>
      <span class="kbd">F5</span>で再読込
    </div>
  </div>
</div>

<script>
/*** ========== 基本設定 / ホワイトリスト ========== ***/
const TARGET_ARTIST_ID="55fvQ5I2IZUfcFT2DV02T3"; // TDCS
const CHECKPOINT_KEY="tdcs_fulltracks_checkpoint_v2";
const CATALOG_CACHE_KEY="tdcs_catalog_cache_v2_noVA";
const ALWAYS_KEEP_ALBUM_IDS = new Set([
  "06Yvg4vlPaVfnAWVwmJX27", // Roughside Out: B
  "4aeD4BUM5mAA1v1hCp9irx"  // Hype Of The One Sided
]);

/*** ========== DOMヘルパー ========== ***/
const $=s=>document.querySelector(s);
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const jitter=v=> ($("#slowJitter").checked? v+Math.floor(Math.random()*Math.floor(v*0.2)) : v);
function log(m){ const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function ilog(m){ const el=$("#indexLog"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function setRate(t){ $("#ratePill").textContent=t; $("#chipRate").textContent="rate: "+t; }
function fmtSec(s){const m=Math.floor(s/60),ss=s%60;return `${m}:${String(ss).padStart(2,'0')}`}

/*** ========== トークン関連 ========== ***/
function getTokObj(){ try{ return JSON.parse(localStorage.getItem("sp_token")||"null"); }catch{ return null; } }
function putTokObj(o){ localStorage.setItem("sp_token",JSON.stringify(o)); }
function tokenStatusText(){
  const o=getTokObj(); if(!o) return "未接続";
  const left=Math.max(0,Math.floor((o.expires_at-Date.now())/1000));
  return `OK（残り ${fmtSec(left)}） scope:${o.scope||"(none)"}`
}
async function refreshIfNeeded(){
  const o=getTokObj(); if(!o) throw new Error("no token");
  const skew=15000;
  if(Date.now()< (o.expires_at-skew)) return o.access_token;
  if(!o.refresh_token){ throw new Error("token expired (no refresh_token). 再認証してください。"); }
  const body=new URLSearchParams({ client_id:"378ef0f44b36499abd10d118ddbddc98", grant_type:"refresh_token", refresh_token:o.refresh_token });
  const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!res.ok){ throw new Error(`refresh failed: ${await res.text()}`); }
  const tok=await res.json();
  const next={ access_token: tok.access_token, token_type: tok.token_type||o.token_type||"Bearer", scope: tok.scope||o.scope||"", refresh_token: tok.refresh_token||o.refresh_token||"", expires_at: Date.now()+ (tok.expires_in||3600)*1000 - 10000 };
  putTokObj(next); return next.access_token;
}

/*** ========== レート制御 / API ========== ***/
let penaltyUntil=0; function inPenalty(){ return Date.now()<penaltyUntil; }
let reqCountMin=0, windowStart=Date.now();
let hourCount=0, hourStart=Date.now();

async function api(endpoint, params={}, opt={}){
  const base="https://api.spotify.com";
  const method=opt.method||"GET";
  const maxRetries=Number($("#maxRetries").value||6);
  const maxBackoff=Number($("#maxBackoffMs").value||30000);
  const minDelay=Number($("#minDelayMs").value||3500);
  const rpmCap=Number($("#rpmCap").value||6);
  const hourBudget=Number($("#hourBudget").value||480);
  const cooldownCapMs=Number($("#cooldownCapMs").value||60000);
  const longBreakEvery=Number($("#longBreakEvery").value||160);
  const longBreakMs=Number($("#longBreakMs").value||240000);

  const now=Date.now();
  if(now-windowStart>=60000){ windowStart=now; reqCountMin=0; }
  if(now-hourStart>=3600000){ hourStart=now; hourCount=0; }
  if(reqCountMin && (reqCountMin%longBreakEvery===0)){ setRate(`long break ${longBreakMs}ms`); await sleep(longBreakMs); }

  if(reqCountMin>=rpmCap){ const wait=60000-(now-windowStart)+50; setRate(`rpm-cap wait ${wait}ms`); await sleep(wait); }
  if(hourCount>=hourBudget){ setRate(`hour budget cooldown 60000ms`); await sleep(60000); hourStart=Date.now(); hourCount=0; }

  let baseDelay=jitter(minDelay);
  if(inPenalty()) baseDelay+=12000;
  await sleep(baseDelay);

  let url=base+endpoint;
  if(method==="GET" && params && Object.keys(params).length){
    const qs=new URLSearchParams(Object.entries(params).filter(([k,v])=>v!==undefined && v!==null));
    url+=`?${qs}`;
  }
  const token=await refreshIfNeeded();
  const headers={"Authorization":`Bearer ${token}`,"Accept":"application/json"};
  if(method!=="GET"){ headers["Content-Type"]="application/json"; }

  let attempt=0, backoff=800;
  while(true){
    try{
      const res=await fetch(url,{method,headers,body:method==="GET"?undefined:JSON.stringify(params)});
      reqCountMin++; hourCount++;

      if(res.status===401 && attempt===0){ await refreshIfNeeded(); attempt++; continue; }
      if(res.status===429){
        const ra=(Number(res.headers.get("Retry-After"))||60)*1000;
        const capped=Math.min(ra, cooldownCapMs);
        penaltyUntil=Date.now()+Math.max(capped,30000);
        const leftSec=Math.round((penaltyUntil-Date.now())/1000);
        $("#penaltyBanner").style.display="flex"; $("#penaltyLeft").textContent=leftSec;
        log(`[429] Retry-After(raw): ${Math.round(ra/1000)}s → cap ${Math.round(capped/1000)}s`);
        const err=new Error("RATE_LIMIT"); err.code=429; err.retryAfter=capped; throw err;
      }
      if(res.status>=500){
        if(attempt>=maxRetries) throw new Error(`HTTP ${res.status} ${await res.text()}`);
        setRate(`5xx backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++; continue;
      }
      if(!res.ok){ throw new Error(`HTTP ${res.status} ${await res.text()}`); }
      setRate("ok"); return await res.json();
    }catch(e){
      if(e && e.code===429){ throw e; }
      if(attempt>=maxRetries){ throw e; }
      setRate(`err backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++;
    }
  }
}

/*** ========== CSVユーティリティ ========== ***/
function detectCols(headers){
  const hmap={}; headers.forEach(h=>hmap[h.trim().toLowerCase()]=h);
  const get=(...c)=> c.map(s=>s.toLowerCase()).find(k=>hmap[k]) ? hmap[c.map(s=>s.toLowerCase()).find(k=>hmap[k])] : null;
  return { url:get("spotify_url","url","spotify"), upc:get("upc","pos","ean"), isrc:get("isrc"),
           album:get("album title","album","release"), version:get("album version","version","mix"), track:get("track title","title","track") };
}
function previewTable(rows){
  const tbl=$("#previewTbl");
  const headers=rows.length?Object.keys(rows[0]):[];
  tbl.querySelector("thead").innerHTML=`<tr>${headers.map(h=>`<th>${h}</th>`).join("")}</tr>`;
  const bodyRows=rows.slice(0,10).map(r=>`<tr>${headers.map(h=>`<td>${(r[h]??"")}</td>`).join("")}</tr>`).join("");
  tbl.querySelector("tbody").innerHTML=bodyRows||"<tr><td>（なし）</td></tr>";
}
function digits(s){ return String(s||"").replace(/\D+/g,""); }
function toCSV(rows){
  if(!rows || !rows.length) return "";
  const headers=Object.keys(rows[0]);
  const esc=v=>{ const x=v==null?"":String(v).replace(/"/g,'""'); return /[",\n]/.test(x)?`"${x}"`:x; };
  return [headers.join(","),...rows.map(r=>headers.map(h=>esc(r[h])).join(","))].join("\n");
}
function parseSpotifyId(u){
  if(!u) return null;
  try{
    if(u.startsWith("spotify:")){
      const parts=u.split(":"); return {type:parts[1], id:parts[2]};
    }
    const url=new URL(u);
    const seg=url.pathname.split("/").filter(Boolean);
    const type=seg[0], id=seg[1]?.split("?")[0];
    if(type && id) return {type,id};
  }catch{}
  return null;
}

/*** ========== VA（Various Artists）判定 ========== ***/
function isVariousArtistsAlbum(alb){
  if(!alb) return false;
  const primary = (alb.artists && alb.artists[0] && (alb.artists[0].name||"")) || "";
  const hasTarget = (alb.artists||[]).some(a=>a && a.id===TARGET_ARTIST_ID);
  const isVAName = /^(various artists)$/i.test(primary.trim());
  const isCompNoTarget = (alb.album_type==="compilation" && !hasTarget);
  return isVAName || isCompNoTarget;
}

/*** ========== カタログ構造 / キャッシュ ========== ***/
const Catalog = {
  albumIds: new Set(),
  albumById: new Map(),    // id -> {id, name, url, upc, artists, album_type, ...}
  upcToAlbumId: new Map(), // upcDigits -> id
  nameToIds: new Map(),
};
function norm(s){ return String(s||"").toLowerCase().replace(/[^\p{Letter}\p{Number}]+/gu," ").trim(); }
function saveCatalogCache(){
  const obj={
    albumIds:[...Catalog.albumIds],
    albumById:[...Catalog.albumById.entries()],
    upcToAlbumId:[...Catalog.upcToAlbumId.entries()],
    nameToIds:[...Catalog.nameToIds.entries()]
  };
  localStorage.setItem(CATALOG_CACHE_KEY, JSON.stringify(obj));
  $("#idxSource").textContent="source: cache(saved)";
}
function loadCatalogCache(){
  try{
    const raw=localStorage.getItem(CATALOG_CACHE_KEY);
    if(!raw) return false;
    const obj=JSON.parse(raw);
    Catalog.albumIds=new Set(obj.albumIds||[]);
    Catalog.albumById=new Map(obj.albumById||[]);
    Catalog.upcToAlbumId=new Map(obj.upcToAlbumId||[]);
    Catalog.nameToIds=new Map(obj.nameToIds||[]);
    return Catalog.upcToAlbumId.size>0;
  }catch{return false;}
}
function clearCatalogCache(){ localStorage.removeItem(CATALOG_CACHE_KEY); }

/*** ========== フルカタログ取得（手動） ========== ***/
let buildingIndex=false;
async function buildCatalogIndex(){
  if(buildingIndex){ ilog('[index] already building; skip'); return; }
  buildingIndex=true;
  try{
    setIndexState("building…");
    $("#idxSource").textContent="source: live";
    ilog(`[index] fetch artist albums for ${TARGET_ARTIST_ID}`);

    let offset=0, got=0, seen=new Set(), consec429=0;
    while(true){
      let page;
      try{
        page=await api(`/v1/artists/${TARGET_ARTIST_ID}/albums`,{
          include_groups:"album,single,compilation,appears_on",
          limit:50, offset
        });
        consec429=0;
      }catch(e){
        if(e && e.code===429){
          const w=(e.retryAfter||60000);
          ilog(`[index] 429 wait ${Math.round(w/1000)}s (offset=${offset})`);
          await sleep(w + jitter(500));
          consec429++;
          if(consec429>=3){ ilog(`[index] extra cooldown 30s`); await sleep(30000); consec429=0; }
          continue;
        } else { throw e; }
      }
      const items=page.items||[];
      for(const a of items){
        if(!a || !a.id || seen.has(a.id)) continue;
        seen.add(a.id);
        Catalog.albumIds.add(a.id);
      }
      got+=items.length; ilog(`[index] fetched ${got} albums (unique:${Catalog.albumIds.size})`);
      if(!page.next || !items.length) break;
      offset+=items.length;
    }

    // hydrate + VA除外
    const ids=[...Catalog.albumIds]; Catalog.albumIds.clear();
    const batchSize=Math.min(20, Number($("#albBatch").value||20));
    for(let i=0;i<ids.length;i+=batchSize){
      const slice=ids.slice(i,i+batchSize);
      let resp;
      try{
        resp=await api(`/v1/albums`,{ids:slice.join(",")});
      }catch(e){
        if(e && e.code===429){
          const w=(e.retryAfter||60000);
          ilog(`[index] 429 wait ${Math.round(w/1000)}s (hydrate i=${i})`);
          await sleep(w + jitter(500));
          i-=batchSize; continue;
        } else { throw e; }
      }
      for(const alb of (resp.albums||[])){
        if(!alb || !alb.id) continue;
        if($("#excludeVA").checked && !ALWAYS_KEEP_ALBUM_IDS.has(alb.id) && isVariousArtistsAlbum(alb)) continue;
        const upc=digits(alb.external_ids?.upc||"");
        Catalog.albumIds.add(alb.id);
        Catalog.albumById.set(alb.id,{
          id:alb.id, name:alb.name||"",
          url:alb.external_urls?.spotify||`https://open.spotify.com/album/${alb.id}`,
          upc, label:alb.label||"", release_date:alb.release_date||"",
          artists: alb.artists||[], album_type: alb.album_type||""
        });
        const nm=norm(alb.name||"");
        if(upc) Catalog.upcToAlbumId.set(upc, alb.id);
        if(nm){ if(!Catalog.nameToIds.has(nm)) Catalog.nameToIds.set(nm,[]); Catalog.nameToIds.get(nm).push(alb.id); }
      }
      ilog(`[index] albums hydrated: ${Math.min(i+batchSize,ids.length)}/${ids.length}`);
      await sleep(jitter(Number($("#batchPauseMs").value||1200)));
    }

    await hydrateForcedAlbumsFirst(true);
    ilog(`[index] UPC mapped: ${Catalog.upcToAlbumId.size} (VA:${$("#excludeVA").checked?"OFF除外:ON":"OFF"})`);
    saveCatalogCache();
    setIndexState("ready");
    $("#chipIdx").className="pill ok"; $("#chipIdx").textContent="catalog: ready";
  }catch(e){
    ilog(`[index err] ${e.message||e}`); setIndexState("error"); $("#chipIdx").className="pill bad"; $("#chipIdx").textContent="catalog: error";
  }finally{
    buildingIndex=false;
  }
}

/*** ========== 強制アルバムを先に収載 ========== ***/
async function hydrateForcedAlbumsFirst(quiet=false){
  const need=[...ALWAYS_KEEP_ALBUM_IDS].filter(id=>!Catalog.albumById.has(id));
  if(!need.length){
    setIndexState("ready(partial)"); $("#idxSource").textContent="source: forced"; return;
  }
  for(let i=0;i<need.length;i+=20){
    let resp;
    try{ resp=await api(`/v1/albums`,{ids:need.slice(i,i+20).join(",")}); }
    catch(e){
      if(e && e.code===429){
        const w=(e.retryAfter||60000);
        ilog(`[index] 429 wait ${Math.round(w/1000)}s (forced)`); await sleep(w+500); i-=20; continue;
      } else { throw e; }
    }
    for(const alb of (resp.albums||[])){
      if(!alb || !alb.id) continue;
      const upc=digits(alb.external_ids?.upc||"");
      Catalog.albumIds.add(alb.id);
      Catalog.albumById.set(alb.id,{
        id:alb.id, name:alb.name||"",
        url:alb.external_urls?.spotify||`https://open.spotify.com/album/${alb.id}`,
        upc, label:alb.label||"", release_date:alb.release_date||"",
        artists: alb.artists||[], album_type: alb.album_type||""
      });
      const nm=norm(alb.name||"");
      if(nm){ if(!Catalog.nameToIds.has(nm)) Catalog.nameToIds.set(nm,[]); Catalog.nameToIds.get(nm).push(alb.id); }
      if(upc) Catalog.upcToAlbumId.set(upc, alb.id);
    }
  }
  setIndexState("ready(partial)"); $("#idxSource").textContent="source: forced";
  $("#chipIdx").className="pill ok"; $("#chipIdx").textContent="catalog: ready(partial)";
}

/*** ========== インデックス準備（自動は“強制+キャッシュ”） ========== ***/
async function ensureIndex(){
  if(Catalog.upcToAlbumId.size>0){ setIndexState("ready"); $("#idxSource").textContent="source: live/cache"; return; }
  await hydrateForcedAlbumsFirst(true);
  if(loadCatalogCache()){
    setIndexState("ready"); $("#idxSource").textContent="source: cache";
    ilog(`[index] loaded from cache (UPC mapped: ${Catalog.upcToAlbumId.size})`);
    $("#chipIdx").className="pill ok"; $("#chipIdx").textContent="catalog: ready"; return;
  }
}

/*** ========== URL→アルバム解決（track→album対応） ========== ***/
async function urlAlbum(u){
  const p=parseSpotifyId(u); if(!p) return null;
  if(p.type==="album"){ try{ return await api(`/v1/albums/${p.id}`,{});}catch{return null;} }
  if(p.type==="track" && $("#cleanUseUrl").checked){
    try{
      const tr=await api(`/v1/tracks/${p.id}`,{});
      if(tr && tr.album){ return await api(`/v1/albums/${tr.album.id}`,{}); }
    }catch(e){ return null; }
  }
  return null;
}

/*** ========== 収集（任意） ========== ***/
async function harvestAlbumTracksFull(albumId, sourceKey, albumUrl){
  const alb = Catalog.albumById.get(albumId) || await api(`/v1/albums/${albumId}`, {});
  if($("#excludeVA").checked && !ALWAYS_KEEP_ALBUM_IDS.has(albumId) && isVariousArtistsAlbum(alb)){
    log(`[harvest skip] VA除外 album:${albumId}`); return [];
  }
  const tracks=[]; let offset=0;
  while(true){
    const page=await api(`/v1/albums/${albumId}/tracks`, {limit:50, offset});
    (page.items||[]).forEach(x=>{ tracks.push({id:x.id,name:x.name,disc_number:x.disc_number,track_number:x.track_number,artists:(x.artists||[]).map(a=>a.name).join(" & ")}); });
    offset += page.items?.length||0;
    await sleep(jitter(Number($("#pagePauseMs").value||300)));
    if(!page.next) break;
  }
  const batchSize=Math.min(50, Number($("#trkBatch").value||40));
  const out=[];
  for(let i=0;i<tracks.length;i+=batchSize){
    const slice=tracks.slice(i,i+batchSize);
    const ids=slice.map(t=>t.id).filter(Boolean).join(",");
    if(!ids) continue;
    const resp=await api(`/v1/tracks`, {ids});
    const full=(resp.tracks||[]);
    for(const simp of slice){
      const f=full.find(x=>x && x.id===simp.id);
      if(!f) continue;
      out.push({
        source_key: sourceKey, album_id: albumId,
        album_url: albumUrl||alb.external_urls?.spotify||`https://open.spotify.com/album/${albumId}`,
        album_name: (alb.name||alb.album_name||""), album_label: (alb.label||""),
        album_release_date: (alb.release_date||""), album_upc: digits(alb.external_ids?.upc||""),
        track_id: f.id, track_name: f.name||simp.name,
        disc_number: f.disc_number||simp.disc_number||"", track_number: f.track_number||simp.track_number||"",
        duration_ms: f.duration_ms||"", explicit: f.explicit?"true":"false",
        isrc: (f.external_ids&&f.external_ids.isrc)||"", artists: (f.artists||[]).map(a=>a.name).join(" & "),
        preview_url: f.preview_url||""
      });
    }
    await sleep(jitter(Number($("#batchPauseMs").value||1200)));
  }
  return out;
}

/*** ========== 実行状態/チェックポイント ========== ***/
let g={rows:[],cols:{},uniqueKeys:[],rowsByKey:null,results:[],doneKeys:new Set(),running:false,fileName:''};
let stopSignal=false;
function loadCheckpoint(){ try{ const cp=JSON.parse(localStorage.getItem(CHECKPOINT_KEY)||"null"); if(!cp) return null; g.doneKeys=new Set(cp.done||[]); g.results=cp.results||[]; return cp; }catch{return null;} }
function saveCheckpoint(){ const cp={ done:[...g.doneKeys], results:g.results }; localStorage.setItem(CHECKPOINT_KEY, JSON.stringify(cp)); $("#downloadCheckpointBtn").disabled=false; }
function clearCheckpoint(){ localStorage.removeItem(CHECKPOINT_KEY); g.doneKeys=new Set(); g.results=[]; $("#downloadCheckpointBtn").disabled=true; }

function buildRowsByKey(rows, cols){
  const map=new Map();
  for(const r of rows){
    const k = (cols.upc && r[cols.upc]) ? `upc:${String(r[cols.upc]).trim()}` :
              (cols.isrc && r[cols.isrc]) ? `isrc:${String(r[cols.isrc]).trim()}` :
              (cols.url && r[cols.url]) ? `url:${String(r[cols.url]).trim()}` :
              `txt:${(r[cols.album]||"")} | ${(r[cols.version]||"")} | ${(r[cols.track]||"")}`;
    if(!map.has(k)) map.set(k,[]);
    map.get(k).push(r);
  }
  return map;
}
function refreshAuthStatus(){
  const txt=tokenStatusText();
  $("#authStatus").textContent=txt;
  $("#tokState").textContent=txt.replace("トークン","token");
  const hasTok=!!getTokObj();
  $("#chipTok").textContent=hasTok? "token: ok" : "token: -";
  $("#chipTok").className="pill "+(hasTok?"ok":"bad");
  $("#s1").className="k "+(hasTok?"ok":"bad");
}
function maybeEnableStart(){ $("#startBtn").disabled = !(g.rows?.length>0 && !!getTokObj()); }

/*** ========== クレンジング ========== ***/
async function ensureIndexAndMark(){
  await ensureIndex();
  $("#indexPill").textContent="ready";
}
async function urlMatchesAlbumOrTrack(u){
  const alb=await urlAlbum(u);
  if(!alb) return {ok:false, reason:"url_not_in_artist_catalog"};
  if($("#excludeVA").checked && !ALWAYS_KEEP_ALBUM_IDS.has(alb.id) && isVariousArtistsAlbum(alb)){
    return {ok:false, reason:"excluded_various_artists"};
  }
  return {ok:true, album:alb};
}
async function cleanseRows(){
  await ensureIndexAndMark();
  const rows=g.rows||[]; const cols=g.cols||{};
  const allowUPC=new Set([...Catalog.upcToAlbumId.keys()]);
  const kept=[], dropped=[];
  for(const r of rows){
    const url=cols.url? String(r[cols.url]||"").trim() : "";
    const upc=cols.upc? digits(r[cols.upc]||"") : "";
    const title = cols.album ? String(r[cols.album]||"") : "";
    const version = cols.version ? String(r[cols.version]||"") : "";
    const nameKey = (title+" "+version).toLowerCase().replace(/[^\p{Letter}\p{Number}]+/gu," ").trim()
                    || title.toLowerCase().replace(/[^\p{Letter}\p{Number}]+/gu," ").trim();

    let keep=false, reason="";
    if(upc && allowUPC.has(upc)){ keep=true; r.__keep_reason="upc_match"; }
    else if(url){
      const chk=await urlMatchesAlbumOrTrack(url);
      if(chk.ok){ keep=true; r.__keep_reason="url_match"; }
      else{ reason=chk.reason; }
    }
    else if(nameKey && Catalog.nameToIds.has(nameKey)){ keep=true; r.__keep_reason="title_match"; }

    if(!keep){
      if(!reason){
        if(!upc && !url) reason="missing_identifiers";
        else if(upc && !allowUPC.has(upc)) reason="upc_not_in_artist_catalog";
        else reason="url_not_in_artist_catalog";
      }
      const dr=Object.assign({}, r); dr.drop_reason=reason; dropped.push(dr);
    }else{
      kept.push(r);
    }
  }
  $("#cleanStat").textContent=`kept:${kept.length} / dropped:${dropped.length}`;
  // 内訳チップ
  const counts={}; dropped.forEach(d=>{ const k=d.drop_reason||"unknown"; counts[k]=(counts[k]||0)+1; });
  const chips=Object.entries(counts).map(([k,v])=>`<span class="chip">${k}: ${v}</span>`).join("");
  $("#reasonChips").innerHTML=chips||"<span class='chip'>no drops</span>";
  $("#statKept").textContent=kept.length; $("#statDrop").textContent=dropped.length;
  $("#resultStats").style.display="flex";

  $("#cleanBtn").disabled = kept.length===0;
  $("#cleanDroppedBtn").disabled = dropped.length===0;
  return {kept,dropped};
}
let lastClean={kept:[],dropped:[]};
async function handleClean(){
  try{
    lastClean = await cleanseRows();
    log(`[clean] kept:${lastClean.kept.length} dropped:${lastClean.dropped.length}`);
  }catch(e){ log(`[clean err] ${e.message||e}`); }
}
function download(name, csv){
  const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href);
}

/*** ========== ラン（任意） ========== ***/
async function run(){
  await ensureIndex();
  g.running=true; $("#pauseBtn").disabled=false; $("#startBtn").disabled=true; $("#resumeBtn").disabled=true;
  const total=g.uniqueKeys.length; let done=0;
  for(const key of g.uniqueKeys){
    if(g.doneKeys.has(key)){ done++; $("#prog").value=Math.round(done/total*100); continue; }
    if(stopSignal){ g.running=false; $("#resumeBtn").disabled=false; $("#pauseBtn").disabled=true; log("一時停止"); return; }
    log(`Resolve: ${key} → cleanerモードでは収集スキップ`);
    g.doneKeys.add(key);
    done++; $("#prog").value=Math.round(done/total*100);
    if(done%3===0) saveCheckpoint();
  }
  saveCheckpoint(); $("#pauseBtn").disabled=true; g.running=false; log("完了");
}

/*** ========== 起動時フック ========== ***/
window.addEventListener("load", ()=>{
  // トークン表示
  $("#authStatus").textContent = tokenStatusText();
  refreshAuthStatus();

  // 強制アルバムだけ先に確保（軽量）
  hydrateForcedAlbumsFirst(true).catch(e=>ilog(`[index forced err] ${e.message||e}`));

  // ボタン
  $("#clearBtn").onclick=()=>{ localStorage.removeItem("sp_token"); refreshAuthStatus(); maybeEnableStart(); };
  $("#rebuildIdxBtn").onclick=()=>{ clearCatalogCache(); Catalog.albumIds.clear(); Catalog.albumById.clear(); Catalog.upcToAlbumId.clear(); Catalog.nameToIds.clear(); ilog("[index] cache cleared"); setIndexState("idle"); $("#idxSource").textContent="source: -"; buildCatalogIndex().catch(e=>ilog(`[index err] ${e.message||e}`)); };

  $("#diagBtn").onclick=async()=>{
    const t=getTokObj(); if(!t){ log("[diag] no token"); return; }
    const left=Math.max(0,Math.floor((t.expires_at-Date.now())/1000));
    log(`[diag] token present scope:${t.scope||"(none)"} exp_in:${left}s`);
    try{ const me=await api("/v1/me", {}); log(`[diag] me.id:${me.id||"-"} country:${me.country||"-"} product:${me.product||"-"}`); }catch(e){ log(`[diag] /me skipped: ${e.message||e}`); }
  };

  $("#csvFile").addEventListener("change",(ev)=>{
    const f=ev.target.files?.[0]; if(!f) return;
    g.fileName=f.name;
    Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{
      g.rows=res.data||[];
      g.cols=detectCols(res.meta.fields||[]);
      $("#fileInfo").textContent = `[CSV] loaded: ${g.rows.length} rows from ${f.name}\n[CSV] detected columns: ${JSON.stringify({url:g.cols.url,upc:g.cols.upc,isrc:g.cols.isrc,album:g.cols.album,version:g.cols.version,track:g.cols.track})}`;
      previewTable(g.rows);
      g.rowsByKey=buildRowsByKey(g.rows,g.cols);
      g.uniqueKeys=[...g.rowsByKey.keys()];
      $("#csvState").textContent=`${g.rows.length} 行読み込み`;
      $("#chipCsv").className="pill ok"; $("#chipCsv").textContent="csv: loaded";
      $("#s2").className="k ok";
      log(`Unique keys: ${g.uniqueKeys.length}`);
      const cp=loadCheckpoint(); if(cp){ log(`resume: ${g.doneKeys.size} processed`); $("#downloadCheckpointBtn").disabled=false; } else { log(`no checkpoint to resume`); }
      maybeEnableStart();
      $("#cleanBtn").disabled=false;
      $("#cleanDroppedBtn").disabled=false;
    }});
  });

  $("#startBtn").onclick=()=>{ run(); };
  $("#pauseBtn").onclick=()=>{ stopSignal=true; };
  $("#resumeBtn").onclick=()=>{ if(!g.running){ stopSignal=false; run(); } };
  $("#clearChkBtn").onclick=()=>{ clearCheckpoint(); log("checkpoint cleared"); };

  $("#cleanBtn").onclick=async()=>{
    if(!g.rows.length){ alert("CSVを読み込んでください"); return; }
    await handleClean();
    const csv=toCSV(lastClean.kept);
    download(`Spotify配信ありのみ_${g.fileName||'out'}.csv`,csv);
  };
  $("#cleanDroppedBtn").onclick=async()=>{
    if(!g.rows.length){ alert("CSVを読み込んでください"); return; }
    if(!lastClean.dropped.length){ await handleClean(); }
    const csv=toCSV(lastClean.dropped);
    download(`Spotify未配信や対象外_${g.fileName||'out'}.csv`,csv);
  };

  // 1秒おきに状態更新（トークン残 / 429残）
  setInterval(()=>{
    // token
    const o=getTokObj();
    if(o){
      const left=Math.max(0,Math.floor((o.expires_at-Date.now())/1000));
      $("#tokLeft").textContent=fmtSec(left);
      $("#tokState").textContent=tokenStatusText();
      $("#s1").className="k ok";
      $("#chipTok").className="pill ok"; $("#chipTok").textContent="token: ok";
    }else{
      $("#tokLeft").textContent="–"; $("#s1").className="k bad";
      $("#chipTok").className="pill bad"; $("#chipTok").textContent="token: -";
    }
    // 429 banner
    const leftMs=penaltyUntil-Date.now();
    if(leftMs>0){
      $("#penaltyBanner").style.display="flex";
      $("#penaltyLeft").textContent=Math.ceil(leftMs/1000);
    }else{
      $("#penaltyBanner").style.display="none";
    }
    $("#vaState").textContent=$("#excludeVA").checked?"ON":"OFF";
  },1000);
});
</script>
</body>
</html>
