<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TDCS Full Tracks Harvester — Ultra Safe v2 (no-search, 60s cap, cached index, forced-first, no-VA)</title>
<link rel="preconnect" href="https://accounts.spotify.com"/>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial,'Noto Sans JP';margin:2rem}
  .card{border:1px solid #ddd;border-radius:10px;padding:1rem;margin-bottom:1rem}
  .row{display:flex;flex-wrap:wrap;gap:1rem;align-items:center}
  button{padding:.6rem 1rem;border-radius:8px;border:1px solid #999;background:#111;color:#fff;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=file]{border:1px dashed #bbb;padding:.75rem;border-radius:8px;background:#fafafa}
  code,.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono','Courier New',monospace}
  .muted{color:#666}.ok{color:#0a7f29}.bad{color:#b00020}
  progress{width:100%;height:14px}
  table{border-collapse:collapse;width:100%}th,td{border:1px solid #eee;padding:.5rem;font-size:.9rem;text-align:left}
  .pill{display:inline-block;padding:.1rem .5rem;border:1px solid #ccc;border-radius:999px;font-size:.8rem;background:#f6f6f6}
  .small{font-size:.85rem}
</style>
</head>
<body>
<header class="card">
  <h1>TDCS Full Tracks Harvester — Ultra Safe v2</h1>
  <div class="small muted">Client ID: <code>378ef0f44b36499abd10d118ddbddc98</code> | Redirect: <code>https://npr2025.github.io/spotify-auth/callback.html</code></div>
  <div class="row">
    <a href="./auth.html?v=20250919-8"><button>Spotifyに接続</button></a>
    <button id="clearBtn" style="background:#eee;color:#111;border-color:#bbb">保存トークン削除</button>
    <span id="authStatus" class="muted">未接続</span>
  </div>
</header>

<section class="card">
  <h2>入力と実行設定</h2>
  <div class="row">
    <input type="file" id="csvFile" accept=".csv"/>
    <label>最小間隔(ms)：<input id="minDelayMs" type="number" value="3500" step="50" style="width:7rem"></label>
    <label>RPM上限(1分)：<input id="rpmCap" type="number" value="6" step="1" style="width:5rem"></label>
    <label>1時間予算(req)：<input id="hourBudget" type="number" value="480" step="50" style="width:6rem"></label>
    <label>最大バックオフ(ms)：<input id="maxBackoffMs" type="number" value="30000" step="500" style="width:7rem"></label>
    <label>最大リトライ：<input id="maxRetries" type="number" value="6" step="1" style="width:5rem"></label>
    <label>429上限(ms)：<input id="cooldownCapMs" type="number" value="60000" step="5000" style="width:8rem"></label>
  </div>
  <div class="row">
    <label>アルバムバッチ間隔(ms)：<input id="batchPauseMs" type="number" value="1200" step="100" style="width:7rem"></label>
    <label>トラックページ間隔(ms)：<input id="pagePauseMs" type="number" value="300" step="50" style="width:6rem"></label>
    <label>tracks?ids バッチ(≤50)：<input id="trkBatch" type="number" value="40" min="1" max="50" step="1" style="width:5rem"></label>
    <label>albums?ids バッチ(≤20)：<input id="albBatch" type="number" value="20" min="1" max="20" step="1" style="width:5rem"></label>
    <label>ロングブレイク：<input id="longBreakEvery" type="number" value="160" step="10" style="width:5rem"> req毎 / <input id="longBreakMs" type="number" value="240000" step="60000" style="width:7rem"> ms</label>
    <label><input id="slowJitter" type="checkbox" checked> ジッターON</label>
    <label><input id="strictNoSearch" type="checkbox" checked> search完全禁止</label>
    <label><input id="excludeVA" type="checkbox" checked> Various Artists 全除外</label>
  </div>
  <div class="row">
    <label><input id="scanAllTracks" type="checkbox" checked> 全アルバムでトラック走査（フル）</label>
    <button id="startBtn" disabled>開始</button>
    <button id="pauseBtn" disabled>一時停止</button>
    <button id="resumeBtn" disabled>再開</button>
    <button id="clearChkBtn">チェックポイント削除</button>
    <button id="diagBtn" style="background:#0a7f29;border-color:#0a7f29">接続診断</button>
  </div>
  <div id="fileInfo" class="small muted"></div>
  <div class="small muted">対応列：<code>spotify_url / UPC / ISRC / Album title / Album version / Track title</code></div>
</section>

<section class="card">
  <h2>カタログ・インデックス <span id="indexPill" class="pill">idle</span></h2>
  <div class="row">
    <button id="rebuildIdxBtn" style="background:#eee;color:#111;border-color:#bbb">カタログ再取得</button>
    <span id="idxSource" class="small muted">source: -</span>
  </div>
  <div id="indexLog" class="mono small" style="white-space:pre-wrap;max-height:160px;overflow:auto"></div>
</section>

<section class="card">
  <h2>クレンジング（Spotify未配信/対象外の潰し）</h2>
  <div class="row">
    <label><input id="cleanUseUrl" type="checkbox" checked> URLで補完（track→album解決を許可）</label>
    <button id="cleanBtn" disabled>Spotify配信ありだけ保存</button>
    <button id="cleanDroppedBtn" disabled>落とした行を保存</button>
    <span id="cleanStat" class="muted small"></span>
  </div>
  <div class="small muted">判定基準：<code>UPC ∈ (対象アーティストのSpotifyカタログ)</code> または <code>URLがそのアルバム/トラック（→アルバム）</code> に一致。ISRC検索は使いません。<br/>※「Various Artists」は常に除外（既定ON）。</div>
</section>

<section class="card">
  <h2>進捗 <span id="ratePill" class="pill">idle</span></h2>
  <progress id="prog" value="0" max="100"></progress>
  <div id="log" class="mono" style="white-space:pre-wrap;max-height:260px;overflow:auto"></div>
</section>

<section class="card">
  <h2>エクスポート</h2>
  <div class="row">
    <button id="downloadTracksBtn" disabled>フルトラックCSV</button>
    <button id="downloadCheckpointBtn" disabled>チェックポイントCSV</button>
  </div>
</section>

<section class="card">
  <h2>プレビュー（10行）</h2>
  <table id="previewTbl"><thead></thead><tbody></tbody></table>
</section>

<script>
/*** 基本設定 ***/
const TARGET_ARTIST_ID="55fvQ5I2IZUfcFT2DV02T3"; // TDCS
const CHECKPOINT_KEY="tdcs_fulltracks_checkpoint_v2";
const CATALOG_CACHE_KEY="tdcs_catalog_cache_v2_noVA";

/* 手動で常に許可したいアルバム（即インデックスへ収載） */
const ALWAYS_KEEP_ALBUM_IDS = new Set([
  "06Yvg4vlPaVfnAWVwmJX27", // Roughside Out: B
  "4aeD4BUM5mAA1v1hCp9irx"  // Hype Of The One Sided
]);

/*** DOM / 小物 ***/
const $=s=>document.querySelector(s);
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
const jitter=v=> ($("#slowJitter").checked? v+Math.floor(Math.random()*Math.floor(v*0.2)) : v);
function log(m){ const el=$("#log"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function ilog(m){ const el=$("#indexLog"); el.textContent+=m+"\n"; el.scrollTop=el.scrollHeight; }
function setRate(t){ $("#ratePill").textContent=t; }
function setIndexState(t){ $("#indexPill").textContent=t; }
function fmtSec(s){const m=Math.floor(s/60),ss=s%60;return `${m}:${String(ss).padStart(2,'0')}`}

/*** トークン ***/
function getTokObj(){ try{ return JSON.parse(localStorage.getItem("sp_token")||"null"); }catch{ return null; } }
function tokenStatusText(){
  const o=getTokObj(); if(!o) return "未接続";
  const left=Math.max(0,Math.floor((o.expires_at-Date.now())/1000));
  return `トークンOK（残り ${fmtSec(left)}） scope:${o.scope||"(none)"}`
}
async function refreshIfNeeded(){
  const o=getTokObj(); if(!o) throw new Error("no token");
  const skew=15000;
  if(Date.now()< (o.expires_at-skew)) return o.access_token;
  if(!o.refresh_token){ throw new Error("token expired (no refresh_token). 再認証してください。"); }
  const body=new URLSearchParams({ client_id:"378ef0f44b36499abd10d118ddbddc98", grant_type:"refresh_token", refresh_token:o.refresh_token });
  const res=await fetch("https://accounts.spotify.com/api/token",{method:"POST",headers:{"Content-Type":"application/x-www-form-urlencoded"},body});
  if(!res.ok){ throw new Error(`refresh failed: ${await res.text()}`); }
  const tok=await res.json();
  const next={ access_token: tok.access_token, token_type: tok.token_type||o.token_type||"Bearer", scope: tok.scope||o.scope||"", refresh_token: tok.refresh_token||o.refresh_token||"", expires_at: Date.now()+ (tok.expires_in||3600)*1000 - 10000 };
  localStorage.setItem("sp_token",JSON.stringify(next));
  return next.access_token;
}

/*** レート制御 & API ***/
let penaltyUntil=0;
function inPenalty(){ return Date.now()<penaltyUntil; }

let reqCountMin=0, windowStart=Date.now();
let hourCount=0, hourStart=Date.now();

async function api(endpoint, params={}, opt={}){
  const base="https://api.spotify.com";
  const method=opt.method||"GET";
  const maxRetries=Number($("#maxRetries").value||6);
  const maxBackoff=Number($("#maxBackoffMs").value||30000);
  const minDelay=Number($("#minDelayMs").value||3500);
  const rpmCap=Number($("#rpmCap").value||6);
  const hourBudget=Number($("#hourBudget").value||480);
  const cooldownCapMs=Number($("#cooldownCapMs").value||60000);
  const longBreakEvery=Number($("#longBreakEvery").value||160);
  const longBreakMs=Number($("#longBreakMs").value||240000);

  const now=Date.now();
  if(now-windowStart>=60000){ windowStart=now; reqCountMin=0; }
  if(now-hourStart>=3600000){ hourStart=now; hourCount=0; }
  if(reqCountMin && (reqCountMin%longBreakEvery===0)){ setRate(`long break ${longBreakMs}ms`); await sleep(longBreakMs); }

  if(reqCountMin>=rpmCap){ const wait=60000-(now-windowStart)+50; setRate(`rpm-cap wait ${wait}ms`); await sleep(wait); }
  if(hourCount>=hourBudget){ setRate(`hour budget cooldown 60000ms`); await sleep(60000); hourStart=Date.now(); hourCount=0; }

  let baseDelay=jitter(minDelay);
  if(inPenalty()) baseDelay+=12000;
  await sleep(baseDelay);

  let url=base+endpoint;
  if(method==="GET" && params && Object.keys(params).length){
    const qs=new URLSearchParams(Object.entries(params).filter(([k,v])=>v!==undefined && v!==null));
    url+=`?${qs}`;
  }
  const token=await refreshIfNeeded();
  const headers={"Authorization":`Bearer ${token}`,"Accept":"application/json"};
  if(method!=="GET"){ headers["Content-Type"]="application/json"; }

  let attempt=0, backoff=800;
  while(true){
    try{
      const res=await fetch(url,{method,headers,body:method==="GET"?undefined:JSON.stringify(params)});
      reqCountMin++; hourCount++;

      if(res.status===401 && attempt===0){ await refreshIfNeeded(); attempt++; continue; }
      if(res.status===429){
        const ra=(Number(res.headers.get("Retry-After"))||60)*1000;
        const capped=Math.min(ra, cooldownCapMs);
        penaltyUntil=Date.now()+Math.max(capped,30000);
        log(`[429] Retry-After(raw): ${Math.round(ra/1000)}s → cap ${Math.round(capped/1000)}s`);
        const err=new Error("RATE_LIMIT"); err.code=429; err.retryAfter=capped; throw err;
      }
      if(res.status>=500){
        if(attempt>=maxRetries) throw new Error(`HTTP ${res.status} ${await res.text()}`);
        setRate(`5xx backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++; continue;
      }
      if(!res.ok){ throw new Error(`HTTP ${res.status} ${await res.text()}`); }
      setRate("ok"); return await res.json();
    }catch(e){
      if(e && e.code===429){ throw e; }
      if(attempt>=maxRetries){ throw e; }
      setRate(`err backoff ${backoff}ms`); await sleep(backoff); backoff=Math.min(maxBackoff,backoff*2); attempt++;
    }
  }
}

/*** CSV/テーブルユーティリティ ***/
function detectCols(headers){
  const hmap={}; headers.forEach(h=>hmap[h.trim().toLowerCase()]=h);
  const get=(...c)=> c.map(s=>s.toLowerCase()).find(k=>hmap[k]) ? hmap[c.map(s=>s.toLowerCase()).find(k=>hmap[k])] : null;
  return { url:get("spotify_url","url","spotify"), upc:get("upc","pos","ean"), isrc:get("isrc"),
           album:get("album title","album","release"), version:get("album version","version","mix"), track:get("track title","title","track") };
}
function previewTable(rows){
  const tbl=$("#previewTbl");
  const headers=rows.length?Object.keys(rows[0]):[];
  tbl.querySelector("thead").innerHTML=`<tr>${headers.map(h=>`<th>${h}</th>`).join("")}</tr>`;
  const bodyRows=rows.slice(0,10).map(r=>`<tr>${headers.map(h=>`<td>${(r[h]??"")}</td>`).join("")}</tr>`).join("");
  tbl.querySelector("tbody").innerHTML=bodyRows||"<tr><td>（なし）</td></tr>";
}
function digits(s){ return String(s||"").replace(/\D+/g,""); }
function toCSV(rows){
  if(!rows || !rows.length) return "";
  const headers=Object.keys(rows[0]);
  const esc=v=>{ const x=v==null?"":String(v).replace(/"/g,'""'); return /[",\n]/.test(x)?`"${x}"`:x; };
  return [headers.join(","),...rows.map(r=>headers.map(h=>esc(r[h])).join(","))].join("\n");
}
function parseSpotifyId(u){
  if(!u) return null;
  try{
    if(u.startsWith("spotify:")){
      const parts=u.split(":"); return {type:parts[1], id:parts[2]};
    }
    const url=new URL(u);
    const seg=url.pathname.split("/").filter(Boolean);
    const type=seg[0], id=seg[1]?.split("?")[0];
    if(type && id) return {type,id};
  }catch{}
  return null;
}

/*** VA（Various Artists）判定 ***/
function isVariousArtistsAlbum(alb){
  if(!alb) return false;
  const primary = (alb.artists && alb.artists[0] && (alb.artists[0].name||"")) || "";
  const hasTarget = (alb.artists||[]).some(a=>a && a.id===TARGET_ARTIST_ID);
  const isVAName = /^(various artists)$/i.test(primary.trim());
  const isCompNoTarget = (alb.album_type==="compilation" && !hasTarget);
  return isVAName || isCompNoTarget;
}

/*** カタログオブジェクト & 正規化 ***/
const Catalog = {
  albumIds: new Set(),
  albumById: new Map(),    // id -> {id, name, url, upc, artists, album_type, ...}
  upcToAlbumId: new Map(), // upcDigits -> id
  nameToIds: new Map(),
};
function norm(s){ return String(s||"").toLowerCase().replace(/[^\p{Letter}\p{Number}]+/gu," ").trim(); }

/*** カタログキャッシュ ***/
function saveCatalogCache(){
  const obj={
    albumIds:[...Catalog.albumIds],
    albumById:[...Catalog.albumById.entries()],
    upcToAlbumId:[...Catalog.upcToAlbumId.entries()],
    nameToIds:[...Catalog.nameToIds.entries()]
  };
  localStorage.setItem(CATALOG_CACHE_KEY, JSON.stringify(obj));
  $("#idxSource").textContent="source: cache(saved)";
}
function loadCatalogCache(){
  try{
    const raw=localStorage.getItem(CATALOG_CACHE_KEY);
    if(!raw) return false;
    const obj=JSON.parse(raw);
    Catalog.albumIds=new Set(obj.albumIds||[]);
    Catalog.albumById=new Map(obj.albumById||[]);
    Catalog.upcToAlbumId=new Map(obj.upcToAlbumId||[]);
    Catalog.nameToIds=new Map(obj.nameToIds||[]);
    return Catalog.upcToAlbumId.size>0;
  }catch{return false;}
}
function clearCatalogCache(){ localStorage.removeItem(CATALOG_CACHE_KEY); }

/*** フルカタログ取得（必要時のみ） ***/
async function buildCatalogIndex(){
  setIndexState("building…");
  $("#idxSource").textContent="source: live";
  ilog(`[index] fetch artist albums for ${TARGET_ARTIST_ID}`);

  let offset=0, got=0, seen=new Set(), consec429=0;
  while(true){
    let page;
    try{
      page=await api(`/v1/artists/${TARGET_ARTIST_ID}/albums`,{
        include_groups:"album,single,compilation,appears_on", // 取得広め→後段でVA除外
        limit:50, offset
      });
      consec429=0;
    }catch(e){
      if(e && e.code===429){
        const w=(e.retryAfter||60000);
        ilog(`[index] 429 wait ${Math.round(w/1000)}s (offset=${offset})`);
        await sleep(w + jitter(500));
        consec429++;
        if(consec429>=3){ ilog(`[index] extra cooldown 30s`); await sleep(30000); consec429=0; }
        continue;
      } else { throw e; }
    }
    const items=page.items||[];
    for(const a of items){
      if(!a || !a.id || seen.has(a.id)) continue;
      seen.add(a.id);
      Catalog.albumIds.add(a.id); // hydrate時にVA除外確定
    }
    got+=items.length; ilog(`[index] fetched ${got} albums (unique:${Catalog.albumIds.size})`);
    if(!page.next || !items.length) break;
    offset+=items.length;
  }

  // hydrate（/v1/albums?ids）、ここで VA 除外
  const ids=[...Catalog.albumIds];
  Catalog.albumIds.clear();
  const batchSize=Math.min(20, Number($("#albBatch").value||20));
  for(let i=0;i<ids.length;i+=batchSize){
    const slice=ids.slice(i,i+batchSize);
    let resp;
    try{
      resp=await api(`/v1/albums`,{ids:slice.join(",")});
    }catch(e){
      if(e && e.code===429){
        const w=(e.retryAfter||60000);
        ilog(`[index] 429 wait ${Math.round(w/1000)}s (hydrate i=${i})`);
        await sleep(w + jitter(500));
        i-=batchSize; continue;
      } else { throw e; }
    }
    for(const alb of (resp.albums||[])){
      if(!alb || !alb.id) continue;
      if($("#excludeVA").checked && !ALWAYS_KEEP_ALBUM_IDS.has(alb.id) && isVariousArtistsAlbum(alb)){
        continue; // VAは完全除外
      }
      const upc=digits(alb.external_ids?.upc||"");
      Catalog.albumIds.add(alb.id);
      Catalog.albumById.set(alb.id,{
        id:alb.id, name:alb.name||"",
        url:alb.external_urls?.spotify||`https://open.spotify.com/album/${alb.id}`,
        upc, label:alb.label||"", release_date:alb.release_date||"",
        artists: alb.artists||[], album_type: alb.album_type||""
      });
      const nm=norm(alb.name||"");
      if(upc) Catalog.upcToAlbumId.set(upc, alb.id);
      if(nm){ if(!Catalog.nameToIds.has(nm)) Catalog.nameToIds.set(nm,[]); Catalog.nameToIds.get(nm).push(alb.id); }
    }
    ilog(`[index] albums hydrated: ${Math.min(i+batchSize,ids.length)}/${ids.length}`);
    await sleep(jitter(Number($("#batchPauseMs").value||1200)));
  }

  // ALWAYS_KEEP を確実に収載
  await hydrateForcedAlbumsFirst(/*quiet*/true);

  ilog(`[index] UPC mapped: ${Catalog.upcToAlbumId.size} (VA除外:${$("#excludeVA").checked?"ON":"OFF"})`);
  saveCatalogCache();
  setIndexState("ready");
}

/*** “強制アルバムを先に”収載（ホットフィックス） ***/
async function hydrateForcedAlbumsFirst(quiet=false){
  const need=[...ALWAYS_KEEP_ALBUM_IDS].filter(id=>!Catalog.albumById.has(id));
  if(!need.length){
    setIndexState("ready(partial)");
    $("#idxSource").textContent="source: forced";
    if(!quiet) ilog(`[index] forced albums already present`);
    return;
  }
  for(let i=0;i<need.length;i+=20){
    let resp;
    try{
      resp=await api(`/v1/albums`,{ids:need.slice(i,i+20).join(",")});
    }catch(e){
      if(e && e.code===429){
        const w=(e.retryAfter||60000);
        ilog(`[index] 429 wait ${Math.round(w/1000)}s (forced)`);
        await sleep(w + 500);
        i-=20; continue;
      } else { throw e; }
    }
    for(const alb of (resp.albums||[])){
      if(!alb || !alb.id) continue;
      const upc=digits(alb.external_ids?.upc||"");
      Catalog.albumIds.add(alb.id);
      Catalog.albumById.set(alb.id,{
        id:alb.id, name:alb.name||"",
        url:alb.external_urls?.spotify||`https://open.spotify.com/album/${alb.id}`,
        upc, label:alb.label||"", release_date:alb.release_date||"",
        artists: alb.artists||[], album_type: alb.album_type||""
      });
      const nm=norm(alb.name||"");
      if(nm){ if(!Catalog.nameToIds.has(nm)) Catalog.nameToIds.set(nm,[]); Catalog.nameToIds.get(nm).push(alb.id); }
      if(upc) Catalog.upcToAlbumId.set(upc, alb.id);
    }
  }
  setIndexState("ready(partial)");
  $("#idxSource").textContent="source: forced";
  if(!quiet) ilog(`[index] forced include albums: ${need.length}`);
}

/*** インデックス利用（自動は“強制だけ / キャッシュ”、フルは手動） ***/
async function ensureIndex(){
  if(Catalog.upcToAlbumId.size>0){ setIndexState("ready"); $("#idxSource").textContent="source: live/cache"; return; }

  // ① まず ALWAYS_KEEP を即収載（小規模で429に強い）
  await hydrateForcedAlbumsFirst();

  // ② キャッシュがあればそれで ready（重い取得はしない）
  if(loadCatalogCache()){
    setIndexState("ready");
    $("#idxSource").textContent="source: cache";
    ilog(`[index] loaded from cache (UPC mapped: ${Catalog.upcToAlbumId.size})`);
    return;
  }

  // ③ フルはユーザー操作で（[カタログ再取得]ボタン）
}

/*** URL→アルバム解決（track→album対応） ***/
async function urlAlbum(u){
  const p=parseSpotifyId(u); if(!p) return null;
  if(p.type==="album"){ try{ return await api(`/v1/albums/${p.id}`,{});}catch{return null;} }
  if(p.type==="track" && $("#cleanUseUrl").checked){
    try{
      const tr=await api(`/v1/tracks/${p.id}`,{});
      if(tr && tr.album){ return await api(`/v1/albums/${tr.album.id}`,{}); }
    }catch(e){ return null; }
  }
  return null;
}

/*** 収集 ***/
async function harvestAlbumTracksFull(albumId, sourceKey, albumUrl){
  const alb = Catalog.albumById.get(albumId) || await api(`/v1/albums/${albumId}`, {});
  if($("#excludeVA").checked && !ALWAYS_KEEP_ALBUM_IDS.has(albumId) && isVariousArtistsAlbum(alb)){
    log(`[harvest skip] VA除外 album:${albumId}`); return [];
  }
  const tracks=[]; let offset=0;
  while(true){
    const page=await api(`/v1/albums/${albumId}/tracks`, {limit:50, offset});
    (page.items||[]).forEach(x=>{ tracks.push({id:x.id,name:x.name,disc_number:x.disc_number,track_number:x.track_number,artists:(x.artists||[]).map(a=>a.name).join(" & ")}); });
    offset += page.items?.length||0;
    await sleep(jitter(Number($("#pagePauseMs").value||300)));
    if(!page.next) break;
  }
  const batchSize=Math.min(50, Number($("#trkBatch").value||40));
  const out=[];
  for(let i=0;i<tracks.length;i+=batchSize){
    const slice=tracks.slice(i,i+batchSize);
    const ids=slice.map(t=>t.id).filter(Boolean).join(",");
    if(!ids) continue;
    const resp=await api(`/v1/tracks`, {ids});
    const full=(resp.tracks||[]);
    for(const simp of slice){
      const f=full.find(x=>x && x.id===simp.id);
      if(!f) continue;
      out.push({
        source_key: sourceKey,
        album_id: albumId,
        album_url: albumUrl||alb.external_urls?.spotify||`https://open.spotify.com/album/${albumId}`,
        album_name: (alb.name||alb.album_name||""),
        album_label: (alb.label||""),
        album_release_date: (alb.release_date||""),
        album_upc: digits(alb.external_ids?.upc||""),
        track_id: f.id, track_name: f.name||simp.name,
        disc_number: f.disc_number||simp.disc_number||"",
        track_number: f.track_number||simp.track_number||"",
        duration_ms: f.duration_ms||"", explicit: f.explicit?"true":"false",
        isrc: (f.external_ids&&f.external_ids.isrc)||"",
        artists: (f.artists||[]).map(a=>a.name).join(" & "),
        preview_url: f.preview_url||""
      });
    }
    await sleep(jitter(Number($("#batchPauseMs").value||1200)));
  }
  return out;
}

/*** 実行状態/チェックポイント ***/
let g={rows:[],cols:{},uniqueKeys:[],rowsByKey:null,results:[],doneKeys:new Set(),running:false,fileName:''};
let stopSignal=false;
function loadCheckpoint(){ try{ const cp=JSON.parse(localStorage.getItem(CHECKPOINT_KEY)||"null"); if(!cp) return null; g.doneKeys=new Set(cp.done||[]); g.results=cp.results||[]; return cp; }catch{return null;} }
function saveCheckpoint(){ const cp={ done:[...g.doneKeys], results:g.results }; localStorage.setItem(CHECKPOINT_KEY, JSON.stringify(cp)); $("#downloadCheckpointBtn").disabled=false; }
function clearCheckpoint(){ localStorage.removeItem(CHECKPOINT_KEY); g.doneKeys=new Set(); g.results=[]; $("#downloadCheckpointBtn").disabled=true; }

function buildRowsByKey(rows, cols){
  const map=new Map();
  for(const r of rows){
    const k = (cols.upc && r[cols.upc]) ? `upc:${String(r[cols.upc]).trim()}` :
              (cols.isrc && r[cols.isrc]) ? `isrc:${String(r[cols.isrc]).trim()}` :
              (cols.url && r[cols.url]) ? `url:${String(r[cols.url]).trim()}` :
              `txt:${(r[cols.album]||"")} | ${(r[cols.version]||"")} | ${(r[cols.track]||"")}`;
    if(!map.has(k)) map.set(k,[]);
    map.get(k).push(r);
  }
  return map;
}
function refreshAuthStatus(){ $("#authStatus").textContent = tokenStatusText(); }
function maybeEnableStart(){ $("#startBtn").disabled = !(g.rows?.length>0 && !!getTokObj()); }

/*** クレンジング ***/
async function cleanseRows(){
  await ensureIndex();
  const rows=g.rows||[]; const cols=g.cols||{};
  const allowUPC=new Set([...Catalog.upcToAlbumId.keys()]);
  const kept=[], dropped=[];
  for(const r of rows){
    const url=cols.url? String(r[cols.url]||"").trim() : "";
    const upc=cols.upc? digits(r[cols.upc]||"") : "";
    const title = cols.album ? String(r[cols.album]||"") : "";
    const version = cols.version ? String(r[cols.version]||"") : "";
    const nameKey = (title+" "+version).toLowerCase().replace(/[^\p{Letter}\p{Number}]+/gu," ").trim()
                    || title.toLowerCase().replace(/[^\p{Letter}\p{Number}]+/gu," ").trim();

    let keep=false, reason="";
    // 1) UPC一致（VAはインデックス時点で除外済）
    if(upc && allowUPC.has(upc)){ keep=true; r.__keep_reason="upc_match"; }
    // 2) URL一致（track→album解決 / VAは不許可）
    else if(url){
      const alb=await urlAlbum(url);
      if(alb){
        if($("#excludeVA").checked && !ALWAYS_KEEP_ALBUM_IDS.has(alb.id) && isVariousArtistsAlbum(alb)){
          reason="excluded_various_artists";
        }else{
          keep=true; r.__keep_reason="url_match";
        }
      }else{
        reason="url_not_in_artist_catalog";
      }
    }
    // 3) タイトル一致フォールバック（インデックスでVA除外済）
    else if(nameKey && Catalog.nameToIds.has(nameKey)){
      keep=true; r.__keep_reason="title_match";
    }

    if(!keep){
      if(!reason){
        if(!upc && !url) reason="missing_identifiers";
        else if(upc && !allowUPC.has(upc)) reason="upc_not_in_artist_catalog";
        else reason="url_not_in_artist_catalog";
      }
      const dr=Object.assign({}, r); dr.drop_reason=reason; dropped.push(dr);
    }else{
      kept.push(r);
    }
  }
  $("#cleanStat").textContent=`kept:${kept.length} / dropped:${dropped.length}`;
  $("#cleanBtn").disabled = kept.length===0;
  $("#cleanDroppedBtn").disabled = dropped.length===0;
  return {kept,dropped};
}

let lastClean={kept:[],dropped:[]};
async function handleClean(){
  try{
    lastClean = await cleanseRows();
    log(`[clean] kept:${lastClean.kept.length} dropped:${lastClean.dropped.length}`);
  }catch(e){ log(`[clean err] ${e.message||e}`); }
}
function download(name, csv){
  const blob=new Blob([csv],{type:"text/csv;charset=utf-8"});
  const a=document.createElement("a"); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href);
}

/*** ラン（収集は任意。クリーナー主体なら未使用でもOK） ***/
async function run(){
  await ensureIndex();
  g.running=true; stopSignal=false; $("#pauseBtn").disabled=false; $("#startBtn").disabled=true; $("#resumeBtn").disabled=true;
  const total=g.uniqueKeys.length; let done=0;
  for(const key of g.uniqueKeys){
    if(g.doneKeys.has(key)){ done++; $("#prog").value=Math.round(done/total*100); continue; }
    if(stopSignal){ g.running=false; $("#resumeBtn").disabled=false; $("#pauseBtn").disabled=true; log("一時停止"); return; }
    log(`Resolve: ${key} → cleanerモードでは収集スキップ`);
    g.doneKeys.add(key);
    done++; $("#prog").value=Math.round(done/total*100);
    if(done%3===0) saveCheckpoint();
  }
  saveCheckpoint(); $("#pauseBtn").disabled=true; g.running=false; log("完了");
}

/*** 起動 ***/
window.addEventListener("load", async ()=>{
  $("#authStatus").textContent = tokenStatusText();

  $("#clearBtn").onclick=()=>{ localStorage.removeItem("sp_token"); $("#authStatus").textContent = tokenStatusText(); maybeEnableStart(); };
  $("#rebuildIdxBtn").onclick=()=>{ clearCatalogCache(); Catalog.albumIds.clear(); Catalog.albumById.clear(); Catalog.upcToAlbumId.clear(); Catalog.nameToIds.clear(); ilog("[index] cache cleared"); setIndexState("idle"); $("#idxSource").textContent="source: -"; buildCatalogIndex().catch(e=>ilog(`[index err] ${e.message||e}`)); };

  $("#diagBtn").onclick=async()=>{
    const t=getTokObj();
    if(!t){ log("[diag] no token"); return; }
    log(`[diag] token present scope:${t.scope||"(none)"} exp_in:${Math.max(0,Math.floor((JSON.parse(localStorage.getItem("sp_token")).expires_at-Date.now())/1000))}s`);
    try{ const me=await api("/v1/me", {}); log(`[diag] me.id:${me.id||"-"} country:${me.country||"-"} product:${me.product||"-"}`); }catch(e){ log(`[diag] /me skipped: ${e.message||e}`); }
  };

  $("#csvFile").addEventListener("change",(ev)=>{
    const f=ev.target.files?.[0]; if(!f) return;
    g.fileName=f.name;
    Papa.parse(f,{header:true,skipEmptyLines:true,complete:(res)=>{
      g.rows=res.data||[];
      g.cols=detectCols(res.meta.fields||[]);
      $("#fileInfo").textContent = `[CSV] loaded: ${g.rows.length} rows from ${f.name}\n[CSV] detected columns: ${JSON.stringify({url:g.cols.url,upc:g.cols.upc,isrc:g.cols.isrc,album:g.cols.album,version:g.cols.version,track:g.cols.track})}`;
      previewTable(g.rows);
      g.rowsByKey=buildRowsByKey(g.rows,g.cols);
      g.uniqueKeys=[...g.rowsByKey.keys()];
      log(`Unique keys: ${g.uniqueKeys.length}`);
      const cp=loadCheckpoint(); if(cp){ log(`resume: ${g.doneKeys.size} processed`); $("#downloadCheckpointBtn").disabled=false; } else { log(`no checkpoint to resume`); }
      maybeEnableStart();
      $("#cleanBtn").disabled=false;
      $("#cleanDroppedBtn").disabled=false;
    }});
  });

  $("#startBtn").onclick=()=>{ run(); };
  $("#pauseBtn").onclick=()=>{ stopSignal=true; };
  $("#resumeBtn").onclick=()=>{ if(!g.running){ stopSignal=false; run(); } };
  $("#clearChkBtn").onclick=()=>{ clearCheckpoint(); log("checkpoint cleared"); };

  $("#cleanBtn").onclick=async()=>{
    if(!g.rows.length){ alert("CSVを読み込んでください"); return; }
    await handleClean();
    const csv=toCSV(lastClean.kept);
    download(`Spotify配信ありのみ_${g.fileName||'out'}.csv`,csv);
  };
  $("#cleanDroppedBtn").onclick=async()=>{
    if(!g.rows.length){ alert("CSVを読み込んでください"); return; }
    if(!lastClean.dropped.length){ await handleClean(); }
    const csv=toCSV(lastClean.dropped);
    download(`Spotify未配信や対象外_${g.fileName||'out'}.csv`,csv);
  };

  // 起動時に“強制アルバムだけ”先に収載（軽量・安全）
  hydrateForcedAlbumsFirst().catch(e=>ilog(`[index forced err] ${e.message||e}`));

  setInterval(()=>{ $("#authStatus").textContent = tokenStatusText(); $("#resumeBtn").disabled = g.running || g.uniqueKeys.length===0; maybeEnableStart(); }, 1000);
});
</script>
</body>
</html>
